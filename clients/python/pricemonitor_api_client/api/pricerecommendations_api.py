# coding: utf-8

"""
    Omnia 2.0 API The Omnia 2.0 API is RESTful and provides access to the backend of Omnia 2.0 and Pricemonitor. It is used to manage products, offers, contracts, and more.  This API supports both public endpoints for customer integration and internal endpoints for platform management. All endpoints are authenticated using either Basic Authentication or JWT Bearer tokens.

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)  # noqa: E501

    The version of the OpenAPI document: 0.0.7200
    Generated by: https://openapi-generator.tech
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from pricemonitor_api_client.api_client import ApiClient
from pricemonitor_api_client.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError
)


class PricerecommendationsApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def decide_price_recommendations_approvals_v3(self, contract_id, com_patagona_pricemonitor_share_api_post_price_recommendation_approval_request_v3, **kwargs):  # noqa: E501
        """Set price recommendation approvals  # noqa: E501

        Processes bulk decisions for price recommendation approvals. Only pending price recommendations can be decided.  ## Notes - *Approval* refers to the price approval flow concept in our business processes, covering all states of price recommendations within this flow (i.e., pending, approved, rejected). The term does not mean all price recommendations are approved. - We preserve a linear history: Once a price recommendation approval is **finalized** (i.e., no longer pending), it can no longer be changed. - If any user rejects, the entire price recommendation is rejected. - If a user has already submitted an active (not superseded) decision for a recommendation, they cannot submit another. - The endpoint is not idempotent, as submitting a decision changes the approval state.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.decide_price_recommendations_approvals_v3(contract_id, com_patagona_pricemonitor_share_api_post_price_recommendation_approval_request_v3, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: Unique identifier of the contract (required)
        :param list[ComPatagonaPricemonitorShareApiPostPriceRecommendationApprovalRequestV3] com_patagona_pricemonitor_share_api_post_price_recommendation_approval_request_v3: The request body contains a list of price decisions to process.  (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: BooleanBulkApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.decide_price_recommendations_approvals_v3_with_http_info(contract_id, com_patagona_pricemonitor_share_api_post_price_recommendation_approval_request_v3, **kwargs)  # noqa: E501

    def decide_price_recommendations_approvals_v3_with_http_info(self, contract_id, com_patagona_pricemonitor_share_api_post_price_recommendation_approval_request_v3, **kwargs):  # noqa: E501
        """Set price recommendation approvals  # noqa: E501

        Processes bulk decisions for price recommendation approvals. Only pending price recommendations can be decided.  ## Notes - *Approval* refers to the price approval flow concept in our business processes, covering all states of price recommendations within this flow (i.e., pending, approved, rejected). The term does not mean all price recommendations are approved. - We preserve a linear history: Once a price recommendation approval is **finalized** (i.e., no longer pending), it can no longer be changed. - If any user rejects, the entire price recommendation is rejected. - If a user has already submitted an active (not superseded) decision for a recommendation, they cannot submit another. - The endpoint is not idempotent, as submitting a decision changes the approval state.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.decide_price_recommendations_approvals_v3_with_http_info(contract_id, com_patagona_pricemonitor_share_api_post_price_recommendation_approval_request_v3, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: Unique identifier of the contract (required)
        :param list[ComPatagonaPricemonitorShareApiPostPriceRecommendationApprovalRequestV3] com_patagona_pricemonitor_share_api_post_price_recommendation_approval_request_v3: The request body contains a list of price decisions to process.  (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(BooleanBulkApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'com_patagona_pricemonitor_share_api_post_price_recommendation_approval_request_v3'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method decide_price_recommendations_approvals_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `decide_price_recommendations_approvals_v3`")  # noqa: E501
        # verify the required parameter 'com_patagona_pricemonitor_share_api_post_price_recommendation_approval_request_v3' is set
        if self.api_client.client_side_validation and ('com_patagona_pricemonitor_share_api_post_price_recommendation_approval_request_v3' not in local_var_params or  # noqa: E501
                                                        local_var_params['com_patagona_pricemonitor_share_api_post_price_recommendation_approval_request_v3'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `com_patagona_pricemonitor_share_api_post_price_recommendation_approval_request_v3` when calling `decide_price_recommendations_approvals_v3`")  # noqa: E501

        if self.api_client.client_side_validation and ('contract_id' in local_var_params and  # noqa: E501
                                                        len(local_var_params['contract_id']) < 1):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `contract_id` when calling `decide_price_recommendations_approvals_v3`, length must be greater than or equal to `1`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'com_patagona_pricemonitor_share_api_post_price_recommendation_approval_request_v3' in local_var_params:
            body_params = local_var_params['com_patagona_pricemonitor_share_api_post_price_recommendation_approval_request_v3']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/vendor/contracts/{contractId}/pricerecommendations/approvals/decide', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BooleanBulkApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_repricing_strategy_vendor_v2(self, contract_id, **kwargs):  # noqa: E501
        """Delete repricing strategy  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_repricing_strategy_vendor_v2(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: Unique identifier of the contract (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_repricing_strategy_vendor_v2_with_http_info(contract_id, **kwargs)  # noqa: E501

    def delete_repricing_strategy_vendor_v2_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Delete repricing strategy  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_repricing_strategy_vendor_v2_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: Unique identifier of the contract (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_repricing_strategy_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `delete_repricing_strategy_vendor_v2`")  # noqa: E501

        if self.api_client.client_side_validation and ('contract_id' in local_var_params and  # noqa: E501
                                                        len(local_var_params['contract_id']) < 1):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `contract_id` when calling `delete_repricing_strategy_vendor_v2`, length must be greater than or equal to `1`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/settings/repricingstrategy', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_price_recommendation(self, contract_id, start_time, end_time, start, **kwargs):  # noqa: E501
        """Get price recommendations for time range  # noqa: E501

        Retrieves all price recommendations for a contract within the specified time range.  This endpoint returns algorithmic pricing recommendations based on market analysis, competitor pricing, and configured pricing strategies. Only the most recent recommendations are returned when multiple recommendations exist for the same product.  **Key Features:** - Paginated results for efficient data retrieval - Optional product tag inclusion - Configurable time range filtering - Real-time market-based recommendations   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_price_recommendation(contract_id, start_time, end_time, start, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: Unique identifier of the contract (required)
        :param datetime start_time: **Start of time range** for price recommendation retrieval.  Format: ISO 8601 date-time in UTC (e.g., `2024-01-15T10:30:00Z`)  (required)
        :param datetime end_time: **End of time range** for price recommendation retrieval.  Format: ISO 8601 date-time in UTC (e.g., `2024-01-16T10:30:00Z`)  (required)
        :param int start: Starting index for pagination (0-based) (required)
        :param int limit: Maximum number of price recommendations to return per page
        :param bool include_tags: Whether to include product tags in the response
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: GetPriceRecommendationApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_price_recommendation_with_http_info(contract_id, start_time, end_time, start, **kwargs)  # noqa: E501

    def get_price_recommendation_with_http_info(self, contract_id, start_time, end_time, start, **kwargs):  # noqa: E501
        """Get price recommendations for time range  # noqa: E501

        Retrieves all price recommendations for a contract within the specified time range.  This endpoint returns algorithmic pricing recommendations based on market analysis, competitor pricing, and configured pricing strategies. Only the most recent recommendations are returned when multiple recommendations exist for the same product.  **Key Features:** - Paginated results for efficient data retrieval - Optional product tag inclusion - Configurable time range filtering - Real-time market-based recommendations   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_price_recommendation_with_http_info(contract_id, start_time, end_time, start, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: Unique identifier of the contract (required)
        :param datetime start_time: **Start of time range** for price recommendation retrieval.  Format: ISO 8601 date-time in UTC (e.g., `2024-01-15T10:30:00Z`)  (required)
        :param datetime end_time: **End of time range** for price recommendation retrieval.  Format: ISO 8601 date-time in UTC (e.g., `2024-01-16T10:30:00Z`)  (required)
        :param int start: Starting index for pagination (0-based) (required)
        :param int limit: Maximum number of price recommendations to return per page
        :param bool include_tags: Whether to include product tags in the response
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(GetPriceRecommendationApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'start_time',
            'end_time',
            'start',
            'limit',
            'include_tags'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_price_recommendation" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_price_recommendation`")  # noqa: E501
        # verify the required parameter 'start_time' is set
        if self.api_client.client_side_validation and ('start_time' not in local_var_params or  # noqa: E501
                                                        local_var_params['start_time'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `start_time` when calling `get_price_recommendation`")  # noqa: E501
        # verify the required parameter 'end_time' is set
        if self.api_client.client_side_validation and ('end_time' not in local_var_params or  # noqa: E501
                                                        local_var_params['end_time'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `end_time` when calling `get_price_recommendation`")  # noqa: E501
        # verify the required parameter 'start' is set
        if self.api_client.client_side_validation and ('start' not in local_var_params or  # noqa: E501
                                                        local_var_params['start'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `start` when calling `get_price_recommendation`")  # noqa: E501

        if self.api_client.client_side_validation and ('contract_id' in local_var_params and  # noqa: E501
                                                        len(local_var_params['contract_id']) < 1):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `contract_id` when calling `get_price_recommendation`, length must be greater than or equal to `1`")  # noqa: E501
        if self.api_client.client_side_validation and 'start' in local_var_params and local_var_params['start'] < 0:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `start` when calling `get_price_recommendation`, must be a value greater than or equal to `0`")  # noqa: E501
        if self.api_client.client_side_validation and 'limit' in local_var_params and local_var_params['limit'] > 1000:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `limit` when calling `get_price_recommendation`, must be a value less than or equal to `1000`")  # noqa: E501
        if self.api_client.client_side_validation and 'limit' in local_var_params and local_var_params['limit'] < 1:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `limit` when calling `get_price_recommendation`, must be a value greater than or equal to `1`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []
        if 'start_time' in local_var_params and local_var_params['start_time'] is not None:  # noqa: E501
            query_params.append(('startTime', local_var_params['start_time']))  # noqa: E501
        if 'end_time' in local_var_params and local_var_params['end_time'] is not None:  # noqa: E501
            query_params.append(('endTime', local_var_params['end_time']))  # noqa: E501
        if 'start' in local_var_params and local_var_params['start'] is not None:  # noqa: E501
            query_params.append(('start', local_var_params['start']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'include_tags' in local_var_params and local_var_params['include_tags'] is not None:  # noqa: E501
            query_params.append(('includeTags', local_var_params['include_tags']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/result/pricerecommendations', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetPriceRecommendationApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_price_recommendation_stats_vendor_v2(self, contract_id, start_time, end_time, max_positions, **kwargs):  # noqa: E501
        """Get price reommendation stats  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_price_recommendation_stats_vendor_v2(contract_id, start_time, end_time, max_positions, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: Unique identifier of the contract (required)
        :param datetime start_time: (required)
        :param datetime end_time: (required)
        :param int max_positions: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_price_recommendation_stats_vendor_v2_with_http_info(contract_id, start_time, end_time, max_positions, **kwargs)  # noqa: E501

    def get_price_recommendation_stats_vendor_v2_with_http_info(self, contract_id, start_time, end_time, max_positions, **kwargs):  # noqa: E501
        """Get price reommendation stats  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_price_recommendation_stats_vendor_v2_with_http_info(contract_id, start_time, end_time, max_positions, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: Unique identifier of the contract (required)
        :param datetime start_time: (required)
        :param datetime end_time: (required)
        :param int max_positions: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'start_time',
            'end_time',
            'max_positions'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_price_recommendation_stats_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_price_recommendation_stats_vendor_v2`")  # noqa: E501
        # verify the required parameter 'start_time' is set
        if self.api_client.client_side_validation and ('start_time' not in local_var_params or  # noqa: E501
                                                        local_var_params['start_time'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `start_time` when calling `get_price_recommendation_stats_vendor_v2`")  # noqa: E501
        # verify the required parameter 'end_time' is set
        if self.api_client.client_side_validation and ('end_time' not in local_var_params or  # noqa: E501
                                                        local_var_params['end_time'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `end_time` when calling `get_price_recommendation_stats_vendor_v2`")  # noqa: E501
        # verify the required parameter 'max_positions' is set
        if self.api_client.client_side_validation and ('max_positions' not in local_var_params or  # noqa: E501
                                                        local_var_params['max_positions'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `max_positions` when calling `get_price_recommendation_stats_vendor_v2`")  # noqa: E501

        if self.api_client.client_side_validation and ('contract_id' in local_var_params and  # noqa: E501
                                                        len(local_var_params['contract_id']) < 1):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `contract_id` when calling `get_price_recommendation_stats_vendor_v2`, length must be greater than or equal to `1`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []
        if 'start_time' in local_var_params and local_var_params['start_time'] is not None:  # noqa: E501
            query_params.append(('startTime', local_var_params['start_time']))  # noqa: E501
        if 'end_time' in local_var_params and local_var_params['end_time'] is not None:  # noqa: E501
            query_params.append(('endTime', local_var_params['end_time']))  # noqa: E501
        if 'max_positions' in local_var_params and local_var_params['max_positions'] is not None:  # noqa: E501
            query_params.append(('maxPositions', local_var_params['max_positions']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/result/pricerecommendationstats', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_price_recommendations(self, contract_id, **kwargs):  # noqa: E501
        """Get price recommendations  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_price_recommendations(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: Unique identifier of the contract (required)
        :param int start: Where to start fetching the recommendations
        :param int limit: Maximal number of results
        :param datetime since: Timestamp of the oldest results
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: GetPriceRecommendationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_price_recommendations_with_http_info(contract_id, **kwargs)  # noqa: E501

    def get_price_recommendations_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Get price recommendations  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_price_recommendations_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: Unique identifier of the contract (required)
        :param int start: Where to start fetching the recommendations
        :param int limit: Maximal number of results
        :param datetime since: Timestamp of the oldest results
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(GetPriceRecommendationsResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'start',
            'limit',
            'since'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_price_recommendations" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_price_recommendations`")  # noqa: E501

        if self.api_client.client_side_validation and ('contract_id' in local_var_params and  # noqa: E501
                                                        len(local_var_params['contract_id']) < 1):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `contract_id` when calling `get_price_recommendations`, length must be greater than or equal to `1`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []
        if 'start' in local_var_params and local_var_params['start'] is not None:  # noqa: E501
            query_params.append(('start', local_var_params['start']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'since' in local_var_params and local_var_params['since'] is not None:  # noqa: E501
            query_params.append(('since', local_var_params['since']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/1/{contractId}/products/analysis/pricerecommendations', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetPriceRecommendationsResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_product_price_recommendation_history(self, contract_id, product_id, **kwargs):  # noqa: E501
        """Get price recommendations for one product  # noqa: E501

        This endpoint returns all price recommendations for one product within a given time range.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_product_price_recommendation_history(contract_id, product_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: Unique identifier of the contract (required)
        :param str product_id: Internal product identifier in the pricemonitor system (required)
        :param datetime start_date: **Start of time range** for data retrieval.  Format: ISO 8601 date-time in UTC (e.g., `2024-01-15T10:30:00Z`)  **Default behavior:** - If omitted and `endDate` is provided: `startDate` = `endDate` - 48 hours - If both omitted: range is `NOW - 48 hours` to `NOW` 
        :param datetime end_date: **End of time range** for data retrieval.  Format: ISO 8601 date-time in UTC (e.g., `2024-01-16T10:30:00Z`)  **Default behavior:** - If omitted and `startDate` is provided: `endDate` = `startDate` + 48 hours - If both omitted: range is `NOW - 48 hours` to `NOW` 
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: GetPriceRecommendationHistoryApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_product_price_recommendation_history_with_http_info(contract_id, product_id, **kwargs)  # noqa: E501

    def get_product_price_recommendation_history_with_http_info(self, contract_id, product_id, **kwargs):  # noqa: E501
        """Get price recommendations for one product  # noqa: E501

        This endpoint returns all price recommendations for one product within a given time range.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_product_price_recommendation_history_with_http_info(contract_id, product_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: Unique identifier of the contract (required)
        :param str product_id: Internal product identifier in the pricemonitor system (required)
        :param datetime start_date: **Start of time range** for data retrieval.  Format: ISO 8601 date-time in UTC (e.g., `2024-01-15T10:30:00Z`)  **Default behavior:** - If omitted and `endDate` is provided: `startDate` = `endDate` - 48 hours - If both omitted: range is `NOW - 48 hours` to `NOW` 
        :param datetime end_date: **End of time range** for data retrieval.  Format: ISO 8601 date-time in UTC (e.g., `2024-01-16T10:30:00Z`)  **Default behavior:** - If omitted and `startDate` is provided: `endDate` = `startDate` + 48 hours - If both omitted: range is `NOW - 48 hours` to `NOW` 
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(GetPriceRecommendationHistoryApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'product_id',
            'start_date',
            'end_date'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_product_price_recommendation_history" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_product_price_recommendation_history`")  # noqa: E501
        # verify the required parameter 'product_id' is set
        if self.api_client.client_side_validation and ('product_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['product_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `product_id` when calling `get_product_price_recommendation_history`")  # noqa: E501

        if self.api_client.client_side_validation and ('contract_id' in local_var_params and  # noqa: E501
                                                        len(local_var_params['contract_id']) < 1):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `contract_id` when calling `get_product_price_recommendation_history`, length must be greater than or equal to `1`")  # noqa: E501
        if self.api_client.client_side_validation and ('product_id' in local_var_params and  # noqa: E501
                                                        len(local_var_params['product_id']) < 1):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `product_id` when calling `get_product_price_recommendation_history`, length must be greater than or equal to `1`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'product_id' in local_var_params:
            path_params['productId'] = local_var_params['product_id']  # noqa: E501

        query_params = []
        if 'start_date' in local_var_params and local_var_params['start_date'] is not None:  # noqa: E501
            query_params.append(('startDate', local_var_params['start_date']))  # noqa: E501
        if 'end_date' in local_var_params and local_var_params['end_date'] is not None:  # noqa: E501
            query_params.append(('endDate', local_var_params['end_date']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/vendor/contracts/{contractId}/products/{productId}/pricerecommendationhistory', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetPriceRecommendationHistoryApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_repricing_strategy_vendor_v2(self, contract_id, **kwargs):  # noqa: E501
        """Get repricing strategy  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_repricing_strategy_vendor_v2(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: Unique identifier of the contract (required)
        :param int document_version:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_repricing_strategy_vendor_v2_with_http_info(contract_id, **kwargs)  # noqa: E501

    def get_repricing_strategy_vendor_v2_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Get repricing strategy  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_repricing_strategy_vendor_v2_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: Unique identifier of the contract (required)
        :param int document_version:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'document_version'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_repricing_strategy_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_repricing_strategy_vendor_v2`")  # noqa: E501

        if self.api_client.client_side_validation and ('contract_id' in local_var_params and  # noqa: E501
                                                        len(local_var_params['contract_id']) < 1):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `contract_id` when calling `get_repricing_strategy_vendor_v2`, length must be greater than or equal to `1`")  # noqa: E501
        if self.api_client.client_side_validation and 'document_version' in local_var_params and local_var_params['document_version'] < 1:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `document_version` when calling `get_repricing_strategy_vendor_v2`, must be a value greater than or equal to `1`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []
        if 'document_version' in local_var_params and local_var_params['document_version'] is not None:  # noqa: E501
            query_params.append(('documentVersion', local_var_params['document_version']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/settings/repricingstrategy', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_time_stamps(self, contract_id, **kwargs):  # noqa: E501
        """Get time stamps  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_time_stamps(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int contract_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_time_stamps_with_http_info(contract_id, **kwargs)  # noqa: E501

    def get_time_stamps_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Get time stamps  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_time_stamps_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int contract_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_time_stamps" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_time_stamps`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/1/{contractId}/products/analysis/timestamps', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_repricing_strategy_vendor_v2(self, contract_id, **kwargs):  # noqa: E501
        """Update repricing strategy  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_repricing_strategy_vendor_v2(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: Unique identifier of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.put_repricing_strategy_vendor_v2_with_http_info(contract_id, **kwargs)  # noqa: E501

    def put_repricing_strategy_vendor_v2_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Update repricing strategy  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_repricing_strategy_vendor_v2_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: Unique identifier of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_repricing_strategy_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `put_repricing_strategy_vendor_v2`")  # noqa: E501

        if self.api_client.client_side_validation and ('contract_id' in local_var_params and  # noqa: E501
                                                        len(local_var_params['contract_id']) < 1):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `contract_id` when calling `put_repricing_strategy_vendor_v2`, length must be greater than or equal to `1`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/settings/repricingstrategy', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def query_price_recommendations_approvals_v3(self, contract_id, com_patagona_pricemonitor_share_api_price_recommendations_approval_query_request_v3, **kwargs):  # noqa: E501
        """Query price recommendation approvals  # noqa: E501

        This endpoint queries price recommendation approvals for a specified set of filters.  Use cases include: - Retrieving pending price recommendation approvals. - Auditing historic pricing decisions.  Note: *Approval* refers to the price approval flow concept in our business processes, covering all states of price recommendations within this flow (e.g., pending, approved, rejected). The term does not mean all price recommendations are approved.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.query_price_recommendations_approvals_v3(contract_id, com_patagona_pricemonitor_share_api_price_recommendations_approval_query_request_v3, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: Unique identifier of the contract (required)
        :param ComPatagonaPricemonitorShareApiPriceRecommendationsApprovalQueryRequestV3 com_patagona_pricemonitor_share_api_price_recommendations_approval_query_request_v3: The request body contains all necessary filters to query the desired price recommendation approvals.  (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: QueryPriceRecommendationsApprovalsV3ApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.query_price_recommendations_approvals_v3_with_http_info(contract_id, com_patagona_pricemonitor_share_api_price_recommendations_approval_query_request_v3, **kwargs)  # noqa: E501

    def query_price_recommendations_approvals_v3_with_http_info(self, contract_id, com_patagona_pricemonitor_share_api_price_recommendations_approval_query_request_v3, **kwargs):  # noqa: E501
        """Query price recommendation approvals  # noqa: E501

        This endpoint queries price recommendation approvals for a specified set of filters.  Use cases include: - Retrieving pending price recommendation approvals. - Auditing historic pricing decisions.  Note: *Approval* refers to the price approval flow concept in our business processes, covering all states of price recommendations within this flow (e.g., pending, approved, rejected). The term does not mean all price recommendations are approved.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.query_price_recommendations_approvals_v3_with_http_info(contract_id, com_patagona_pricemonitor_share_api_price_recommendations_approval_query_request_v3, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: Unique identifier of the contract (required)
        :param ComPatagonaPricemonitorShareApiPriceRecommendationsApprovalQueryRequestV3 com_patagona_pricemonitor_share_api_price_recommendations_approval_query_request_v3: The request body contains all necessary filters to query the desired price recommendation approvals.  (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(QueryPriceRecommendationsApprovalsV3ApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'com_patagona_pricemonitor_share_api_price_recommendations_approval_query_request_v3'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method query_price_recommendations_approvals_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `query_price_recommendations_approvals_v3`")  # noqa: E501
        # verify the required parameter 'com_patagona_pricemonitor_share_api_price_recommendations_approval_query_request_v3' is set
        if self.api_client.client_side_validation and ('com_patagona_pricemonitor_share_api_price_recommendations_approval_query_request_v3' not in local_var_params or  # noqa: E501
                                                        local_var_params['com_patagona_pricemonitor_share_api_price_recommendations_approval_query_request_v3'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `com_patagona_pricemonitor_share_api_price_recommendations_approval_query_request_v3` when calling `query_price_recommendations_approvals_v3`")  # noqa: E501

        if self.api_client.client_side_validation and ('contract_id' in local_var_params and  # noqa: E501
                                                        len(local_var_params['contract_id']) < 1):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `contract_id` when calling `query_price_recommendations_approvals_v3`, length must be greater than or equal to `1`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'com_patagona_pricemonitor_share_api_price_recommendations_approval_query_request_v3' in local_var_params:
            body_params = local_var_params['com_patagona_pricemonitor_share_api_price_recommendations_approval_query_request_v3']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/vendor/contracts/{contractId}/pricerecommendations/approvals/query', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='QueryPriceRecommendationsApprovalsV3ApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def query_price_recommendations_vendor_v2(self, contract_id, **kwargs):  # noqa: E501
        """Query price recommendations  # noqa: E501

        This endpoint is used to query certain price recommendations. It supports a rather complex filtering structure. Most commonly it's used for querying by our internal product id.  Here you can find an example request body for querying one product id (here `123456`):  <details> <summary>Click to expand</summary>  ``` json {   \"pagination\": {     \"start\": 0,     \"limit\": 500   },   \"range\": {     \"start\": \"2023-01-07T12:05:01.000Z\",     \"end\": \"2023-01-09T12:05:01.000Z\"   },   \"filter\": {     \"filters\": [{       \"left\": {         \"attributeName\": \"productId\",         \"type\": \"StringValueProvider\"       },       \"right\": {         \"value\": \"123456\",         \"type\": \"StringConstantValueProvider\"       },       \"comparison\": {         \"type\": \"StringEquality\"       },       \"type\": \"ComparisonFilter\"     }],     \"type\": \"OrFilter\"   } } ``` </details>  If you want to query for multiple product ids, then you need to provide one object per product id in the filters-array.  It's recommended to query for at most 1000 price recommendations at once.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.query_price_recommendations_vendor_v2(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: Unique identifier of the contract (required)
        :param PriceRecommendationApiQueryV2 price_recommendation_api_query_v2: The request body specifies which price recommendations will be searched for.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: QueryPriceRecommendationsV2ApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.query_price_recommendations_vendor_v2_with_http_info(contract_id, **kwargs)  # noqa: E501

    def query_price_recommendations_vendor_v2_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Query price recommendations  # noqa: E501

        This endpoint is used to query certain price recommendations. It supports a rather complex filtering structure. Most commonly it's used for querying by our internal product id.  Here you can find an example request body for querying one product id (here `123456`):  <details> <summary>Click to expand</summary>  ``` json {   \"pagination\": {     \"start\": 0,     \"limit\": 500   },   \"range\": {     \"start\": \"2023-01-07T12:05:01.000Z\",     \"end\": \"2023-01-09T12:05:01.000Z\"   },   \"filter\": {     \"filters\": [{       \"left\": {         \"attributeName\": \"productId\",         \"type\": \"StringValueProvider\"       },       \"right\": {         \"value\": \"123456\",         \"type\": \"StringConstantValueProvider\"       },       \"comparison\": {         \"type\": \"StringEquality\"       },       \"type\": \"ComparisonFilter\"     }],     \"type\": \"OrFilter\"   } } ``` </details>  If you want to query for multiple product ids, then you need to provide one object per product id in the filters-array.  It's recommended to query for at most 1000 price recommendations at once.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.query_price_recommendations_vendor_v2_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: Unique identifier of the contract (required)
        :param PriceRecommendationApiQueryV2 price_recommendation_api_query_v2: The request body specifies which price recommendations will be searched for.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(QueryPriceRecommendationsV2ApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'price_recommendation_api_query_v2'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method query_price_recommendations_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `query_price_recommendations_vendor_v2`")  # noqa: E501

        if self.api_client.client_side_validation and ('contract_id' in local_var_params and  # noqa: E501
                                                        len(local_var_params['contract_id']) < 1):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `contract_id` when calling `query_price_recommendations_vendor_v2`, length must be greater than or equal to `1`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'price_recommendation_api_query_v2' in local_var_params:
            body_params = local_var_params['price_recommendation_api_query_v2']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/result/pricerecommendations/query', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='QueryPriceRecommendationsV2ApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def simulate_price_recommendations_v3(self, contract_id, com_patagona_pricemonitor_share_api_price_simulation_bulk_request_v3, **kwargs):  # noqa: E501
        """Simulate price recommendations  # noqa: E501

        This endpoint simulates price recommendations for a specified set of products. It is useful for:  - Explaining why certain price recommendations have been calculated. - Testing and evaluating pricing strategies before applying them.  The simulation process can be customized by including parameters such as a custom pricing strategy, custom time range, specific offers and more.  A maximum of 10 price recommendation simulations may be included in one request.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulate_price_recommendations_v3(contract_id, com_patagona_pricemonitor_share_api_price_simulation_bulk_request_v3, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: Unique identifier of the contract (required)
        :param ComPatagonaPricemonitorShareApiPriceSimulationBulkRequestV3 com_patagona_pricemonitor_share_api_price_simulation_bulk_request_v3: The request body contains all the necessary data to simulate price recommendations for multiple products. Custom parameters, such as pricing strategies and time ranges, can be provided in order to simulate different scenarios.  (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: SimulatePriceCalculationBulkV3ApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.simulate_price_recommendations_v3_with_http_info(contract_id, com_patagona_pricemonitor_share_api_price_simulation_bulk_request_v3, **kwargs)  # noqa: E501

    def simulate_price_recommendations_v3_with_http_info(self, contract_id, com_patagona_pricemonitor_share_api_price_simulation_bulk_request_v3, **kwargs):  # noqa: E501
        """Simulate price recommendations  # noqa: E501

        This endpoint simulates price recommendations for a specified set of products. It is useful for:  - Explaining why certain price recommendations have been calculated. - Testing and evaluating pricing strategies before applying them.  The simulation process can be customized by including parameters such as a custom pricing strategy, custom time range, specific offers and more.  A maximum of 10 price recommendation simulations may be included in one request.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simulate_price_recommendations_v3_with_http_info(contract_id, com_patagona_pricemonitor_share_api_price_simulation_bulk_request_v3, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: Unique identifier of the contract (required)
        :param ComPatagonaPricemonitorShareApiPriceSimulationBulkRequestV3 com_patagona_pricemonitor_share_api_price_simulation_bulk_request_v3: The request body contains all the necessary data to simulate price recommendations for multiple products. Custom parameters, such as pricing strategies and time ranges, can be provided in order to simulate different scenarios.  (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(SimulatePriceCalculationBulkV3ApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'com_patagona_pricemonitor_share_api_price_simulation_bulk_request_v3'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simulate_price_recommendations_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `simulate_price_recommendations_v3`")  # noqa: E501
        # verify the required parameter 'com_patagona_pricemonitor_share_api_price_simulation_bulk_request_v3' is set
        if self.api_client.client_side_validation and ('com_patagona_pricemonitor_share_api_price_simulation_bulk_request_v3' not in local_var_params or  # noqa: E501
                                                        local_var_params['com_patagona_pricemonitor_share_api_price_simulation_bulk_request_v3'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `com_patagona_pricemonitor_share_api_price_simulation_bulk_request_v3` when calling `simulate_price_recommendations_v3`")  # noqa: E501

        if self.api_client.client_side_validation and ('contract_id' in local_var_params and  # noqa: E501
                                                        len(local_var_params['contract_id']) < 1):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `contract_id` when calling `simulate_price_recommendations_v3`, length must be greater than or equal to `1`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'com_patagona_pricemonitor_share_api_price_simulation_bulk_request_v3' in local_var_params:
            body_params = local_var_params['com_patagona_pricemonitor_share_api_price_simulation_bulk_request_v3']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/vendor/contracts/{contractId}/pricerecommendations/simulate', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SimulatePriceCalculationBulkV3ApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)
