# coding: utf-8

"""
    Omnia 2.0 API The Omnia 2.0 API is RESTful and provides access to the backend of Omnia 2.0 and Pricemonitor. It is used to manage products, offers, contracts and more.

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)  # noqa: E501

    The version of the OpenAPI document: 0.0.6944
    Generated by: https://openapi-generator.tech
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from pricemonitor_api_client.api_client import ApiClient
from pricemonitor_api_client.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError
)


class InternalApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def add_company(self, **kwargs):  # noqa: E501
        """Add company  # noqa: E501

        Add a company.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_company(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.add_company_with_http_info(**kwargs)  # noqa: E501

    def add_company_with_http_info(self, **kwargs):  # noqa: E501
        """Add company  # noqa: E501

        Add a company.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_company_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_company" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/controlpanel/api/companies', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_company_user(self, id, email, **kwargs):  # noqa: E501
        """Add user to company  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_company_user(id, email, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: (required)
        :param str email: (required)
        :param object body: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.add_company_user_with_http_info(id, email, **kwargs)  # noqa: E501

    def add_company_user_with_http_info(self, id, email, **kwargs):  # noqa: E501
        """Add user to company  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_company_user_with_http_info(id, email, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: (required)
        :param str email: (required)
        :param object body: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'email',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_company_user" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `add_company_user`")  # noqa: E501
        # verify the required parameter 'email' is set
        if self.api_client.client_side_validation and ('email' not in local_var_params or  # noqa: E501
                                                        local_var_params['email'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `email` when calling `add_company_user`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'email' in local_var_params:
            path_params['email'] = local_var_params['email']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/controlpanel/companies/{id}/users/{email}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_pricing_strategy_scenario(self, contract_id, **kwargs):  # noqa: E501
        """Add scenario strategy  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_pricing_strategy_scenario(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param PostScenarioStrategyRequest post_scenario_strategy_request: The scenario strategy to be stored. Including the necessary metadata.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: PostScenarioStrategyResponseApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.add_pricing_strategy_scenario_with_http_info(contract_id, **kwargs)  # noqa: E501

    def add_pricing_strategy_scenario_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Add scenario strategy  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_pricing_strategy_scenario_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param PostScenarioStrategyRequest post_scenario_strategy_request: The scenario strategy to be stored. Including the necessary metadata.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(PostScenarioStrategyResponseApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'post_scenario_strategy_request'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_pricing_strategy_scenario" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `add_pricing_strategy_scenario`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'post_scenario_strategy_request' in local_var_params:
            body_params = local_var_params['post_scenario_strategy_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/vendor/contracts/{contractId}/settings/pricingstrategies/scenarios', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PostScenarioStrategyResponseApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_user(self, **kwargs):  # noqa: E501
        """Add a new user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_user(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param NewUser new_user: The new user to be added
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.add_user_with_http_info(**kwargs)  # noqa: E501

    def add_user_with_http_info(self, **kwargs):  # noqa: E501
        """Add a new user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_user_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param NewUser new_user: The new user to be added
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'new_user'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_user" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'new_user' in local_var_params:
            body_params = local_var_params['new_user']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/controlpanel/users', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def authenticate(self, **kwargs):  # noqa: E501
        """Authenticate  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.authenticate(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.authenticate_with_http_info(**kwargs)  # noqa: E501

    def authenticate_with_http_info(self, **kwargs):  # noqa: E501
        """Authenticate  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.authenticate_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method authenticate" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/login', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def change_password(self, **kwargs):  # noqa: E501
        """Change password  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.change_password(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.change_password_with_http_info(**kwargs)  # noqa: E501

    def change_password_with_http_info(self, **kwargs):  # noqa: E501
        """Change password  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.change_password_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method change_password" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/account/password', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def check_user_confirmation(self, token, **kwargs):  # noqa: E501
        """Check if a specific confirmation token exists  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.check_user_confirmation(token, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str token: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.check_user_confirmation_with_http_info(token, **kwargs)  # noqa: E501

    def check_user_confirmation_with_http_info(self, token, **kwargs):  # noqa: E501
        """Check if a specific confirmation token exists  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.check_user_confirmation_with_http_info(token, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str token: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'token'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method check_user_confirmation" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'token' is set
        if self.api_client.client_side_validation and ('token' not in local_var_params or  # noqa: E501
                                                        local_var_params['token'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `token` when calling `check_user_confirmation`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'token' in local_var_params:
            path_params['token'] = local_var_params['token']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/account/confirm/{token}', 'HEAD',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def confirm_user(self, token, body, **kwargs):  # noqa: E501
        """Confirm an unconfirmed user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.confirm_user(token, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str token: (required)
        :param str body: The password that should be set on the confirmed user (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.confirm_user_with_http_info(token, body, **kwargs)  # noqa: E501

    def confirm_user_with_http_info(self, token, body, **kwargs):  # noqa: E501
        """Confirm an unconfirmed user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.confirm_user_with_http_info(token, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str token: (required)
        :param str body: The password that should be set on the confirmed user (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'token',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method confirm_user" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'token' is set
        if self.api_client.client_side_validation and ('token' not in local_var_params or  # noqa: E501
                                                        local_var_params['token'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `token` when calling `confirm_user`")  # noqa: E501
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in local_var_params or  # noqa: E501
                                                        local_var_params['body'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `body` when calling `confirm_user`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'token' in local_var_params:
            path_params['token'] = local_var_params['token']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/account/confirm/{token}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_alert_settings(self, contract_id, **kwargs):  # noqa: E501
        """Create alert settings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_alert_settings(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_alert_settings_with_http_info(contract_id, **kwargs)  # noqa: E501

    def create_alert_settings_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Create alert settings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_alert_settings_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_alert_settings" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `create_alert_settings`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/1/{contractId}/settings/alerts', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_auth_token(self, email, **kwargs):  # noqa: E501
        """Create authentication token  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_auth_token(email, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str email: (required)
        :param object body: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_auth_token_with_http_info(email, **kwargs)  # noqa: E501

    def create_auth_token_with_http_info(self, email, **kwargs):  # noqa: E501
        """Create authentication token  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_auth_token_with_http_info(email, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str email: (required)
        :param object body: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'email',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_auth_token" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'email' is set
        if self.api_client.client_side_validation and ('email' not in local_var_params or  # noqa: E501
                                                        local_var_params['email'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `email` when calling `create_auth_token`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'email' in local_var_params:
            path_params['email'] = local_var_params['email']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/controlpanel/users/{email}/authtokens', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_task(self, contract_id, **kwargs):  # noqa: E501
        """Create task  # noqa: E501

        Create a new task  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_task(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param ComPatagonaPricemonitorShareApiCreateTaskBodyV2 com_patagona_pricemonitor_share_api_create_task_body_v2: Create a new task
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_task_with_http_info(contract_id, **kwargs)  # noqa: E501

    def create_task_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Create task  # noqa: E501

        Create a new task  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_task_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param ComPatagonaPricemonitorShareApiCreateTaskBodyV2 com_patagona_pricemonitor_share_api_create_task_body_v2: Create a new task
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'com_patagona_pricemonitor_share_api_create_task_body_v2'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_task" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `create_task`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'com_patagona_pricemonitor_share_api_create_task_body_v2' in local_var_params:
            body_params = local_var_params['com_patagona_pricemonitor_share_api_create_task_body_v2']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/1/{contractId}/tasks', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_task_manufacturer_v2(self, contract_id, **kwargs):  # noqa: E501
        """Create task [manufacturer]  # noqa: E501

        Creates a new task for a manufacturer contract  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_task_manufacturer_v2(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param ComPatagonaPricemonitorShareApiCreateTaskBodyV2 com_patagona_pricemonitor_share_api_create_task_body_v2: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: GenericTaskWithUrl
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_task_manufacturer_v2_with_http_info(contract_id, **kwargs)  # noqa: E501

    def create_task_manufacturer_v2_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Create task [manufacturer]  # noqa: E501

        Creates a new task for a manufacturer contract  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_task_manufacturer_v2_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param ComPatagonaPricemonitorShareApiCreateTaskBodyV2 com_patagona_pricemonitor_share_api_create_task_body_v2: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(GenericTaskWithUrl, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'com_patagona_pricemonitor_share_api_create_task_body_v2'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_task_manufacturer_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `create_task_manufacturer_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'com_patagona_pricemonitor_share_api_create_task_body_v2' in local_var_params:
            body_params = local_var_params['com_patagona_pricemonitor_share_api_create_task_body_v2']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/m/contracts/{contractId}/tasks', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GenericTaskWithUrl',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_task_vendor_v2(self, contract_id, **kwargs):  # noqa: E501
        """Create a task [vendor]  # noqa: E501

        Creates a new task for a vendor contract.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_task_vendor_v2(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param ComPatagonaPricemonitorShareApiCreateTaskBodyV2 com_patagona_pricemonitor_share_api_create_task_body_v2: Create a new task
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_task_vendor_v2_with_http_info(contract_id, **kwargs)  # noqa: E501

    def create_task_vendor_v2_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Create a task [vendor]  # noqa: E501

        Creates a new task for a vendor contract.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_task_vendor_v2_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param ComPatagonaPricemonitorShareApiCreateTaskBodyV2 com_patagona_pricemonitor_share_api_create_task_body_v2: Create a new task
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'com_patagona_pricemonitor_share_api_create_task_body_v2'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_task_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `create_task_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'com_patagona_pricemonitor_share_api_create_task_body_v2' in local_var_params:
            body_params = local_var_params['com_patagona_pricemonitor_share_api_create_task_body_v2']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/tasks', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_alert_settings(self, contract_id, alert_id, **kwargs):  # noqa: E501
        """Delete alert settings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_alert_settings(contract_id, alert_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str alert_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_alert_settings_with_http_info(contract_id, alert_id, **kwargs)  # noqa: E501

    def delete_alert_settings_with_http_info(self, contract_id, alert_id, **kwargs):  # noqa: E501
        """Delete alert settings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_alert_settings_with_http_info(contract_id, alert_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str alert_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'alert_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_alert_settings" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `delete_alert_settings`")  # noqa: E501
        # verify the required parameter 'alert_id' is set
        if self.api_client.client_side_validation and ('alert_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['alert_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `alert_id` when calling `delete_alert_settings`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'alert_id' in local_var_params:
            path_params['alertId'] = local_var_params['alert_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/1/{contractId}/settings/alerts/{alertId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_auth_token(self, email, token, **kwargs):  # noqa: E501
        """Delete authentication token  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_auth_token(email, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str email: (required)
        :param str token: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_auth_token_with_http_info(email, token, **kwargs)  # noqa: E501

    def delete_auth_token_with_http_info(self, email, token, **kwargs):  # noqa: E501
        """Delete authentication token  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_auth_token_with_http_info(email, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str email: (required)
        :param str token: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'email',
            'token'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_auth_token" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'email' is set
        if self.api_client.client_side_validation and ('email' not in local_var_params or  # noqa: E501
                                                        local_var_params['email'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `email` when calling `delete_auth_token`")  # noqa: E501
        # verify the required parameter 'token' is set
        if self.api_client.client_side_validation and ('token' not in local_var_params or  # noqa: E501
                                                        local_var_params['token'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `token` when calling `delete_auth_token`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'email' in local_var_params:
            path_params['email'] = local_var_params['email']  # noqa: E501
        if 'token' in local_var_params:
            path_params['token'] = local_var_params['token']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/controlpanel/users/{email}/authtokens/{token}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_callback_settings_manufacturer_v2(self, contract_id, **kwargs):  # noqa: E501
        """Delete callbacks [manufacturer]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_callback_settings_manufacturer_v2(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_callback_settings_manufacturer_v2_with_http_info(contract_id, **kwargs)  # noqa: E501

    def delete_callback_settings_manufacturer_v2_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Delete callbacks [manufacturer]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_callback_settings_manufacturer_v2_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_callback_settings_manufacturer_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `delete_callback_settings_manufacturer_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/m/contracts/{contractId}/settings/callbacks', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_callback_settings_vendor_v2(self, contract_id, **kwargs):  # noqa: E501
        """Delete callbacks [vendor]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_callback_settings_vendor_v2(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_callback_settings_vendor_v2_with_http_info(contract_id, **kwargs)  # noqa: E501

    def delete_callback_settings_vendor_v2_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Delete callbacks [vendor]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_callback_settings_vendor_v2_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_callback_settings_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `delete_callback_settings_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/settings/callbacks', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_contract_vendor_v2(self, contract_id, **kwargs):  # noqa: E501
        """Delete contract [vendor]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_contract_vendor_v2(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_contract_vendor_v2_with_http_info(contract_id, **kwargs)  # noqa: E501

    def delete_contract_vendor_v2_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Delete contract [vendor]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_contract_vendor_v2_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_contract_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `delete_contract_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_dynamic_monitoring_settings(self, contract_id, **kwargs):  # noqa: E501
        """Delete dynamic monitoring settings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_dynamic_monitoring_settings(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_dynamic_monitoring_settings_with_http_info(contract_id, **kwargs)  # noqa: E501

    def delete_dynamic_monitoring_settings_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Delete dynamic monitoring settings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_dynamic_monitoring_settings_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_dynamic_monitoring_settings" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `delete_dynamic_monitoring_settings`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/1/{contractId}/settings/dynamicmonitoring', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_feed_vendor_v2(self, contract_id, feed_id, **kwargs):  # noqa: E501
        """Deleted feed  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_feed_vendor_v2(contract_id, feed_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str feed_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_feed_vendor_v2_with_http_info(contract_id, feed_id, **kwargs)  # noqa: E501

    def delete_feed_vendor_v2_with_http_info(self, contract_id, feed_id, **kwargs):  # noqa: E501
        """Deleted feed  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_feed_vendor_v2_with_http_info(contract_id, feed_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str feed_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'feed_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_feed_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `delete_feed_vendor_v2`")  # noqa: E501
        # verify the required parameter 'feed_id' is set
        if self.api_client.client_side_validation and ('feed_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['feed_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `feed_id` when calling `delete_feed_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'feed_id' in local_var_params:
            path_params['feedId'] = local_var_params['feed_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/feeds/{feedId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_import_settings_vendor_v2(self, contract_id, **kwargs):  # noqa: E501
        """Delete import settings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_import_settings_vendor_v2(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_import_settings_vendor_v2_with_http_info(contract_id, **kwargs)  # noqa: E501

    def delete_import_settings_vendor_v2_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Delete import settings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_import_settings_vendor_v2_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_import_settings_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `delete_import_settings_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/settings/import', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_monitoring_schedule_manufacturer_v3(self, contract_id, schedule_id, **kwargs):  # noqa: E501
        """Delete monitoring schedule for contract [manufacturer]  # noqa: E501

        Delete a monitoring schedule for a given manufacturer contract.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_monitoring_schedule_manufacturer_v3(contract_id, schedule_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param int schedule_id: ID of a monitoring schedule (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ComPatagonaPricemonitorShareApiDeleteByNumericIdApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_monitoring_schedule_manufacturer_v3_with_http_info(contract_id, schedule_id, **kwargs)  # noqa: E501

    def delete_monitoring_schedule_manufacturer_v3_with_http_info(self, contract_id, schedule_id, **kwargs):  # noqa: E501
        """Delete monitoring schedule for contract [manufacturer]  # noqa: E501

        Delete a monitoring schedule for a given manufacturer contract.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_monitoring_schedule_manufacturer_v3_with_http_info(contract_id, schedule_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param int schedule_id: ID of a monitoring schedule (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ComPatagonaPricemonitorShareApiDeleteByNumericIdApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'schedule_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_monitoring_schedule_manufacturer_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `delete_monitoring_schedule_manufacturer_v3`")  # noqa: E501
        # verify the required parameter 'schedule_id' is set
        if self.api_client.client_side_validation and ('schedule_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['schedule_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `schedule_id` when calling `delete_monitoring_schedule_manufacturer_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'schedule_id' in local_var_params:
            path_params['scheduleId'] = local_var_params['schedule_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/manufacturer/contracts/{contractId}/settings/monitoringschedules/{scheduleId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ComPatagonaPricemonitorShareApiDeleteByNumericIdApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_monitoring_schedule_vendor_v3(self, contract_id, schedule_id, **kwargs):  # noqa: E501
        """Delete monitoring schedule for contract [vendor]  # noqa: E501

        Delete a monitoring schedule for a given vendor contract.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_monitoring_schedule_vendor_v3(contract_id, schedule_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param int schedule_id: ID of a monitoring schedule (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ComPatagonaPricemonitorShareApiDeleteByNumericIdApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_monitoring_schedule_vendor_v3_with_http_info(contract_id, schedule_id, **kwargs)  # noqa: E501

    def delete_monitoring_schedule_vendor_v3_with_http_info(self, contract_id, schedule_id, **kwargs):  # noqa: E501
        """Delete monitoring schedule for contract [vendor]  # noqa: E501

        Delete a monitoring schedule for a given vendor contract.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_monitoring_schedule_vendor_v3_with_http_info(contract_id, schedule_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param int schedule_id: ID of a monitoring schedule (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ComPatagonaPricemonitorShareApiDeleteByNumericIdApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'schedule_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_monitoring_schedule_vendor_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `delete_monitoring_schedule_vendor_v3`")  # noqa: E501
        # verify the required parameter 'schedule_id' is set
        if self.api_client.client_side_validation and ('schedule_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['schedule_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `schedule_id` when calling `delete_monitoring_schedule_vendor_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'schedule_id' in local_var_params:
            path_params['scheduleId'] = local_var_params['schedule_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/vendor/contracts/{contractId}/settings/monitoringschedules/{scheduleId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ComPatagonaPricemonitorShareApiDeleteByNumericIdApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_products_manufacturer_v3(self, contract_id, **kwargs):  # noqa: E501
        """Delete products [manufacturer]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_products_manufacturer_v3(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param datetime updated_max:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_products_manufacturer_v3_with_http_info(contract_id, **kwargs)  # noqa: E501

    def delete_products_manufacturer_v3_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Delete products [manufacturer]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_products_manufacturer_v3_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param datetime updated_max:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'updated_max'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_products_manufacturer_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `delete_products_manufacturer_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []
        if 'updated_max' in local_var_params and local_var_params['updated_max'] is not None:  # noqa: E501
            query_params.append(('updatedMax', local_var_params['updated_max']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/manufacturer/contracts/{contractId}/products', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_repricing_strategy_vendor_v2(self, contract_id, **kwargs):  # noqa: E501
        """Delete repricing strategy  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_repricing_strategy_vendor_v2(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_repricing_strategy_vendor_v2_with_http_info(contract_id, **kwargs)  # noqa: E501

    def delete_repricing_strategy_vendor_v2_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Delete repricing strategy  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_repricing_strategy_vendor_v2_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_repricing_strategy_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `delete_repricing_strategy_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/settings/repricingstrategy', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_user_role(self, user_id, role_name, **kwargs):  # noqa: E501
        """Delete user role  # noqa: E501

        Remove the specified role from the given user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_user_role(user_id, role_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int user_id: (required)
        :param str role_name: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_user_role_with_http_info(user_id, role_name, **kwargs)  # noqa: E501

    def delete_user_role_with_http_info(self, user_id, role_name, **kwargs):  # noqa: E501
        """Delete user role  # noqa: E501

        Remove the specified role from the given user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_user_role_with_http_info(user_id, role_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int user_id: (required)
        :param str role_name: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'user_id',
            'role_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_user_role" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'user_id' is set
        if self.api_client.client_side_validation and ('user_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['user_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `user_id` when calling `delete_user_role`")  # noqa: E501
        # verify the required parameter 'role_name' is set
        if self.api_client.client_side_validation and ('role_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['role_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `role_name` when calling `delete_user_role`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in local_var_params:
            path_params['userId'] = local_var_params['user_id']  # noqa: E501
        if 'role_name' in local_var_params:
            path_params['roleName'] = local_var_params['role_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/users/{userId}/role/{roleName}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_vendor_shop_mapping_manufacturer_v3(self, contract_id, vendor_id, **kwargs):  # noqa: E501
        """Delete vendor and associated shops for contract  # noqa: E501

        Delete a vendor and associated shops for a given manufacturer contract.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_vendor_shop_mapping_manufacturer_v3(contract_id, vendor_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param int vendor_id: ID of vendor shop mapping (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ComPatagonaPricemonitorShareApiDeleteByNumericIdApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_vendor_shop_mapping_manufacturer_v3_with_http_info(contract_id, vendor_id, **kwargs)  # noqa: E501

    def delete_vendor_shop_mapping_manufacturer_v3_with_http_info(self, contract_id, vendor_id, **kwargs):  # noqa: E501
        """Delete vendor and associated shops for contract  # noqa: E501

        Delete a vendor and associated shops for a given manufacturer contract.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_vendor_shop_mapping_manufacturer_v3_with_http_info(contract_id, vendor_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param int vendor_id: ID of vendor shop mapping (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ComPatagonaPricemonitorShareApiDeleteByNumericIdApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'vendor_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_vendor_shop_mapping_manufacturer_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `delete_vendor_shop_mapping_manufacturer_v3`")  # noqa: E501
        # verify the required parameter 'vendor_id' is set
        if self.api_client.client_side_validation and ('vendor_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['vendor_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `vendor_id` when calling `delete_vendor_shop_mapping_manufacturer_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'vendor_id' in local_var_params:
            path_params['vendorId'] = local_var_params['vendor_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/manufacturer/contracts/{contractId}/vendors/{vendorId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ComPatagonaPricemonitorShareApiDeleteByNumericIdApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def execute_monitoring_schedule_manufacturer_v3(self, contract_id, schedule_id, **kwargs):  # noqa: E501
        """Trigger monitoring pipeline for schedule [manufacturer]  # noqa: E501

        Trigger a monitoring pipeline task for a manufacturer for a configured monitoring schedule.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.execute_monitoring_schedule_manufacturer_v3(contract_id, schedule_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param int schedule_id: ID of a monitoring schedule (required)
        :param bool trigger_follow_up_task:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: EmptyApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.execute_monitoring_schedule_manufacturer_v3_with_http_info(contract_id, schedule_id, **kwargs)  # noqa: E501

    def execute_monitoring_schedule_manufacturer_v3_with_http_info(self, contract_id, schedule_id, **kwargs):  # noqa: E501
        """Trigger monitoring pipeline for schedule [manufacturer]  # noqa: E501

        Trigger a monitoring pipeline task for a manufacturer for a configured monitoring schedule.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.execute_monitoring_schedule_manufacturer_v3_with_http_info(contract_id, schedule_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param int schedule_id: ID of a monitoring schedule (required)
        :param bool trigger_follow_up_task:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(EmptyApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'schedule_id',
            'trigger_follow_up_task'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method execute_monitoring_schedule_manufacturer_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `execute_monitoring_schedule_manufacturer_v3`")  # noqa: E501
        # verify the required parameter 'schedule_id' is set
        if self.api_client.client_side_validation and ('schedule_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['schedule_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `schedule_id` when calling `execute_monitoring_schedule_manufacturer_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'schedule_id' in local_var_params:
            path_params['scheduleId'] = local_var_params['schedule_id']  # noqa: E501

        query_params = []
        if 'trigger_follow_up_task' in local_var_params and local_var_params['trigger_follow_up_task'] is not None:  # noqa: E501
            query_params.append(('triggerFollowUpTask', local_var_params['trigger_follow_up_task']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/manufacturer/contracts/{contractId}/settings/monitoringschedules/{scheduleId}/execute', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EmptyApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def execute_monitoring_schedule_vendor_v3(self, contract_id, schedule_id, **kwargs):  # noqa: E501
        """Trigger monitoring pipeline for schedule [vendor]  # noqa: E501

        Trigger a monitoring pipeline task for a vendor for a configured monitoring schedule.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.execute_monitoring_schedule_vendor_v3(contract_id, schedule_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param int schedule_id: ID of a monitoring schedule (required)
        :param bool trigger_follow_up_task:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: EmptyApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.execute_monitoring_schedule_vendor_v3_with_http_info(contract_id, schedule_id, **kwargs)  # noqa: E501

    def execute_monitoring_schedule_vendor_v3_with_http_info(self, contract_id, schedule_id, **kwargs):  # noqa: E501
        """Trigger monitoring pipeline for schedule [vendor]  # noqa: E501

        Trigger a monitoring pipeline task for a vendor for a configured monitoring schedule.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.execute_monitoring_schedule_vendor_v3_with_http_info(contract_id, schedule_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param int schedule_id: ID of a monitoring schedule (required)
        :param bool trigger_follow_up_task:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(EmptyApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'schedule_id',
            'trigger_follow_up_task'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method execute_monitoring_schedule_vendor_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `execute_monitoring_schedule_vendor_v3`")  # noqa: E501
        # verify the required parameter 'schedule_id' is set
        if self.api_client.client_side_validation and ('schedule_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['schedule_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `schedule_id` when calling `execute_monitoring_schedule_vendor_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'schedule_id' in local_var_params:
            path_params['scheduleId'] = local_var_params['schedule_id']  # noqa: E501

        query_params = []
        if 'trigger_follow_up_task' in local_var_params and local_var_params['trigger_follow_up_task'] is not None:  # noqa: E501
            query_params.append(('triggerFollowUpTask', local_var_params['trigger_follow_up_task']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/vendor/contracts/{contractId}/settings/monitoringschedules/{scheduleId}/execute', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EmptyApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_active_ebay_token_vendor_v2(self, contract_id, **kwargs):  # noqa: E501
        """Get active Ebay token  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_active_ebay_token_vendor_v2(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_active_ebay_token_vendor_v2_with_http_info(contract_id, **kwargs)  # noqa: E501

    def get_active_ebay_token_vendor_v2_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Get active Ebay token  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_active_ebay_token_vendor_v2_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_active_ebay_token_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_active_ebay_token_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/settings/ebay/token', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_alert_settings(self, contract_id, **kwargs):  # noqa: E501
        """Get alert settings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_alert_settings(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_alert_settings_with_http_info(contract_id, **kwargs)  # noqa: E501

    def get_alert_settings_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Get alert settings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_alert_settings_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_alert_settings" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_alert_settings`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/1/{contractId}/settings/alerts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_companies(self, **kwargs):  # noqa: E501
        """Get a list of all companies  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_companies(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int start: Start of the pagination
        :param int limit: Number of elements per page
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ComPatagonaPricemonitorShareApiAdminCompanyV2
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_all_companies_with_http_info(**kwargs)  # noqa: E501

    def get_all_companies_with_http_info(self, **kwargs):  # noqa: E501
        """Get a list of all companies  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_companies_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int start: Start of the pagination
        :param int limit: Number of elements per page
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ComPatagonaPricemonitorShareApiAdminCompanyV2, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'start',
            'limit'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_companies" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'start' in local_var_params and local_var_params['start'] is not None:  # noqa: E501
            query_params.append(('start', local_var_params['start']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/controlpanel/api/companies', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ComPatagonaPricemonitorShareApiAdminCompanyV2',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_contracts(self, **kwargs):  # noqa: E501
        """Get a list of all contracts  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_contracts(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_all_contracts_with_http_info(**kwargs)  # noqa: E501

    def get_all_contracts_with_http_info(self, **kwargs):  # noqa: E501
        """Get a list of all contracts  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_contracts_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_contracts" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/controlpanel/api/contracts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_domains_control_panel_v3(self, **kwargs):  # noqa: E501
        """Add domain  # noqa: E501

        Add a new domain.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_domains_control_panel_v3(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param ComPatagonaPricemonitorShareApiPostAdminAddDomainBodyV3 com_patagona_pricemonitor_share_api_post_admin_add_domain_body_v3: The domain to be added and its offer sources
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: PostAdminAddDomainV3ApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_all_domains_control_panel_v3_with_http_info(**kwargs)  # noqa: E501

    def get_all_domains_control_panel_v3_with_http_info(self, **kwargs):  # noqa: E501
        """Add domain  # noqa: E501

        Add a new domain.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_domains_control_panel_v3_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param ComPatagonaPricemonitorShareApiPostAdminAddDomainBodyV3 com_patagona_pricemonitor_share_api_post_admin_add_domain_body_v3: The domain to be added and its offer sources
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(PostAdminAddDomainV3ApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'com_patagona_pricemonitor_share_api_post_admin_add_domain_body_v3'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_domains_control_panel_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'com_patagona_pricemonitor_share_api_post_admin_add_domain_body_v3' in local_var_params:
            body_params = local_var_params['com_patagona_pricemonitor_share_api_post_admin_add_domain_body_v3']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/controlpanel/api/v3/domains', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PostAdminAddDomainV3ApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_ebay_authorizations_vendor_v2(self, contract_id, start, limit, **kwargs):  # noqa: E501
        """Get Ebay authorizations  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_ebay_authorizations_vendor_v2(contract_id, start, limit, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param int start: (required)
        :param int limit: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_all_ebay_authorizations_vendor_v2_with_http_info(contract_id, start, limit, **kwargs)  # noqa: E501

    def get_all_ebay_authorizations_vendor_v2_with_http_info(self, contract_id, start, limit, **kwargs):  # noqa: E501
        """Get Ebay authorizations  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_ebay_authorizations_vendor_v2_with_http_info(contract_id, start, limit, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param int start: (required)
        :param int limit: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'start',
            'limit'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_ebay_authorizations_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_all_ebay_authorizations_vendor_v2`")  # noqa: E501
        # verify the required parameter 'start' is set
        if self.api_client.client_side_validation and ('start' not in local_var_params or  # noqa: E501
                                                        local_var_params['start'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `start` when calling `get_all_ebay_authorizations_vendor_v2`")  # noqa: E501
        # verify the required parameter 'limit' is set
        if self.api_client.client_side_validation and ('limit' not in local_var_params or  # noqa: E501
                                                        local_var_params['limit'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `limit` when calling `get_all_ebay_authorizations_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []
        if 'start' in local_var_params and local_var_params['start'] is not None:  # noqa: E501
            query_params.append(('start', local_var_params['start']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/settings/ebay/authorizations', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_ebay_tokens_vendor_v2(self, contract_id, start, limit, **kwargs):  # noqa: E501
        """Get all Ebay tokens  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_ebay_tokens_vendor_v2(contract_id, start, limit, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param int start: (required)
        :param int limit: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_all_ebay_tokens_vendor_v2_with_http_info(contract_id, start, limit, **kwargs)  # noqa: E501

    def get_all_ebay_tokens_vendor_v2_with_http_info(self, contract_id, start, limit, **kwargs):  # noqa: E501
        """Get all Ebay tokens  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_ebay_tokens_vendor_v2_with_http_info(contract_id, start, limit, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param int start: (required)
        :param int limit: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'start',
            'limit'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_ebay_tokens_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_all_ebay_tokens_vendor_v2`")  # noqa: E501
        # verify the required parameter 'start' is set
        if self.api_client.client_side_validation and ('start' not in local_var_params or  # noqa: E501
                                                        local_var_params['start'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `start` when calling `get_all_ebay_tokens_vendor_v2`")  # noqa: E501
        # verify the required parameter 'limit' is set
        if self.api_client.client_side_validation and ('limit' not in local_var_params or  # noqa: E501
                                                        local_var_params['limit'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `limit` when calling `get_all_ebay_tokens_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []
        if 'start' in local_var_params and local_var_params['start'] is not None:  # noqa: E501
            query_params.append(('start', local_var_params['start']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/settings/ebay/tokens', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_portals(self, **kwargs):  # noqa: E501
        """Get a list of all portals  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_portals(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_all_portals_with_http_info(**kwargs)  # noqa: E501

    def get_all_portals_with_http_info(self, **kwargs):  # noqa: E501
        """Get a list of all portals  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_portals_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_portals" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/controlpanel/api/portals', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_scenarios_metadata(self, contract_id, **kwargs):  # noqa: E501
        """Get all scenario strategies  # noqa: E501

        Get a list of all scenario strategy metadata for a contract.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_scenarios_metadata(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: list[ScenarioStrategyMetadataResponseApiResponse]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_all_scenarios_metadata_with_http_info(contract_id, **kwargs)  # noqa: E501

    def get_all_scenarios_metadata_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Get all scenario strategies  # noqa: E501

        Get a list of all scenario strategy metadata for a contract.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_scenarios_metadata_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(list[ScenarioStrategyMetadataResponseApiResponse], status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_scenarios_metadata" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_all_scenarios_metadata`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/vendor/contracts/{contractId}/settings/pricingstrategies/scenarios', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ScenarioStrategyMetadataResponseApiResponse]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_tasks(self, contract_id, task_id, task_type, task_state, limit, **kwargs):  # noqa: E501
        """Get all tasks  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_tasks(contract_id, task_id, task_type, task_state, limit, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param list[str] contract_id: (required)
        :param list[str] task_id: (required)
        :param list[str] task_type: (required)
        :param list[str] task_state: (required)
        :param int limit: (required)
        :param datetime min_creation_date:
        :param datetime max_creation_date:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_all_tasks_with_http_info(contract_id, task_id, task_type, task_state, limit, **kwargs)  # noqa: E501

    def get_all_tasks_with_http_info(self, contract_id, task_id, task_type, task_state, limit, **kwargs):  # noqa: E501
        """Get all tasks  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_tasks_with_http_info(contract_id, task_id, task_type, task_state, limit, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param list[str] contract_id: (required)
        :param list[str] task_id: (required)
        :param list[str] task_type: (required)
        :param list[str] task_state: (required)
        :param int limit: (required)
        :param datetime min_creation_date:
        :param datetime max_creation_date:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'task_id',
            'task_type',
            'task_state',
            'limit',
            'min_creation_date',
            'max_creation_date'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_tasks" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_all_tasks`")  # noqa: E501
        # verify the required parameter 'task_id' is set
        if self.api_client.client_side_validation and ('task_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['task_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `task_id` when calling `get_all_tasks`")  # noqa: E501
        # verify the required parameter 'task_type' is set
        if self.api_client.client_side_validation and ('task_type' not in local_var_params or  # noqa: E501
                                                        local_var_params['task_type'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `task_type` when calling `get_all_tasks`")  # noqa: E501
        # verify the required parameter 'task_state' is set
        if self.api_client.client_side_validation and ('task_state' not in local_var_params or  # noqa: E501
                                                        local_var_params['task_state'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `task_state` when calling `get_all_tasks`")  # noqa: E501
        # verify the required parameter 'limit' is set
        if self.api_client.client_side_validation and ('limit' not in local_var_params or  # noqa: E501
                                                        local_var_params['limit'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `limit` when calling `get_all_tasks`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'contract_id' in local_var_params and local_var_params['contract_id'] is not None:  # noqa: E501
            query_params.append(('contractId', local_var_params['contract_id']))  # noqa: E501
            collection_formats['contractId'] = 'multi'  # noqa: E501
        if 'task_id' in local_var_params and local_var_params['task_id'] is not None:  # noqa: E501
            query_params.append(('taskId', local_var_params['task_id']))  # noqa: E501
            collection_formats['taskId'] = 'multi'  # noqa: E501
        if 'task_type' in local_var_params and local_var_params['task_type'] is not None:  # noqa: E501
            query_params.append(('taskType', local_var_params['task_type']))  # noqa: E501
            collection_formats['taskType'] = 'multi'  # noqa: E501
        if 'task_state' in local_var_params and local_var_params['task_state'] is not None:  # noqa: E501
            query_params.append(('taskState', local_var_params['task_state']))  # noqa: E501
            collection_formats['taskState'] = 'multi'  # noqa: E501
        if 'min_creation_date' in local_var_params and local_var_params['min_creation_date'] is not None:  # noqa: E501
            query_params.append(('minCreationDate', local_var_params['min_creation_date']))  # noqa: E501
        if 'max_creation_date' in local_var_params and local_var_params['max_creation_date'] is not None:  # noqa: E501
            query_params.append(('maxCreationDate', local_var_params['max_creation_date']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/controlpanel/api/tasks', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_users(self, **kwargs):  # noqa: E501
        """Get a list of all users  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_users(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_all_users_with_http_info(**kwargs)  # noqa: E501

    def get_all_users_with_http_info(self, **kwargs):  # noqa: E501
        """Get a list of all users  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_users_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_users" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/controlpanel/api/users', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_authorization_status_vendor_v3(self, company_id, **kwargs):  # noqa: E501
        """Get authorization status for Amazon seller account  # noqa: E501

        Get OAuth authorization status for customer's Amazon seller central account. For setting up OAuth authorization, have a look at the endpoint POST /api/v3/companies/{companyId}/amazon/authorization.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_authorization_status_vendor_v3(company_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int company_id: ID of a company (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: GetAuthorizationStatusResponseV3ApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_authorization_status_vendor_v3_with_http_info(company_id, **kwargs)  # noqa: E501

    def get_authorization_status_vendor_v3_with_http_info(self, company_id, **kwargs):  # noqa: E501
        """Get authorization status for Amazon seller account  # noqa: E501

        Get OAuth authorization status for customer's Amazon seller central account. For setting up OAuth authorization, have a look at the endpoint POST /api/v3/companies/{companyId}/amazon/authorization.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_authorization_status_vendor_v3_with_http_info(company_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int company_id: ID of a company (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(GetAuthorizationStatusResponseV3ApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'company_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_authorization_status_vendor_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'company_id' is set
        if self.api_client.client_side_validation and ('company_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['company_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `company_id` when calling `get_authorization_status_vendor_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'company_id' in local_var_params:
            path_params['companyId'] = local_var_params['company_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/companies/{companyId}/amazon/authorization/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetAuthorizationStatusResponseV3ApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_callbacks(self, contract_id, **kwargs):  # noqa: E501
        """Get callbacks [manufacturer]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_callbacks(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Callbacks
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_callbacks_with_http_info(contract_id, **kwargs)  # noqa: E501

    def get_callbacks_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Get callbacks [manufacturer]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_callbacks_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Callbacks, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_callbacks" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_callbacks`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/m/contracts/{contractId}/settings/callbacks', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Callbacks',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_callbacks_vendor_v2(self, contract_id, **kwargs):  # noqa: E501
        """Get callbacks [vendor]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_callbacks_vendor_v2(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_callbacks_vendor_v2_with_http_info(contract_id, **kwargs)  # noqa: E501

    def get_callbacks_vendor_v2_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Get callbacks [vendor]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_callbacks_vendor_v2_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_callbacks_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_callbacks_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/settings/callbacks', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_cheapest_vendors_manufacturer_v2(self, contract_id, session, include_delivery_costs, **kwargs):  # noqa: E501
        """Query cheapest offers  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cheapest_vendors_manufacturer_v2(contract_id, session, include_delivery_costs, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param datetime session: (required)
        :param bool include_delivery_costs: (required)
        :param ComPatagonaPricemonitorShareApiTagFilteredVendorsRequest com_patagona_pricemonitor_share_api_tag_filtered_vendors_request: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_cheapest_vendors_manufacturer_v2_with_http_info(contract_id, session, include_delivery_costs, **kwargs)  # noqa: E501

    def get_cheapest_vendors_manufacturer_v2_with_http_info(self, contract_id, session, include_delivery_costs, **kwargs):  # noqa: E501
        """Query cheapest offers  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cheapest_vendors_manufacturer_v2_with_http_info(contract_id, session, include_delivery_costs, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param datetime session: (required)
        :param bool include_delivery_costs: (required)
        :param ComPatagonaPricemonitorShareApiTagFilteredVendorsRequest com_patagona_pricemonitor_share_api_tag_filtered_vendors_request: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'session',
            'include_delivery_costs',
            'com_patagona_pricemonitor_share_api_tag_filtered_vendors_request'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_cheapest_vendors_manufacturer_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_cheapest_vendors_manufacturer_v2`")  # noqa: E501
        # verify the required parameter 'session' is set
        if self.api_client.client_side_validation and ('session' not in local_var_params or  # noqa: E501
                                                        local_var_params['session'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `session` when calling `get_cheapest_vendors_manufacturer_v2`")  # noqa: E501
        # verify the required parameter 'include_delivery_costs' is set
        if self.api_client.client_side_validation and ('include_delivery_costs' not in local_var_params or  # noqa: E501
                                                        local_var_params['include_delivery_costs'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `include_delivery_costs` when calling `get_cheapest_vendors_manufacturer_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []
        if 'session' in local_var_params and local_var_params['session'] is not None:  # noqa: E501
            query_params.append(('session', local_var_params['session']))  # noqa: E501
        if 'include_delivery_costs' in local_var_params and local_var_params['include_delivery_costs'] is not None:  # noqa: E501
            query_params.append(('includeDeliveryCosts', local_var_params['include_delivery_costs']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'com_patagona_pricemonitor_share_api_tag_filtered_vendors_request' in local_var_params:
            body_params = local_var_params['com_patagona_pricemonitor_share_api_tag_filtered_vendors_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/m/contracts/{contractId}/result/vendors/cheapest', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_company(self, company_id, **kwargs):  # noqa: E501
        """Get company  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_company(company_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int company_id: ID of a company (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_company_with_http_info(company_id, **kwargs)  # noqa: E501

    def get_company_with_http_info(self, company_id, **kwargs):  # noqa: E501
        """Get company  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_company_with_http_info(company_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int company_id: ID of a company (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'company_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_company" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'company_id' is set
        if self.api_client.client_side_validation and ('company_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['company_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `company_id` when calling `get_company`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'company_id' in local_var_params:
            path_params['companyId'] = local_var_params['company_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/controlpanel/api/companies/{companyId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_complex_offer_filters_vendor_v2(self, contract_id, list_type, **kwargs):  # noqa: E501
        """Get all complex filters for the given contract.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_complex_offer_filters_vendor_v2(contract_id, list_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str list_type: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: OfferFilterApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_complex_offer_filters_vendor_v2_with_http_info(contract_id, list_type, **kwargs)  # noqa: E501

    def get_complex_offer_filters_vendor_v2_with_http_info(self, contract_id, list_type, **kwargs):  # noqa: E501
        """Get all complex filters for the given contract.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_complex_offer_filters_vendor_v2_with_http_info(contract_id, list_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str list_type: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(OfferFilterApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'list_type'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_complex_offer_filters_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_complex_offer_filters_vendor_v2`")  # noqa: E501
        # verify the required parameter 'list_type' is set
        if self.api_client.client_side_validation and ('list_type' not in local_var_params or  # noqa: E501
                                                        local_var_params['list_type'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `list_type` when calling `get_complex_offer_filters_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'list_type' in local_var_params:
            path_params['listType'] = local_var_params['list_type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/offerfilters/{listType}/complex', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='OfferFilterApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_contracts_vendor_v2(self, **kwargs):  # noqa: E501
        """Get contracts [vendor]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_contracts_vendor_v2(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param datetime max_creation_date:
        :param datetime min_expiration_date:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_contracts_vendor_v2_with_http_info(**kwargs)  # noqa: E501

    def get_contracts_vendor_v2_with_http_info(self, **kwargs):  # noqa: E501
        """Get contracts [vendor]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_contracts_vendor_v2_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param datetime max_creation_date:
        :param datetime min_expiration_date:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'max_creation_date',
            'min_expiration_date'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_contracts_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'max_creation_date' in local_var_params and local_var_params['max_creation_date'] is not None:  # noqa: E501
            query_params.append(('maxCreationDate', local_var_params['max_creation_date']))  # noqa: E501
        if 'min_expiration_date' in local_var_params and local_var_params['min_expiration_date'] is not None:  # noqa: E501
            query_params.append(('minExpirationDate', local_var_params['min_expiration_date']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_currency_vendor_v2(self, contract_id, **kwargs):  # noqa: E501
        """Get currency settings [vendor]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_currency_vendor_v2(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_currency_vendor_v2_with_http_info(contract_id, **kwargs)  # noqa: E501

    def get_currency_vendor_v2_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Get currency settings [vendor]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_currency_vendor_v2_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_currency_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_currency_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/settings/currency', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_customer_contract_settings_manufaturer_v3(self, contract_id, **kwargs):  # noqa: E501
        """Get contract settings [manufacturer]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_customer_contract_settings_manufaturer_v3(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: GetCustomerContractSettingsApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_customer_contract_settings_manufaturer_v3_with_http_info(contract_id, **kwargs)  # noqa: E501

    def get_customer_contract_settings_manufaturer_v3_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Get contract settings [manufacturer]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_customer_contract_settings_manufaturer_v3_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(GetCustomerContractSettingsApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_customer_contract_settings_manufaturer_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_customer_contract_settings_manufaturer_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/manufacturer/contracts/{contractId}/settings/customer', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetCustomerContractSettingsApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_customer_contract_settings_vendor_v3(self, contract_id, **kwargs):  # noqa: E501
        """Get customer contract settings [vendor]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_customer_contract_settings_vendor_v3(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: GetCustomerContractSettingsApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_customer_contract_settings_vendor_v3_with_http_info(contract_id, **kwargs)  # noqa: E501

    def get_customer_contract_settings_vendor_v3_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Get customer contract settings [vendor]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_customer_contract_settings_vendor_v3_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(GetCustomerContractSettingsApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_customer_contract_settings_vendor_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_customer_contract_settings_vendor_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/vendor/contracts/{contractId}/settings/customer', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetCustomerContractSettingsApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_domains_vendor_v2(self, contract_id, **kwargs):  # noqa: E501
        """Get domains for contract  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_domains_vendor_v2(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: StringArrayResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_domains_vendor_v2_with_http_info(contract_id, **kwargs)  # noqa: E501

    def get_domains_vendor_v2_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Get domains for contract  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_domains_vendor_v2_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(StringArrayResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_domains_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_domains_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/settings/domains', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StringArrayResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_dynamic_monitoring_settings(self, contract_id, **kwargs):  # noqa: E501
        """Get dynamic monitoring settings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dynamic_monitoring_settings(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_dynamic_monitoring_settings_with_http_info(contract_id, **kwargs)  # noqa: E501

    def get_dynamic_monitoring_settings_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Get dynamic monitoring settings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dynamic_monitoring_settings_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_dynamic_monitoring_settings" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_dynamic_monitoring_settings`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/1/{contractId}/settings/dynamicmonitoring', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_ebay_authorizations_vendor_v2(self, contract_id, auth_ids, **kwargs):  # noqa: E501
        """Get Ebay authorization  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ebay_authorizations_vendor_v2(contract_id, auth_ids, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str auth_ids: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_ebay_authorizations_vendor_v2_with_http_info(contract_id, auth_ids, **kwargs)  # noqa: E501

    def get_ebay_authorizations_vendor_v2_with_http_info(self, contract_id, auth_ids, **kwargs):  # noqa: E501
        """Get Ebay authorization  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ebay_authorizations_vendor_v2_with_http_info(contract_id, auth_ids, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str auth_ids: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'auth_ids'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_ebay_authorizations_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_ebay_authorizations_vendor_v2`")  # noqa: E501
        # verify the required parameter 'auth_ids' is set
        if self.api_client.client_side_validation and ('auth_ids' not in local_var_params or  # noqa: E501
                                                        local_var_params['auth_ids'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `auth_ids` when calling `get_ebay_authorizations_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'auth_ids' in local_var_params:
            path_params['authIds'] = local_var_params['auth_ids']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/settings/ebay/authorizations/{authIds}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_extended_tags_manufacturer_v3(self, contract_id, product_id, **kwargs):  # noqa: E501
        """Get extended tags [manufacturer]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_extended_tags_manufacturer_v3(contract_id, product_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str product_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_extended_tags_manufacturer_v3_with_http_info(contract_id, product_id, **kwargs)  # noqa: E501

    def get_extended_tags_manufacturer_v3_with_http_info(self, contract_id, product_id, **kwargs):  # noqa: E501
        """Get extended tags [manufacturer]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_extended_tags_manufacturer_v3_with_http_info(contract_id, product_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str product_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'product_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_extended_tags_manufacturer_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_extended_tags_manufacturer_v3`")  # noqa: E501
        # verify the required parameter 'product_id' is set
        if self.api_client.client_side_validation and ('product_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['product_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `product_id` when calling `get_extended_tags_manufacturer_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'product_id' in local_var_params:
            path_params['productId'] = local_var_params['product_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/manufacturer/contracts/{contractId}/products/{productId}/extendedtags', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_feed_export_delta_vendor_v2(self, contract_id, feed_id, **kwargs):  # noqa: E501
        """Get delta export feed  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_feed_export_delta_vendor_v2(contract_id, feed_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str feed_id: (required)
        :param str file_name:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_feed_export_delta_vendor_v2_with_http_info(contract_id, feed_id, **kwargs)  # noqa: E501

    def get_feed_export_delta_vendor_v2_with_http_info(self, contract_id, feed_id, **kwargs):  # noqa: E501
        """Get delta export feed  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_feed_export_delta_vendor_v2_with_http_info(contract_id, feed_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str feed_id: (required)
        :param str file_name:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'feed_id',
            'file_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_feed_export_delta_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_feed_export_delta_vendor_v2`")  # noqa: E501
        # verify the required parameter 'feed_id' is set
        if self.api_client.client_side_validation and ('feed_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['feed_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `feed_id` when calling `get_feed_export_delta_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'feed_id' in local_var_params:
            path_params['feedId'] = local_var_params['feed_id']  # noqa: E501

        query_params = []
        if 'file_name' in local_var_params and local_var_params['file_name'] is not None:  # noqa: E501
            query_params.append(('fileName', local_var_params['file_name']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/feeds/{feedId}/export/delta', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_feed_export_vendor_v2(self, contract_id, feed_id, **kwargs):  # noqa: E501
        """Get export feed  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_feed_export_vendor_v2(contract_id, feed_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str feed_id: (required)
        :param str file_name:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_feed_export_vendor_v2_with_http_info(contract_id, feed_id, **kwargs)  # noqa: E501

    def get_feed_export_vendor_v2_with_http_info(self, contract_id, feed_id, **kwargs):  # noqa: E501
        """Get export feed  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_feed_export_vendor_v2_with_http_info(contract_id, feed_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str feed_id: (required)
        :param str file_name:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'feed_id',
            'file_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_feed_export_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_feed_export_vendor_v2`")  # noqa: E501
        # verify the required parameter 'feed_id' is set
        if self.api_client.client_side_validation and ('feed_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['feed_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `feed_id` when calling `get_feed_export_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'feed_id' in local_var_params:
            path_params['feedId'] = local_var_params['feed_id']  # noqa: E501

        query_params = []
        if 'file_name' in local_var_params and local_var_params['file_name'] is not None:  # noqa: E501
            query_params.append(('fileName', local_var_params['file_name']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/feeds/{feedId}/export', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_import_settings_vendor_v2(self, contract_id, **kwargs):  # noqa: E501
        """Get import settings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_import_settings_vendor_v2(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_import_settings_vendor_v2_with_http_info(contract_id, **kwargs)  # noqa: E501

    def get_import_settings_vendor_v2_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Get import settings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_import_settings_vendor_v2_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_import_settings_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_import_settings_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/settings/import', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_looker_user_attributes(self, **kwargs):  # noqa: E501
        """Get Looker user attributes  # noqa: E501

        Retrieves user attributes from Looker. We created the endpoint to allow us to track the impact of the issue described in [Confluence](https://omniaretail.atlassian.net/wiki/spaces/DEV/pages/648151090/Looker+Dashboard+Mismatch+Problem+in+Omnia+2.0)   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_looker_user_attributes(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: LookerUserAttributesV3ApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_looker_user_attributes_with_http_info(**kwargs)  # noqa: E501

    def get_looker_user_attributes_with_http_info(self, **kwargs):  # noqa: E501
        """Get Looker user attributes  # noqa: E501

        Retrieves user attributes from Looker. We created the endpoint to allow us to track the impact of the issue described in [Confluence](https://omniaretail.atlassian.net/wiki/spaces/DEV/pages/648151090/Looker+Dashboard+Mismatch+Problem+in+Omnia+2.0)   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_looker_user_attributes_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(LookerUserAttributesV3ApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_looker_user_attributes" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/user/looker/attributes', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LookerUserAttributesV3ApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_manufacturer_manufacturer_v2(self, contract_id, **kwargs):  # noqa: E501
        """Get contract [manufacturer]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_manufacturer_manufacturer_v2(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_manufacturer_manufacturer_v2_with_http_info(contract_id, **kwargs)  # noqa: E501

    def get_manufacturer_manufacturer_v2_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Get contract [manufacturer]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_manufacturer_manufacturer_v2_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_manufacturer_manufacturer_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_manufacturer_manufacturer_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/m/contracts/{contractId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_manufacturer_v3(self, contract_id, **kwargs):  # noqa: E501
        """Get contract [manufacturer]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_manufacturer_v3(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: GetManufacturerV3ApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_manufacturer_v3_with_http_info(contract_id, **kwargs)  # noqa: E501

    def get_manufacturer_v3_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Get contract [manufacturer]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_manufacturer_v3_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(GetManufacturerV3ApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_manufacturer_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_manufacturer_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/manufacturer/contracts/{contractId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetManufacturerV3ApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_mappings_vendor_v2(self, contract_id, input_type, identifiers, **kwargs):  # noqa: E501
        """Get product mappings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_mappings_vendor_v2(contract_id, input_type, identifiers, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str input_type: (required)
        :param list[str] identifiers: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_mappings_vendor_v2_with_http_info(contract_id, input_type, identifiers, **kwargs)  # noqa: E501

    def get_mappings_vendor_v2_with_http_info(self, contract_id, input_type, identifiers, **kwargs):  # noqa: E501
        """Get product mappings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_mappings_vendor_v2_with_http_info(contract_id, input_type, identifiers, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str input_type: (required)
        :param list[str] identifiers: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'input_type',
            'identifiers'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_mappings_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_mappings_vendor_v2`")  # noqa: E501
        # verify the required parameter 'input_type' is set
        if self.api_client.client_side_validation and ('input_type' not in local_var_params or  # noqa: E501
                                                        local_var_params['input_type'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `input_type` when calling `get_mappings_vendor_v2`")  # noqa: E501
        # verify the required parameter 'identifiers' is set
        if self.api_client.client_side_validation and ('identifiers' not in local_var_params or  # noqa: E501
                                                        local_var_params['identifiers'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `identifiers` when calling `get_mappings_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []
        if 'input_type' in local_var_params and local_var_params['input_type'] is not None:  # noqa: E501
            query_params.append(('inputType', local_var_params['input_type']))  # noqa: E501
        if 'identifiers' in local_var_params and local_var_params['identifiers'] is not None:  # noqa: E501
            query_params.append(('identifiers', local_var_params['identifiers']))  # noqa: E501
            collection_formats['identifiers'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/productidentifiermapping', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_marketplace_activation_status(self, marketplace_country_code, company_id, contract_id, **kwargs):  # noqa: E501
        """Get marketplace activation status  # noqa: E501

        Get marketplace activation status of a customer in our system.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_marketplace_activation_status(marketplace_country_code, company_id, contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str marketplace_country_code: Marketplace country code. You can view complete list here. https://developer-docs.amazon.com/sp-api/docs/marketplace-ids. Currently, only Europe as a region is supported. (required)
        :param int company_id: ID of a company (required)
        :param str contract_id: ID of the contract (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ActivateMarketplaceResponseV3ApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_marketplace_activation_status_with_http_info(marketplace_country_code, company_id, contract_id, **kwargs)  # noqa: E501

    def get_marketplace_activation_status_with_http_info(self, marketplace_country_code, company_id, contract_id, **kwargs):  # noqa: E501
        """Get marketplace activation status  # noqa: E501

        Get marketplace activation status of a customer in our system.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_marketplace_activation_status_with_http_info(marketplace_country_code, company_id, contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str marketplace_country_code: Marketplace country code. You can view complete list here. https://developer-docs.amazon.com/sp-api/docs/marketplace-ids. Currently, only Europe as a region is supported. (required)
        :param int company_id: ID of a company (required)
        :param str contract_id: ID of the contract (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ActivateMarketplaceResponseV3ApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'marketplace_country_code',
            'company_id',
            'contract_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_marketplace_activation_status" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'marketplace_country_code' is set
        if self.api_client.client_side_validation and ('marketplace_country_code' not in local_var_params or  # noqa: E501
                                                        local_var_params['marketplace_country_code'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `marketplace_country_code` when calling `get_marketplace_activation_status`")  # noqa: E501
        # verify the required parameter 'company_id' is set
        if self.api_client.client_side_validation and ('company_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['company_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `company_id` when calling `get_marketplace_activation_status`")  # noqa: E501
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_marketplace_activation_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'marketplace_country_code' in local_var_params:
            path_params['marketplaceCountryCode'] = local_var_params['marketplace_country_code']  # noqa: E501
        if 'company_id' in local_var_params:
            path_params['companyId'] = local_var_params['company_id']  # noqa: E501
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/companies/{companyId}/amazon/marketplace/{marketplaceCountryCode}/contracts/{contractId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ActivateMarketplaceResponseV3ApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_monitoring_schedules_manufacturer_v3(self, contract_id, **kwargs):  # noqa: E501
        """Get all monitoring schedules for contract [manufacturer]  # noqa: E501

        Get all the monitoring schedules for a specified manufacturer contract.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_monitoring_schedules_manufacturer_v3(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: GetMonitoringSchedulesApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_monitoring_schedules_manufacturer_v3_with_http_info(contract_id, **kwargs)  # noqa: E501

    def get_monitoring_schedules_manufacturer_v3_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Get all monitoring schedules for contract [manufacturer]  # noqa: E501

        Get all the monitoring schedules for a specified manufacturer contract.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_monitoring_schedules_manufacturer_v3_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(GetMonitoringSchedulesApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_monitoring_schedules_manufacturer_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_monitoring_schedules_manufacturer_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/manufacturer/contracts/{contractId}/settings/monitoringschedules', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetMonitoringSchedulesApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_monitoring_schedules_vendor_v3(self, contract_id, **kwargs):  # noqa: E501
        """Get all monitoring schedules for contract [vendor]  # noqa: E501

        Get all the monitoring schedules for a specified vendor contract.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_monitoring_schedules_vendor_v3(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: GetMonitoringSchedulesApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_monitoring_schedules_vendor_v3_with_http_info(contract_id, **kwargs)  # noqa: E501

    def get_monitoring_schedules_vendor_v3_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Get all monitoring schedules for contract [vendor]  # noqa: E501

        Get all the monitoring schedules for a specified vendor contract.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_monitoring_schedules_vendor_v3_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(GetMonitoringSchedulesApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_monitoring_schedules_vendor_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_monitoring_schedules_vendor_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/vendor/contracts/{contractId}/settings/monitoringschedules', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetMonitoringSchedulesApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_monitoring_settings_manufacturer_v2(self, contract_id, **kwargs):  # noqa: E501
        """Get monitoring settings for contract  # noqa: E501

        Get the current monitoring settings for a given contract  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_monitoring_settings_manufacturer_v2(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_monitoring_settings_manufacturer_v2_with_http_info(contract_id, **kwargs)  # noqa: E501

    def get_monitoring_settings_manufacturer_v2_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Get monitoring settings for contract  # noqa: E501

        Get the current monitoring settings for a given contract  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_monitoring_settings_manufacturer_v2_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_monitoring_settings_manufacturer_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_monitoring_settings_manufacturer_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/m/contracts/{contractId}/settings/monitoring', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_monitoring_settings_manufacturer_v3(self, contract_id, **kwargs):  # noqa: E501
        """Get monitoring settings [manufacturer]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_monitoring_settings_manufacturer_v3(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_monitoring_settings_manufacturer_v3_with_http_info(contract_id, **kwargs)  # noqa: E501

    def get_monitoring_settings_manufacturer_v3_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Get monitoring settings [manufacturer]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_monitoring_settings_manufacturer_v3_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_monitoring_settings_manufacturer_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_monitoring_settings_manufacturer_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/manufacturer/contracts/{contractId}/settings/monitoring', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_monitoring_settings_vendor_v2(self, contract_id, **kwargs):  # noqa: E501
        """Get monitoring settings [vendor]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_monitoring_settings_vendor_v2(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_monitoring_settings_vendor_v2_with_http_info(contract_id, **kwargs)  # noqa: E501

    def get_monitoring_settings_vendor_v2_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Get monitoring settings [vendor]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_monitoring_settings_vendor_v2_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_monitoring_settings_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_monitoring_settings_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/settings/monitoring', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_monitoring_settings_vendor_v3(self, contract_id, **kwargs):  # noqa: E501
        """Get monitoring settings [vendor]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_monitoring_settings_vendor_v3(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_monitoring_settings_vendor_v3_with_http_info(contract_id, **kwargs)  # noqa: E501

    def get_monitoring_settings_vendor_v3_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Get monitoring settings [vendor]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_monitoring_settings_vendor_v3_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_monitoring_settings_vendor_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_monitoring_settings_vendor_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/vendor/contracts/{contractId}/settings/monitoring', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_offer_filters_vendor_v2(self, contract_id, list_type, **kwargs):  # noqa: E501
        """Get all vendor filters for contract  # noqa: E501

        Get all the vendor filters for the given contract.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_offer_filters_vendor_v2(contract_id, list_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str list_type: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_offer_filters_vendor_v2_with_http_info(contract_id, list_type, **kwargs)  # noqa: E501

    def get_offer_filters_vendor_v2_with_http_info(self, contract_id, list_type, **kwargs):  # noqa: E501
        """Get all vendor filters for contract  # noqa: E501

        Get all the vendor filters for the given contract.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_offer_filters_vendor_v2_with_http_info(contract_id, list_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str list_type: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'list_type'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_offer_filters_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_offer_filters_vendor_v2`")  # noqa: E501
        # verify the required parameter 'list_type' is set
        if self.api_client.client_side_validation and ('list_type' not in local_var_params or  # noqa: E501
                                                        local_var_params['list_type'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `list_type` when calling `get_offer_filters_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'list_type' in local_var_params:
            path_params['listType'] = local_var_params['list_type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/offerfilters/{listType}/vendors', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_offer_retention_settings_manufacturer_v3(self, contract_id, contract_type, **kwargs):  # noqa: E501
        """Get offer retention settings [manufacturer]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_offer_retention_settings_manufacturer_v3(contract_id, contract_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str contract_type: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_offer_retention_settings_manufacturer_v3_with_http_info(contract_id, contract_type, **kwargs)  # noqa: E501

    def get_offer_retention_settings_manufacturer_v3_with_http_info(self, contract_id, contract_type, **kwargs):  # noqa: E501
        """Get offer retention settings [manufacturer]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_offer_retention_settings_manufacturer_v3_with_http_info(contract_id, contract_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str contract_type: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'contract_type'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_offer_retention_settings_manufacturer_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_offer_retention_settings_manufacturer_v3`")  # noqa: E501
        # verify the required parameter 'contract_type' is set
        if self.api_client.client_side_validation and ('contract_type' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_type'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_type` when calling `get_offer_retention_settings_manufacturer_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []
        if 'contract_type' in local_var_params and local_var_params['contract_type'] is not None:  # noqa: E501
            query_params.append(('contractType', local_var_params['contract_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/manufacturer/contracts/{contractId}/settings/offerretention', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_offer_retention_settings_vendor_v3(self, contract_id, contract_type, **kwargs):  # noqa: E501
        """Get offer retention settings [vendor]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_offer_retention_settings_vendor_v3(contract_id, contract_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str contract_type: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_offer_retention_settings_vendor_v3_with_http_info(contract_id, contract_type, **kwargs)  # noqa: E501

    def get_offer_retention_settings_vendor_v3_with_http_info(self, contract_id, contract_type, **kwargs):  # noqa: E501
        """Get offer retention settings [vendor]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_offer_retention_settings_vendor_v3_with_http_info(contract_id, contract_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str contract_type: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'contract_type'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_offer_retention_settings_vendor_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_offer_retention_settings_vendor_v3`")  # noqa: E501
        # verify the required parameter 'contract_type' is set
        if self.api_client.client_side_validation and ('contract_type' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_type'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_type` when calling `get_offer_retention_settings_vendor_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []
        if 'contract_type' in local_var_params and local_var_params['contract_type'] is not None:  # noqa: E501
            query_params.append(('contractType', local_var_params['contract_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/vendor/contracts/{contractId}/settings/offerretention', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_offer_statistics_manufacturer_v3(self, contract_id, include_delivery_costs, **kwargs):  # noqa: E501
        """Get offer statistics per product of a contract  # noqa: E501

        Get offer statistics per product of a contract. Only the latest offers per product and domain the are taken into account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_offer_statistics_manufacturer_v3(contract_id, include_delivery_costs, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param bool include_delivery_costs: (required)
        :param datetime start_date: Timestamp of start of time range, formatted as ISO Date (i.e. 2018-04-06T13:46:13Z) in UTC. If this value is omitted and {endDate} is given, {startDate} is set to {endDate} - 48 hours. If both values are omitted, the range is 'NOW - 48 hours to NOW'.
        :param datetime end_date: Timestamp of end of time range, formatted as ISO Date (i.e. 2018-04-06T13:46:13Z) in UTC. If this value is omitted and {startDate} is given, {endDate} is set to {startDate} + 48 hours. If both values are omitted, the range is 'NOW - 48 hours to NOW'.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: GetOfferStatisticsV3ApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_offer_statistics_manufacturer_v3_with_http_info(contract_id, include_delivery_costs, **kwargs)  # noqa: E501

    def get_offer_statistics_manufacturer_v3_with_http_info(self, contract_id, include_delivery_costs, **kwargs):  # noqa: E501
        """Get offer statistics per product of a contract  # noqa: E501

        Get offer statistics per product of a contract. Only the latest offers per product and domain the are taken into account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_offer_statistics_manufacturer_v3_with_http_info(contract_id, include_delivery_costs, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param bool include_delivery_costs: (required)
        :param datetime start_date: Timestamp of start of time range, formatted as ISO Date (i.e. 2018-04-06T13:46:13Z) in UTC. If this value is omitted and {endDate} is given, {startDate} is set to {endDate} - 48 hours. If both values are omitted, the range is 'NOW - 48 hours to NOW'.
        :param datetime end_date: Timestamp of end of time range, formatted as ISO Date (i.e. 2018-04-06T13:46:13Z) in UTC. If this value is omitted and {startDate} is given, {endDate} is set to {startDate} + 48 hours. If both values are omitted, the range is 'NOW - 48 hours to NOW'.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(GetOfferStatisticsV3ApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'include_delivery_costs',
            'start_date',
            'end_date'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_offer_statistics_manufacturer_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_offer_statistics_manufacturer_v3`")  # noqa: E501
        # verify the required parameter 'include_delivery_costs' is set
        if self.api_client.client_side_validation and ('include_delivery_costs' not in local_var_params or  # noqa: E501
                                                        local_var_params['include_delivery_costs'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `include_delivery_costs` when calling `get_offer_statistics_manufacturer_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []
        if 'start_date' in local_var_params and local_var_params['start_date'] is not None:  # noqa: E501
            query_params.append(('startDate', local_var_params['start_date']))  # noqa: E501
        if 'end_date' in local_var_params and local_var_params['end_date'] is not None:  # noqa: E501
            query_params.append(('endDate', local_var_params['end_date']))  # noqa: E501
        if 'include_delivery_costs' in local_var_params and local_var_params['include_delivery_costs'] is not None:  # noqa: E501
            query_params.append(('includeDeliveryCosts', local_var_params['include_delivery_costs']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/manufacturer/contracts/{contractId}/offers/stats', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetOfferStatisticsV3ApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_offers(self, contract_id, start, limit, **kwargs):  # noqa: E501
        """Get all offers for all products  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_offers(contract_id, start, limit, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param int start: Start product index for pagination (required)
        :param int limit: Number of products for pagination (required)
        :param datetime start_date: Timestamp of start of time range, formatted as ISO Date (i.e. 2018-04-06T13:46:13Z) in UTC. If this value is omitted and {endDate} is given, {startDate} is set to {endDate} - 48 hours. If both values are omitted, the range is 'NOW - 48 hours to NOW'.
        :param datetime end_date: Timestamp of end of time range, formatted as ISO Date (i.e. 2018-04-06T13:46:13Z) in UTC. If this value is omitted and {startDate} is given, {endDate} is set to {startDate} + 48 hours. If both values are omitted, the range is 'NOW - 48 hours to NOW'.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: GetOffersResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_offers_with_http_info(contract_id, start, limit, **kwargs)  # noqa: E501

    def get_offers_with_http_info(self, contract_id, start, limit, **kwargs):  # noqa: E501
        """Get all offers for all products  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_offers_with_http_info(contract_id, start, limit, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param int start: Start product index for pagination (required)
        :param int limit: Number of products for pagination (required)
        :param datetime start_date: Timestamp of start of time range, formatted as ISO Date (i.e. 2018-04-06T13:46:13Z) in UTC. If this value is omitted and {endDate} is given, {startDate} is set to {endDate} - 48 hours. If both values are omitted, the range is 'NOW - 48 hours to NOW'.
        :param datetime end_date: Timestamp of end of time range, formatted as ISO Date (i.e. 2018-04-06T13:46:13Z) in UTC. If this value is omitted and {startDate} is given, {endDate} is set to {startDate} + 48 hours. If both values are omitted, the range is 'NOW - 48 hours to NOW'.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(GetOffersResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'start',
            'limit',
            'start_date',
            'end_date'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_offers" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_offers`")  # noqa: E501
        # verify the required parameter 'start' is set
        if self.api_client.client_side_validation and ('start' not in local_var_params or  # noqa: E501
                                                        local_var_params['start'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `start` when calling `get_offers`")  # noqa: E501
        # verify the required parameter 'limit' is set
        if self.api_client.client_side_validation and ('limit' not in local_var_params or  # noqa: E501
                                                        local_var_params['limit'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `limit` when calling `get_offers`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []
        if 'start' in local_var_params and local_var_params['start'] is not None:  # noqa: E501
            query_params.append(('start', local_var_params['start']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'start_date' in local_var_params and local_var_params['start_date'] is not None:  # noqa: E501
            query_params.append(('startDate', local_var_params['start_date']))  # noqa: E501
        if 'end_date' in local_var_params and local_var_params['end_date'] is not None:  # noqa: E501
            query_params.append(('endDate', local_var_params['end_date']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/result/offers', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetOffersResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_offers_shops_manufacturer_v3(self, contract_id, **kwargs):  # noqa: E501
        """Get shops with offers for time range  # noqa: E501

        Returns all shops which have at least one offer for a given time range per domain.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_offers_shops_manufacturer_v3(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param datetime start_date: Timestamp of start of time range, formatted as ISO Date (i.e. 2018-04-06T13:46:13Z) in UTC. If this value is omitted and {endDate} is given, {startDate} is set to {endDate} - 48 hours. If both values are omitted, the range is 'NOW - 48 hours to NOW'. The time range may not exceed 1 week.
        :param datetime end_date: Timestamp of end of time range, formatted as ISO Date (i.e. 2018-04-06T13:46:13Z) in UTC. If this value is omitted and {startDate} is given, {endDate} is set to {startDate} + 48 hours. If both values are omitted, the range is 'NOW - 48 hours to NOW'. The time range may not exceed 1 week.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: GetShopsByDomainResponseV3ApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_offers_shops_manufacturer_v3_with_http_info(contract_id, **kwargs)  # noqa: E501

    def get_offers_shops_manufacturer_v3_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Get shops with offers for time range  # noqa: E501

        Returns all shops which have at least one offer for a given time range per domain.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_offers_shops_manufacturer_v3_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param datetime start_date: Timestamp of start of time range, formatted as ISO Date (i.e. 2018-04-06T13:46:13Z) in UTC. If this value is omitted and {endDate} is given, {startDate} is set to {endDate} - 48 hours. If both values are omitted, the range is 'NOW - 48 hours to NOW'. The time range may not exceed 1 week.
        :param datetime end_date: Timestamp of end of time range, formatted as ISO Date (i.e. 2018-04-06T13:46:13Z) in UTC. If this value is omitted and {startDate} is given, {endDate} is set to {startDate} + 48 hours. If both values are omitted, the range is 'NOW - 48 hours to NOW'. The time range may not exceed 1 week.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(GetShopsByDomainResponseV3ApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'start_date',
            'end_date'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_offers_shops_manufacturer_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_offers_shops_manufacturer_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []
        if 'start_date' in local_var_params and local_var_params['start_date'] is not None:  # noqa: E501
            query_params.append(('startDate', local_var_params['start_date']))  # noqa: E501
        if 'end_date' in local_var_params and local_var_params['end_date'] is not None:  # noqa: E501
            query_params.append(('endDate', local_var_params['end_date']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/manufacturer/contracts/{contractId}/offers/shops', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetShopsByDomainResponseV3ApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_offers_shops_vendor_v3(self, contract_id, **kwargs):  # noqa: E501
        """Get shops with offers for time range per domain  # noqa: E501

        Returns all shops which have at least one offer for a given time range per domain.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_offers_shops_vendor_v3(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param datetime start_date: Timestamp of start of time range, formatted as ISO Date (i.e. 2018-04-06T13:46:13Z) in UTC. If this value is omitted and {endDate} is given, {startDate} is set to {endDate} - 48 hours. If both values are omitted, the range is 'NOW - 48 hours to NOW'. The time range may not exceed 1 week.
        :param datetime end_date: Timestamp of end of time range, formatted as ISO Date (i.e. 2018-04-06T13:46:13Z) in UTC. If this value is omitted and {startDate} is given, {endDate} is set to {startDate} + 48 hours. If both values are omitted, the range is 'NOW - 48 hours to NOW'. The time range may not exceed 1 week.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: GetShopsByDomainResponseV3ApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_offers_shops_vendor_v3_with_http_info(contract_id, **kwargs)  # noqa: E501

    def get_offers_shops_vendor_v3_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Get shops with offers for time range per domain  # noqa: E501

        Returns all shops which have at least one offer for a given time range per domain.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_offers_shops_vendor_v3_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param datetime start_date: Timestamp of start of time range, formatted as ISO Date (i.e. 2018-04-06T13:46:13Z) in UTC. If this value is omitted and {endDate} is given, {startDate} is set to {endDate} - 48 hours. If both values are omitted, the range is 'NOW - 48 hours to NOW'. The time range may not exceed 1 week.
        :param datetime end_date: Timestamp of end of time range, formatted as ISO Date (i.e. 2018-04-06T13:46:13Z) in UTC. If this value is omitted and {startDate} is given, {endDate} is set to {startDate} + 48 hours. If both values are omitted, the range is 'NOW - 48 hours to NOW'. The time range may not exceed 1 week.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(GetShopsByDomainResponseV3ApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'start_date',
            'end_date'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_offers_shops_vendor_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_offers_shops_vendor_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []
        if 'start_date' in local_var_params and local_var_params['start_date'] is not None:  # noqa: E501
            query_params.append(('startDate', local_var_params['start_date']))  # noqa: E501
        if 'end_date' in local_var_params and local_var_params['end_date'] is not None:  # noqa: E501
            query_params.append(('endDate', local_var_params['end_date']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/vendor/contracts/{contractId}/offers/shops', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetShopsByDomainResponseV3ApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_orders_count_by_portal_by_contract(self, contract_id, **kwargs):  # noqa: E501
        """Get orders count by portal  # noqa: E501

        Get the number of orders by portal for the given contract.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_orders_count_by_portal_by_contract(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_orders_count_by_portal_by_contract_with_http_info(contract_id, **kwargs)  # noqa: E501

    def get_orders_count_by_portal_by_contract_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Get orders count by portal  # noqa: E501

        Get the number of orders by portal for the given contract.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_orders_count_by_portal_by_contract_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_orders_count_by_portal_by_contract" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_orders_count_by_portal_by_contract`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/1/{contractId}/products/orderscountbyportal', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_price_cutters_manufacturer_v2(self, contract_id, session, limit, include_delivery_costs, **kwargs):  # noqa: E501
        """Query price cutters [manufacturer]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_price_cutters_manufacturer_v2(contract_id, session, limit, include_delivery_costs, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param datetime session: (required)
        :param int limit: (required)
        :param bool include_delivery_costs: (required)
        :param object body: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_price_cutters_manufacturer_v2_with_http_info(contract_id, session, limit, include_delivery_costs, **kwargs)  # noqa: E501

    def get_price_cutters_manufacturer_v2_with_http_info(self, contract_id, session, limit, include_delivery_costs, **kwargs):  # noqa: E501
        """Query price cutters [manufacturer]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_price_cutters_manufacturer_v2_with_http_info(contract_id, session, limit, include_delivery_costs, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param datetime session: (required)
        :param int limit: (required)
        :param bool include_delivery_costs: (required)
        :param object body: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'session',
            'limit',
            'include_delivery_costs',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_price_cutters_manufacturer_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_price_cutters_manufacturer_v2`")  # noqa: E501
        # verify the required parameter 'session' is set
        if self.api_client.client_side_validation and ('session' not in local_var_params or  # noqa: E501
                                                        local_var_params['session'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `session` when calling `get_price_cutters_manufacturer_v2`")  # noqa: E501
        # verify the required parameter 'limit' is set
        if self.api_client.client_side_validation and ('limit' not in local_var_params or  # noqa: E501
                                                        local_var_params['limit'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `limit` when calling `get_price_cutters_manufacturer_v2`")  # noqa: E501
        # verify the required parameter 'include_delivery_costs' is set
        if self.api_client.client_side_validation and ('include_delivery_costs' not in local_var_params or  # noqa: E501
                                                        local_var_params['include_delivery_costs'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `include_delivery_costs` when calling `get_price_cutters_manufacturer_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []
        if 'session' in local_var_params and local_var_params['session'] is not None:  # noqa: E501
            query_params.append(('session', local_var_params['session']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'include_delivery_costs' in local_var_params and local_var_params['include_delivery_costs'] is not None:  # noqa: E501
            query_params.append(('includeDeliveryCosts', local_var_params['include_delivery_costs']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/m/contracts/{contractId}/result/pricecutters', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_price_cutters_vendor_v2(self, contract_id, session, limit, include_delivery_costs, **kwargs):  # noqa: E501
        """Query price cutters [vendor]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_price_cutters_vendor_v2(contract_id, session, limit, include_delivery_costs, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param datetime session: (required)
        :param int limit: (required)
        :param bool include_delivery_costs: (required)
        :param object body: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_price_cutters_vendor_v2_with_http_info(contract_id, session, limit, include_delivery_costs, **kwargs)  # noqa: E501

    def get_price_cutters_vendor_v2_with_http_info(self, contract_id, session, limit, include_delivery_costs, **kwargs):  # noqa: E501
        """Query price cutters [vendor]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_price_cutters_vendor_v2_with_http_info(contract_id, session, limit, include_delivery_costs, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param datetime session: (required)
        :param int limit: (required)
        :param bool include_delivery_costs: (required)
        :param object body: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'session',
            'limit',
            'include_delivery_costs',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_price_cutters_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_price_cutters_vendor_v2`")  # noqa: E501
        # verify the required parameter 'session' is set
        if self.api_client.client_side_validation and ('session' not in local_var_params or  # noqa: E501
                                                        local_var_params['session'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `session` when calling `get_price_cutters_vendor_v2`")  # noqa: E501
        # verify the required parameter 'limit' is set
        if self.api_client.client_side_validation and ('limit' not in local_var_params or  # noqa: E501
                                                        local_var_params['limit'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `limit` when calling `get_price_cutters_vendor_v2`")  # noqa: E501
        # verify the required parameter 'include_delivery_costs' is set
        if self.api_client.client_side_validation and ('include_delivery_costs' not in local_var_params or  # noqa: E501
                                                        local_var_params['include_delivery_costs'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `include_delivery_costs` when calling `get_price_cutters_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []
        if 'session' in local_var_params and local_var_params['session'] is not None:  # noqa: E501
            query_params.append(('session', local_var_params['session']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'include_delivery_costs' in local_var_params and local_var_params['include_delivery_costs'] is not None:  # noqa: E501
            query_params.append(('includeDeliveryCosts', local_var_params['include_delivery_costs']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/result/pricecutters', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_price_recommendation_stats_vendor_v2(self, contract_id, start_time, end_time, max_positions, **kwargs):  # noqa: E501
        """Get price reommendation stats  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_price_recommendation_stats_vendor_v2(contract_id, start_time, end_time, max_positions, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param datetime start_time: (required)
        :param datetime end_time: (required)
        :param int max_positions: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_price_recommendation_stats_vendor_v2_with_http_info(contract_id, start_time, end_time, max_positions, **kwargs)  # noqa: E501

    def get_price_recommendation_stats_vendor_v2_with_http_info(self, contract_id, start_time, end_time, max_positions, **kwargs):  # noqa: E501
        """Get price reommendation stats  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_price_recommendation_stats_vendor_v2_with_http_info(contract_id, start_time, end_time, max_positions, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param datetime start_time: (required)
        :param datetime end_time: (required)
        :param int max_positions: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'start_time',
            'end_time',
            'max_positions'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_price_recommendation_stats_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_price_recommendation_stats_vendor_v2`")  # noqa: E501
        # verify the required parameter 'start_time' is set
        if self.api_client.client_side_validation and ('start_time' not in local_var_params or  # noqa: E501
                                                        local_var_params['start_time'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `start_time` when calling `get_price_recommendation_stats_vendor_v2`")  # noqa: E501
        # verify the required parameter 'end_time' is set
        if self.api_client.client_side_validation and ('end_time' not in local_var_params or  # noqa: E501
                                                        local_var_params['end_time'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `end_time` when calling `get_price_recommendation_stats_vendor_v2`")  # noqa: E501
        # verify the required parameter 'max_positions' is set
        if self.api_client.client_side_validation and ('max_positions' not in local_var_params or  # noqa: E501
                                                        local_var_params['max_positions'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `max_positions` when calling `get_price_recommendation_stats_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []
        if 'start_time' in local_var_params and local_var_params['start_time'] is not None:  # noqa: E501
            query_params.append(('startTime', local_var_params['start_time']))  # noqa: E501
        if 'end_time' in local_var_params and local_var_params['end_time'] is not None:  # noqa: E501
            query_params.append(('endTime', local_var_params['end_time']))  # noqa: E501
        if 'max_positions' in local_var_params and local_var_params['max_positions'] is not None:  # noqa: E501
            query_params.append(('maxPositions', local_var_params['max_positions']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/result/pricerecommendationstats', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_product_filters_by_id_vendor_v2(self, contract_id, **kwargs):  # noqa: E501
        """Get filtered offers  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_product_filters_by_id_vendor_v2(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_product_filters_by_id_vendor_v2_with_http_info(contract_id, **kwargs)  # noqa: E501

    def get_product_filters_by_id_vendor_v2_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Get filtered offers  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_product_filters_by_id_vendor_v2_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_product_filters_by_id_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_product_filters_by_id_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/offerfilters/:listType/products/query', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_product_filters_by_range_vendor_v2(self, contract_id, list_type, start, limit, **kwargs):  # noqa: E501
        """Get all the filters product-wise for the given contract.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_product_filters_by_range_vendor_v2(contract_id, list_type, start, limit, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str list_type: (required)
        :param int start: (required)
        :param int limit: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_product_filters_by_range_vendor_v2_with_http_info(contract_id, list_type, start, limit, **kwargs)  # noqa: E501

    def get_product_filters_by_range_vendor_v2_with_http_info(self, contract_id, list_type, start, limit, **kwargs):  # noqa: E501
        """Get all the filters product-wise for the given contract.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_product_filters_by_range_vendor_v2_with_http_info(contract_id, list_type, start, limit, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str list_type: (required)
        :param int start: (required)
        :param int limit: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'list_type',
            'start',
            'limit'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_product_filters_by_range_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_product_filters_by_range_vendor_v2`")  # noqa: E501
        # verify the required parameter 'list_type' is set
        if self.api_client.client_side_validation and ('list_type' not in local_var_params or  # noqa: E501
                                                        local_var_params['list_type'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `list_type` when calling `get_product_filters_by_range_vendor_v2`")  # noqa: E501
        # verify the required parameter 'start' is set
        if self.api_client.client_side_validation and ('start' not in local_var_params or  # noqa: E501
                                                        local_var_params['start'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `start` when calling `get_product_filters_by_range_vendor_v2`")  # noqa: E501
        # verify the required parameter 'limit' is set
        if self.api_client.client_side_validation and ('limit' not in local_var_params or  # noqa: E501
                                                        local_var_params['limit'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `limit` when calling `get_product_filters_by_range_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'list_type' in local_var_params:
            path_params['listType'] = local_var_params['list_type']  # noqa: E501

        query_params = []
        if 'start' in local_var_params and local_var_params['start'] is not None:  # noqa: E501
            query_params.append(('start', local_var_params['start']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/offerfilters/{listType}/products', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_product_filters_vendor_v2(self, contract_id, list_type, product_id, **kwargs):  # noqa: E501
        """Get all the filters of a given product for the given contract.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_product_filters_vendor_v2(contract_id, list_type, product_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str list_type: (required)
        :param str product_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: OfferFilterApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_product_filters_vendor_v2_with_http_info(contract_id, list_type, product_id, **kwargs)  # noqa: E501

    def get_product_filters_vendor_v2_with_http_info(self, contract_id, list_type, product_id, **kwargs):  # noqa: E501
        """Get all the filters of a given product for the given contract.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_product_filters_vendor_v2_with_http_info(contract_id, list_type, product_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str list_type: (required)
        :param str product_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(OfferFilterApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'list_type',
            'product_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_product_filters_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_product_filters_vendor_v2`")  # noqa: E501
        # verify the required parameter 'list_type' is set
        if self.api_client.client_side_validation and ('list_type' not in local_var_params or  # noqa: E501
                                                        local_var_params['list_type'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `list_type` when calling `get_product_filters_vendor_v2`")  # noqa: E501
        # verify the required parameter 'product_id' is set
        if self.api_client.client_side_validation and ('product_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['product_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `product_id` when calling `get_product_filters_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'list_type' in local_var_params:
            path_params['listType'] = local_var_params['list_type']  # noqa: E501
        if 'product_id' in local_var_params:
            path_params['productId'] = local_var_params['product_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/offerfilters/{listType}/products/{productId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='OfferFilterApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_product_metrics_by_contract(self, contract_id, start, end, **kwargs):  # noqa: E501
        """Get product metrics for contract  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_product_metrics_by_contract(contract_id, start, end, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param datetime start: (required)
        :param datetime end: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_product_metrics_by_contract_with_http_info(contract_id, start, end, **kwargs)  # noqa: E501

    def get_product_metrics_by_contract_with_http_info(self, contract_id, start, end, **kwargs):  # noqa: E501
        """Get product metrics for contract  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_product_metrics_by_contract_with_http_info(contract_id, start, end, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param datetime start: (required)
        :param datetime end: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'start',
            'end'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_product_metrics_by_contract" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_product_metrics_by_contract`")  # noqa: E501
        # verify the required parameter 'start' is set
        if self.api_client.client_side_validation and ('start' not in local_var_params or  # noqa: E501
                                                        local_var_params['start'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `start` when calling `get_product_metrics_by_contract`")  # noqa: E501
        # verify the required parameter 'end' is set
        if self.api_client.client_side_validation and ('end' not in local_var_params or  # noqa: E501
                                                        local_var_params['end'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `end` when calling `get_product_metrics_by_contract`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []
        if 'start' in local_var_params and local_var_params['start'] is not None:  # noqa: E501
            query_params.append(('start', local_var_params['start']))  # noqa: E501
        if 'end' in local_var_params and local_var_params['end'] is not None:  # noqa: E501
            query_params.append(('end', local_var_params['end']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/1/{contractId}/products/articlescountbyportal', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_product_monitoring_status_stats_vendor_v3(self, contract_id, **kwargs):  # noqa: E501
        """Get product monitoring status stats [vendor]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_product_monitoring_status_stats_vendor_v3(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: GetProductMonitoringStatusStatsVendorV3ApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_product_monitoring_status_stats_vendor_v3_with_http_info(contract_id, **kwargs)  # noqa: E501

    def get_product_monitoring_status_stats_vendor_v3_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Get product monitoring status stats [vendor]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_product_monitoring_status_stats_vendor_v3_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(GetProductMonitoringStatusStatsVendorV3ApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_product_monitoring_status_stats_vendor_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_product_monitoring_status_stats_vendor_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/vendor/contracts/{contractId}/products/monitoringstatus/stats', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetProductMonitoringStatusStatsVendorV3ApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_product_price_violations_manufacturer_v2(self, contract_id, start, end, include_delivery_costs, reference_price_delta, **kwargs):  # noqa: E501
        """Get product price violations [manufacturer]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_product_price_violations_manufacturer_v2(contract_id, start, end, include_delivery_costs, reference_price_delta, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param datetime start: (required)
        :param datetime end: (required)
        :param bool include_delivery_costs: (required)
        :param float reference_price_delta: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_product_price_violations_manufacturer_v2_with_http_info(contract_id, start, end, include_delivery_costs, reference_price_delta, **kwargs)  # noqa: E501

    def get_product_price_violations_manufacturer_v2_with_http_info(self, contract_id, start, end, include_delivery_costs, reference_price_delta, **kwargs):  # noqa: E501
        """Get product price violations [manufacturer]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_product_price_violations_manufacturer_v2_with_http_info(contract_id, start, end, include_delivery_costs, reference_price_delta, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param datetime start: (required)
        :param datetime end: (required)
        :param bool include_delivery_costs: (required)
        :param float reference_price_delta: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'start',
            'end',
            'include_delivery_costs',
            'reference_price_delta'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_product_price_violations_manufacturer_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_product_price_violations_manufacturer_v2`")  # noqa: E501
        # verify the required parameter 'start' is set
        if self.api_client.client_side_validation and ('start' not in local_var_params or  # noqa: E501
                                                        local_var_params['start'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `start` when calling `get_product_price_violations_manufacturer_v2`")  # noqa: E501
        # verify the required parameter 'end' is set
        if self.api_client.client_side_validation and ('end' not in local_var_params or  # noqa: E501
                                                        local_var_params['end'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `end` when calling `get_product_price_violations_manufacturer_v2`")  # noqa: E501
        # verify the required parameter 'include_delivery_costs' is set
        if self.api_client.client_side_validation and ('include_delivery_costs' not in local_var_params or  # noqa: E501
                                                        local_var_params['include_delivery_costs'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `include_delivery_costs` when calling `get_product_price_violations_manufacturer_v2`")  # noqa: E501
        # verify the required parameter 'reference_price_delta' is set
        if self.api_client.client_side_validation and ('reference_price_delta' not in local_var_params or  # noqa: E501
                                                        local_var_params['reference_price_delta'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `reference_price_delta` when calling `get_product_price_violations_manufacturer_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []
        if 'start' in local_var_params and local_var_params['start'] is not None:  # noqa: E501
            query_params.append(('start', local_var_params['start']))  # noqa: E501
        if 'end' in local_var_params and local_var_params['end'] is not None:  # noqa: E501
            query_params.append(('end', local_var_params['end']))  # noqa: E501
        if 'include_delivery_costs' in local_var_params and local_var_params['include_delivery_costs'] is not None:  # noqa: E501
            query_params.append(('includeDeliveryCosts', local_var_params['include_delivery_costs']))  # noqa: E501
        if 'reference_price_delta' in local_var_params and local_var_params['reference_price_delta'] is not None:  # noqa: E501
            query_params.append(('referencePriceDelta', local_var_params['reference_price_delta']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/m/contracts/{contractId}/result/priceviolations', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_product_price_violations_vendor_v2(self, contract_id, start, end, include_delivery_costs, reference_price_delta, **kwargs):  # noqa: E501
        """Get product price violations [vendor]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_product_price_violations_vendor_v2(contract_id, start, end, include_delivery_costs, reference_price_delta, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param datetime start: (required)
        :param datetime end: (required)
        :param bool include_delivery_costs: (required)
        :param float reference_price_delta: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_product_price_violations_vendor_v2_with_http_info(contract_id, start, end, include_delivery_costs, reference_price_delta, **kwargs)  # noqa: E501

    def get_product_price_violations_vendor_v2_with_http_info(self, contract_id, start, end, include_delivery_costs, reference_price_delta, **kwargs):  # noqa: E501
        """Get product price violations [vendor]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_product_price_violations_vendor_v2_with_http_info(contract_id, start, end, include_delivery_costs, reference_price_delta, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param datetime start: (required)
        :param datetime end: (required)
        :param bool include_delivery_costs: (required)
        :param float reference_price_delta: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'start',
            'end',
            'include_delivery_costs',
            'reference_price_delta'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_product_price_violations_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_product_price_violations_vendor_v2`")  # noqa: E501
        # verify the required parameter 'start' is set
        if self.api_client.client_side_validation and ('start' not in local_var_params or  # noqa: E501
                                                        local_var_params['start'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `start` when calling `get_product_price_violations_vendor_v2`")  # noqa: E501
        # verify the required parameter 'end' is set
        if self.api_client.client_side_validation and ('end' not in local_var_params or  # noqa: E501
                                                        local_var_params['end'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `end` when calling `get_product_price_violations_vendor_v2`")  # noqa: E501
        # verify the required parameter 'include_delivery_costs' is set
        if self.api_client.client_side_validation and ('include_delivery_costs' not in local_var_params or  # noqa: E501
                                                        local_var_params['include_delivery_costs'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `include_delivery_costs` when calling `get_product_price_violations_vendor_v2`")  # noqa: E501
        # verify the required parameter 'reference_price_delta' is set
        if self.api_client.client_side_validation and ('reference_price_delta' not in local_var_params or  # noqa: E501
                                                        local_var_params['reference_price_delta'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `reference_price_delta` when calling `get_product_price_violations_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []
        if 'start' in local_var_params and local_var_params['start'] is not None:  # noqa: E501
            query_params.append(('start', local_var_params['start']))  # noqa: E501
        if 'end' in local_var_params and local_var_params['end'] is not None:  # noqa: E501
            query_params.append(('end', local_var_params['end']))  # noqa: E501
        if 'include_delivery_costs' in local_var_params and local_var_params['include_delivery_costs'] is not None:  # noqa: E501
            query_params.append(('includeDeliveryCosts', local_var_params['include_delivery_costs']))  # noqa: E501
        if 'reference_price_delta' in local_var_params and local_var_params['reference_price_delta'] is not None:  # noqa: E501
            query_params.append(('referencePriceDelta', local_var_params['reference_price_delta']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/result/priceviolations', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_product_properties_v3(self, contract_id, product_id, **kwargs):  # noqa: E501
        """Get all product properties for a product  # noqa: E501

        This endpoint returns a list product properties for a certain product and contract. Product properties represent additional information for a product, independent of the imported products and tags.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_product_properties_v3(contract_id, product_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param int product_id: ID of the product (Omnia's internal product id) (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: GetProductPropertiesV3ApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_product_properties_v3_with_http_info(contract_id, product_id, **kwargs)  # noqa: E501

    def get_product_properties_v3_with_http_info(self, contract_id, product_id, **kwargs):  # noqa: E501
        """Get all product properties for a product  # noqa: E501

        This endpoint returns a list product properties for a certain product and contract. Product properties represent additional information for a product, independent of the imported products and tags.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_product_properties_v3_with_http_info(contract_id, product_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param int product_id: ID of the product (Omnia's internal product id) (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(GetProductPropertiesV3ApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'product_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_product_properties_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_product_properties_v3`")  # noqa: E501
        # verify the required parameter 'product_id' is set
        if self.api_client.client_side_validation and ('product_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['product_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `product_id` when calling `get_product_properties_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'product_id' in local_var_params:
            path_params['productId'] = local_var_params['product_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/vendor/contracts/{contractId}/products/{productId}/properties', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetProductPropertiesV3ApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_product_property_keys_v3(self, contract_id, **kwargs):  # noqa: E501
        """Get all product properties keys  # noqa: E501

        This endpoint returns a list of distinct product property keys for all imported products of a contract.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_product_property_keys_v3(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: StringArrayResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_product_property_keys_v3_with_http_info(contract_id, **kwargs)  # noqa: E501

    def get_product_property_keys_v3_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Get all product properties keys  # noqa: E501

        This endpoint returns a list of distinct product property keys for all imported products of a contract.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_product_property_keys_v3_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(StringArrayResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_product_property_keys_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_product_property_keys_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/vendor/contracts/{contractId}/products/properties/keys', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StringArrayResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_repricing_strategy_vendor_v2(self, contract_id, **kwargs):  # noqa: E501
        """Get repricing strategy  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_repricing_strategy_vendor_v2(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param int document_version:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_repricing_strategy_vendor_v2_with_http_info(contract_id, **kwargs)  # noqa: E501

    def get_repricing_strategy_vendor_v2_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Get repricing strategy  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_repricing_strategy_vendor_v2_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param int document_version:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'document_version'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_repricing_strategy_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_repricing_strategy_vendor_v2`")  # noqa: E501

        if self.api_client.client_side_validation and 'document_version' in local_var_params and local_var_params['document_version'] < 1:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `document_version` when calling `get_repricing_strategy_vendor_v2`, must be a value greater than or equal to `1`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []
        if 'document_version' in local_var_params and local_var_params['document_version'] is not None:  # noqa: E501
            query_params.append(('documentVersion', local_var_params['document_version']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/settings/repricingstrategy', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_scenario_by_id(self, contract_id, scenario_id, **kwargs):  # noqa: E501
        """Get scenario strategy  # noqa: E501

        Get a scenario strategy with the provided scenario id.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_scenario_by_id(contract_id, scenario_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param int scenario_id: ID of the required scenario strategy (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ScenarioStrategyResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_scenario_by_id_with_http_info(contract_id, scenario_id, **kwargs)  # noqa: E501

    def get_scenario_by_id_with_http_info(self, contract_id, scenario_id, **kwargs):  # noqa: E501
        """Get scenario strategy  # noqa: E501

        Get a scenario strategy with the provided scenario id.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_scenario_by_id_with_http_info(contract_id, scenario_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param int scenario_id: ID of the required scenario strategy (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ScenarioStrategyResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'scenario_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_scenario_by_id" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_scenario_by_id`")  # noqa: E501
        # verify the required parameter 'scenario_id' is set
        if self.api_client.client_side_validation and ('scenario_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['scenario_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `scenario_id` when calling `get_scenario_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'scenario_id' in local_var_params:
            path_params['scenarioId'] = local_var_params['scenario_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/vendor/contracts/{contractId}/settings/pricingstrategies/scenarios/{scenarioId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ScenarioStrategyResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_settings(self, contract_id, **kwargs):  # noqa: E501
        """Get settings for contract  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_settings(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ComPatagonaPricemonitorShareApiGetContractSettingsResponseV1
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_settings_with_http_info(contract_id, **kwargs)  # noqa: E501

    def get_settings_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Get settings for contract  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_settings_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ComPatagonaPricemonitorShareApiGetContractSettingsResponseV1, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_settings" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_settings`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/1/{contractId}/settings', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ComPatagonaPricemonitorShareApiGetContractSettingsResponseV1',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_tag_values_manufacturer_v2(self, contract_id, key, **kwargs):  # noqa: E501
        """Get product tag values [manufacturer]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_tag_values_manufacturer_v2(contract_id, key, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str key: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_tag_values_manufacturer_v2_with_http_info(contract_id, key, **kwargs)  # noqa: E501

    def get_tag_values_manufacturer_v2_with_http_info(self, contract_id, key, **kwargs):  # noqa: E501
        """Get product tag values [manufacturer]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_tag_values_manufacturer_v2_with_http_info(contract_id, key, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str key: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'key'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_tag_values_manufacturer_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_tag_values_manufacturer_v2`")  # noqa: E501
        # verify the required parameter 'key' is set
        if self.api_client.client_side_validation and ('key' not in local_var_params or  # noqa: E501
                                                        local_var_params['key'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `key` when calling `get_tag_values_manufacturer_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'key' in local_var_params:
            path_params['key'] = local_var_params['key']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/m/contracts/{contractId}/products/tags/{key}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_tag_values_vendor_v2(self, contract_id, key, **kwargs):  # noqa: E501
        """Get tag values for key  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_tag_values_vendor_v2(contract_id, key, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str key: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_tag_values_vendor_v2_with_http_info(contract_id, key, **kwargs)  # noqa: E501

    def get_tag_values_vendor_v2_with_http_info(self, contract_id, key, **kwargs):  # noqa: E501
        """Get tag values for key  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_tag_values_vendor_v2_with_http_info(contract_id, key, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str key: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'key'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_tag_values_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_tag_values_vendor_v2`")  # noqa: E501
        # verify the required parameter 'key' is set
        if self.api_client.client_side_validation and ('key' not in local_var_params or  # noqa: E501
                                                        local_var_params['key'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `key` when calling `get_tag_values_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'key' in local_var_params:
            path_params['key'] = local_var_params['key']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/products/tags/{key}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_tags_manufacturer_v2(self, contract_id, **kwargs):  # noqa: E501
        """Get product tags [manufacturer]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_tags_manufacturer_v2(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_tags_manufacturer_v2_with_http_info(contract_id, **kwargs)  # noqa: E501

    def get_tags_manufacturer_v2_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Get product tags [manufacturer]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_tags_manufacturer_v2_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_tags_manufacturer_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_tags_manufacturer_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/m/contracts/{contractId}/products/tags', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_tags_vendor_v2(self, contract_id, **kwargs):  # noqa: E501
        """Get product tags [vendor]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_tags_vendor_v2(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_tags_vendor_v2_with_http_info(contract_id, **kwargs)  # noqa: E501

    def get_tags_vendor_v2_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Get product tags [vendor]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_tags_vendor_v2_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_tags_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_tags_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/products/tags', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_task(self, contract_id, task_id, **kwargs):  # noqa: E501
        """Get task  # noqa: E501

        Get a task by id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_task(contract_id, task_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str task_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_task_with_http_info(contract_id, task_id, **kwargs)  # noqa: E501

    def get_task_with_http_info(self, contract_id, task_id, **kwargs):  # noqa: E501
        """Get task  # noqa: E501

        Get a task by id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_task_with_http_info(contract_id, task_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str task_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'task_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_task" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_task`")  # noqa: E501
        # verify the required parameter 'task_id' is set
        if self.api_client.client_side_validation and ('task_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['task_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `task_id` when calling `get_task`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'task_id' in local_var_params:
            path_params['taskId'] = local_var_params['task_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/1/{contractId}/tasks/{taskId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_task_data_manufacturer_v2(self, contract_id, task_id, **kwargs):  # noqa: E501
        """Get task data [manufacturer]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_task_data_manufacturer_v2(contract_id, task_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str task_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_task_data_manufacturer_v2_with_http_info(contract_id, task_id, **kwargs)  # noqa: E501

    def get_task_data_manufacturer_v2_with_http_info(self, contract_id, task_id, **kwargs):  # noqa: E501
        """Get task data [manufacturer]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_task_data_manufacturer_v2_with_http_info(contract_id, task_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str task_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'task_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_task_data_manufacturer_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_task_data_manufacturer_v2`")  # noqa: E501
        # verify the required parameter 'task_id' is set
        if self.api_client.client_side_validation and ('task_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['task_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `task_id` when calling `get_task_data_manufacturer_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'task_id' in local_var_params:
            path_params['taskId'] = local_var_params['task_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/m/contracts/{contractId}/tasks/{taskId}/data', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_task_data_vendor_v2(self, contract_id, task_id, **kwargs):  # noqa: E501
        """Get task data [vendor]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_task_data_vendor_v2(contract_id, task_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str task_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_task_data_vendor_v2_with_http_info(contract_id, task_id, **kwargs)  # noqa: E501

    def get_task_data_vendor_v2_with_http_info(self, contract_id, task_id, **kwargs):  # noqa: E501
        """Get task data [vendor]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_task_data_vendor_v2_with_http_info(contract_id, task_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str task_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'task_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_task_data_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_task_data_vendor_v2`")  # noqa: E501
        # verify the required parameter 'task_id' is set
        if self.api_client.client_side_validation and ('task_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['task_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `task_id` when calling `get_task_data_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'task_id' in local_var_params:
            path_params['taskId'] = local_var_params['task_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/tasks/{taskId}/data', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_task_manufacturer_v2(self, contract_id, task_id, **kwargs):  # noqa: E501
        """Get task [manufacturer]  # noqa: E501

        Get the task with the specified id.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_task_manufacturer_v2(contract_id, task_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str task_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: GenericTask
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_task_manufacturer_v2_with_http_info(contract_id, task_id, **kwargs)  # noqa: E501

    def get_task_manufacturer_v2_with_http_info(self, contract_id, task_id, **kwargs):  # noqa: E501
        """Get task [manufacturer]  # noqa: E501

        Get the task with the specified id.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_task_manufacturer_v2_with_http_info(contract_id, task_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str task_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(GenericTask, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'task_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_task_manufacturer_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_task_manufacturer_v2`")  # noqa: E501
        # verify the required parameter 'task_id' is set
        if self.api_client.client_side_validation and ('task_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['task_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `task_id` when calling `get_task_manufacturer_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'task_id' in local_var_params:
            path_params['taskId'] = local_var_params['task_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/m/contracts/{contractId}/tasks/{taskId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GenericTask',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_task_state(self, contract_id, task_id, **kwargs):  # noqa: E501
        """Get task state  # noqa: E501

        Gets the state of a task.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_task_state(contract_id, task_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str task_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_task_state_with_http_info(contract_id, task_id, **kwargs)  # noqa: E501

    def get_task_state_with_http_info(self, contract_id, task_id, **kwargs):  # noqa: E501
        """Get task state  # noqa: E501

        Gets the state of a task.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_task_state_with_http_info(contract_id, task_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str task_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'task_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_task_state" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_task_state`")  # noqa: E501
        # verify the required parameter 'task_id' is set
        if self.api_client.client_side_validation and ('task_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['task_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `task_id` when calling `get_task_state`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'task_id' in local_var_params:
            path_params['taskId'] = local_var_params['task_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/1/{contractId}/tasks/{taskId}/state', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_tasks(self, contract_id, tasks, attributes, limit, **kwargs):  # noqa: E501
        """Get tasks  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_tasks(contract_id, tasks, attributes, limit, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str tasks: (required)
        :param str attributes: (required)
        :param int limit: (required)
        :param str task_type:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_tasks_with_http_info(contract_id, tasks, attributes, limit, **kwargs)  # noqa: E501

    def get_tasks_with_http_info(self, contract_id, tasks, attributes, limit, **kwargs):  # noqa: E501
        """Get tasks  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_tasks_with_http_info(contract_id, tasks, attributes, limit, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str tasks: (required)
        :param str attributes: (required)
        :param int limit: (required)
        :param str task_type:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'tasks',
            'attributes',
            'limit',
            'task_type'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_tasks" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_tasks`")  # noqa: E501
        # verify the required parameter 'tasks' is set
        if self.api_client.client_side_validation and ('tasks' not in local_var_params or  # noqa: E501
                                                        local_var_params['tasks'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `tasks` when calling `get_tasks`")  # noqa: E501
        # verify the required parameter 'attributes' is set
        if self.api_client.client_side_validation and ('attributes' not in local_var_params or  # noqa: E501
                                                        local_var_params['attributes'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `attributes` when calling `get_tasks`")  # noqa: E501
        # verify the required parameter 'limit' is set
        if self.api_client.client_side_validation and ('limit' not in local_var_params or  # noqa: E501
                                                        local_var_params['limit'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `limit` when calling `get_tasks`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []
        if 'tasks' in local_var_params and local_var_params['tasks'] is not None:  # noqa: E501
            query_params.append(('tasks', local_var_params['tasks']))  # noqa: E501
        if 'attributes' in local_var_params and local_var_params['attributes'] is not None:  # noqa: E501
            query_params.append(('attributes', local_var_params['attributes']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'task_type' in local_var_params and local_var_params['task_type'] is not None:  # noqa: E501
            query_params.append(('taskType', local_var_params['task_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/1/{contractId}/tasks', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_tasks_manufacturer_v2(self, contract_id, task_type_filter, task_state, limit, include_failures, **kwargs):  # noqa: E501
        """Find tasks for contract [manufactuerer]  # noqa: E501

        Returns a list of task objects for the given contract  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_tasks_manufacturer_v2(contract_id, task_type_filter, task_state, limit, include_failures, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param list[str] task_type_filter: A list of task types to filter for (required)
        :param list[str] task_state: A list of task states to filter for (required)
        :param int limit: The maximum number of tasks returned (required)
        :param bool include_failures: Include failed tasks (required)
        :param str task_ids_filter: Comma separated list of task IDs to filter for
        :param datetime min_creation_date: Ignore all tasks created earlier than this date (ISO 8601)
        :param datetime max_creation_date: Ignore all tasks created later than this date (ISO 8601)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: list[GenericTask]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_tasks_manufacturer_v2_with_http_info(contract_id, task_type_filter, task_state, limit, include_failures, **kwargs)  # noqa: E501

    def get_tasks_manufacturer_v2_with_http_info(self, contract_id, task_type_filter, task_state, limit, include_failures, **kwargs):  # noqa: E501
        """Find tasks for contract [manufactuerer]  # noqa: E501

        Returns a list of task objects for the given contract  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_tasks_manufacturer_v2_with_http_info(contract_id, task_type_filter, task_state, limit, include_failures, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param list[str] task_type_filter: A list of task types to filter for (required)
        :param list[str] task_state: A list of task states to filter for (required)
        :param int limit: The maximum number of tasks returned (required)
        :param bool include_failures: Include failed tasks (required)
        :param str task_ids_filter: Comma separated list of task IDs to filter for
        :param datetime min_creation_date: Ignore all tasks created earlier than this date (ISO 8601)
        :param datetime max_creation_date: Ignore all tasks created later than this date (ISO 8601)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(list[GenericTask], status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'task_type_filter',
            'task_state',
            'limit',
            'include_failures',
            'task_ids_filter',
            'min_creation_date',
            'max_creation_date'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_tasks_manufacturer_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_tasks_manufacturer_v2`")  # noqa: E501
        # verify the required parameter 'task_type_filter' is set
        if self.api_client.client_side_validation and ('task_type_filter' not in local_var_params or  # noqa: E501
                                                        local_var_params['task_type_filter'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `task_type_filter` when calling `get_tasks_manufacturer_v2`")  # noqa: E501
        # verify the required parameter 'task_state' is set
        if self.api_client.client_side_validation and ('task_state' not in local_var_params or  # noqa: E501
                                                        local_var_params['task_state'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `task_state` when calling `get_tasks_manufacturer_v2`")  # noqa: E501
        # verify the required parameter 'limit' is set
        if self.api_client.client_side_validation and ('limit' not in local_var_params or  # noqa: E501
                                                        local_var_params['limit'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `limit` when calling `get_tasks_manufacturer_v2`")  # noqa: E501
        # verify the required parameter 'include_failures' is set
        if self.api_client.client_side_validation and ('include_failures' not in local_var_params or  # noqa: E501
                                                        local_var_params['include_failures'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `include_failures` when calling `get_tasks_manufacturer_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []
        if 'task_ids_filter' in local_var_params and local_var_params['task_ids_filter'] is not None:  # noqa: E501
            query_params.append(('taskIdsFilter', local_var_params['task_ids_filter']))  # noqa: E501
        if 'task_type_filter' in local_var_params and local_var_params['task_type_filter'] is not None:  # noqa: E501
            query_params.append(('taskTypeFilter', local_var_params['task_type_filter']))  # noqa: E501
            collection_formats['taskTypeFilter'] = 'multi'  # noqa: E501
        if 'task_state' in local_var_params and local_var_params['task_state'] is not None:  # noqa: E501
            query_params.append(('taskState', local_var_params['task_state']))  # noqa: E501
            collection_formats['taskState'] = 'multi'  # noqa: E501
        if 'min_creation_date' in local_var_params and local_var_params['min_creation_date'] is not None:  # noqa: E501
            query_params.append(('minCreationDate', local_var_params['min_creation_date']))  # noqa: E501
        if 'max_creation_date' in local_var_params and local_var_params['max_creation_date'] is not None:  # noqa: E501
            query_params.append(('maxCreationDate', local_var_params['max_creation_date']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'include_failures' in local_var_params and local_var_params['include_failures'] is not None:  # noqa: E501
            query_params.append(('includeFailures', local_var_params['include_failures']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/m/contracts/{contractId}/tasks', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[GenericTask]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_tasks_stats(self, since_seconds, **kwargs):  # noqa: E501
        """Get all task stats  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_tasks_stats(since_seconds, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int since_seconds: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_tasks_stats_with_http_info(since_seconds, **kwargs)  # noqa: E501

    def get_tasks_stats_with_http_info(self, since_seconds, **kwargs):  # noqa: E501
        """Get all task stats  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_tasks_stats_with_http_info(since_seconds, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int since_seconds: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'since_seconds'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_tasks_stats" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'since_seconds' is set
        if self.api_client.client_side_validation and ('since_seconds' not in local_var_params or  # noqa: E501
                                                        local_var_params['since_seconds'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `since_seconds` when calling `get_tasks_stats`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'since_seconds' in local_var_params and local_var_params['since_seconds'] is not None:  # noqa: E501
            query_params.append(('sinceSeconds', local_var_params['since_seconds']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/controlpanel/api/tasks/stats', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_time_stamps(self, contract_id, **kwargs):  # noqa: E501
        """Get time stamps  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_time_stamps(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int contract_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_time_stamps_with_http_info(contract_id, **kwargs)  # noqa: E501

    def get_time_stamps_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Get time stamps  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_time_stamps_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int contract_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_time_stamps" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_time_stamps`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/1/{contractId}/products/analysis/timestamps', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_user(self, email, **kwargs):  # noqa: E501
        """Get user  # noqa: E501

        Get the user with the specified email address.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_user(email, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str email: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_user_with_http_info(email, **kwargs)  # noqa: E501

    def get_user_with_http_info(self, email, **kwargs):  # noqa: E501
        """Get user  # noqa: E501

        Get the user with the specified email address.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_user_with_http_info(email, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str email: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'email'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_user" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'email' is set
        if self.api_client.client_side_validation and ('email' not in local_var_params or  # noqa: E501
                                                        local_var_params['email'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `email` when calling `get_user`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'email' in local_var_params:
            path_params['email'] = local_var_params['email']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/controlpanel/api/users/{email}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_user_access_to_contracts_of_company_v3(self, company_id, **kwargs):  # noqa: E501
        """Get contract access of users  # noqa: E501

        Get which user can access which contract of the company.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_user_access_to_contracts_of_company_v3(company_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int company_id: ID of a company (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: GetUserAccessToContractsOfCompanyV3ApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_user_access_to_contracts_of_company_v3_with_http_info(company_id, **kwargs)  # noqa: E501

    def get_user_access_to_contracts_of_company_v3_with_http_info(self, company_id, **kwargs):  # noqa: E501
        """Get contract access of users  # noqa: E501

        Get which user can access which contract of the company.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_user_access_to_contracts_of_company_v3_with_http_info(company_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int company_id: ID of a company (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(GetUserAccessToContractsOfCompanyV3ApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'company_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_user_access_to_contracts_of_company_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'company_id' is set
        if self.api_client.client_side_validation and ('company_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['company_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `company_id` when calling `get_user_access_to_contracts_of_company_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'company_id' in local_var_params:
            path_params['companyId'] = local_var_params['company_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/companies/{companyId}/users/contractaccess', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetUserAccessToContractsOfCompanyV3ApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_users(self, company_id, **kwargs):  # noqa: E501
        """Get all users of a company  # noqa: E501

        This endpoint returns all users that are assigned to a company. It is only accessible for admins or company admins.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_users(company_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int company_id: ID of a company (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: list[ComPatagonaPricemonitorShareApiGetCompanyUsersUser]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_users_with_http_info(company_id, **kwargs)  # noqa: E501

    def get_users_with_http_info(self, company_id, **kwargs):  # noqa: E501
        """Get all users of a company  # noqa: E501

        This endpoint returns all users that are assigned to a company. It is only accessible for admins or company admins.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_users_with_http_info(company_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int company_id: ID of a company (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(list[ComPatagonaPricemonitorShareApiGetCompanyUsersUser], status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'company_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_users" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'company_id' is set
        if self.api_client.client_side_validation and ('company_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['company_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `company_id` when calling `get_users`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'company_id' in local_var_params:
            path_params['companyId'] = local_var_params['company_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/controlpanel/api/companies/{companyId}/users', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ComPatagonaPricemonitorShareApiGetCompanyUsersUser]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_vendor_settings_v2_vendor_v2(self, contract_id, **kwargs):  # noqa: E501
        """Get repricing settings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_vendor_settings_v2_vendor_v2(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_vendor_settings_v2_vendor_v2_with_http_info(contract_id, **kwargs)  # noqa: E501

    def get_vendor_settings_v2_vendor_v2_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Get repricing settings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_vendor_settings_v2_vendor_v2_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_vendor_settings_v2_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_vendor_settings_v2_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/settings/repricing', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_vendor_shop_mapping_manufacturer_v3(self, contract_id, vendor_id, **kwargs):  # noqa: E501
        """Get vendor and shops for contract  # noqa: E501

        Get vendor along with their associated shop for given vendor id and manufacturer contract.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_vendor_shop_mapping_manufacturer_v3(contract_id, vendor_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param int vendor_id: ID of vendor shop mapping (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: VendorShopMappingV3ApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_vendor_shop_mapping_manufacturer_v3_with_http_info(contract_id, vendor_id, **kwargs)  # noqa: E501

    def get_vendor_shop_mapping_manufacturer_v3_with_http_info(self, contract_id, vendor_id, **kwargs):  # noqa: E501
        """Get vendor and shops for contract  # noqa: E501

        Get vendor along with their associated shop for given vendor id and manufacturer contract.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_vendor_shop_mapping_manufacturer_v3_with_http_info(contract_id, vendor_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param int vendor_id: ID of vendor shop mapping (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(VendorShopMappingV3ApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'vendor_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_vendor_shop_mapping_manufacturer_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_vendor_shop_mapping_manufacturer_v3`")  # noqa: E501
        # verify the required parameter 'vendor_id' is set
        if self.api_client.client_side_validation and ('vendor_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['vendor_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `vendor_id` when calling `get_vendor_shop_mapping_manufacturer_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'vendor_id' in local_var_params:
            path_params['vendorId'] = local_var_params['vendor_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/manufacturer/contracts/{contractId}/vendors/{vendorId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='VendorShopMappingV3ApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_vendor_shop_mappings_manufacturer_v3(self, contract_id, **kwargs):  # noqa: E501
        """Get all vendors and shops for contract  # noqa: E501

        Get all the vendors along with their associated shops for a specified manufacturer contract.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_vendor_shop_mappings_manufacturer_v3(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: GetVendorShopMappingsApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_vendor_shop_mappings_manufacturer_v3_with_http_info(contract_id, **kwargs)  # noqa: E501

    def get_vendor_shop_mappings_manufacturer_v3_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Get all vendors and shops for contract  # noqa: E501

        Get all the vendors along with their associated shops for a specified manufacturer contract.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_vendor_shop_mappings_manufacturer_v3_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(GetVendorShopMappingsApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_vendor_shop_mappings_manufacturer_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_vendor_shop_mappings_manufacturer_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/manufacturer/contracts/{contractId}/vendors', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetVendorShopMappingsApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_vendor_v3(self, contract_id, **kwargs):  # noqa: E501
        """Get contract [vendor]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_vendor_v3(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_vendor_v3_with_http_info(contract_id, **kwargs)  # noqa: E501

    def get_vendor_v3_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Get contract [vendor]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_vendor_v3_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_vendor_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_vendor_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/vendor/contracts/{contractId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_vendor_vendor_v2(self, contract_id, **kwargs):  # noqa: E501
        """Get contract [vendor]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_vendor_vendor_v2(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_vendor_vendor_v2_with_http_info(contract_id, **kwargs)  # noqa: E501

    def get_vendor_vendor_v2_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Get contract [vendor]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_vendor_vendor_v2_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_vendor_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_vendor_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_vendors_by_domain_manufacturer_v2(self, contract_id, domain, start, include_delivery_costs, session, **kwargs):  # noqa: E501
        """Get vendors by domain  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_vendors_by_domain_manufacturer_v2(contract_id, domain, start, include_delivery_costs, session, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str domain: (required)
        :param int start: (required)
        :param bool include_delivery_costs: (required)
        :param datetime session: (required)
        :param ComPatagonaPricemonitorShareApiTagFilteredVendorsRequest com_patagona_pricemonitor_share_api_tag_filtered_vendors_request: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ComPatagonaPricemonitorShareApiPostVendorsByDomainResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_vendors_by_domain_manufacturer_v2_with_http_info(contract_id, domain, start, include_delivery_costs, session, **kwargs)  # noqa: E501

    def get_vendors_by_domain_manufacturer_v2_with_http_info(self, contract_id, domain, start, include_delivery_costs, session, **kwargs):  # noqa: E501
        """Get vendors by domain  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_vendors_by_domain_manufacturer_v2_with_http_info(contract_id, domain, start, include_delivery_costs, session, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str domain: (required)
        :param int start: (required)
        :param bool include_delivery_costs: (required)
        :param datetime session: (required)
        :param ComPatagonaPricemonitorShareApiTagFilteredVendorsRequest com_patagona_pricemonitor_share_api_tag_filtered_vendors_request: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ComPatagonaPricemonitorShareApiPostVendorsByDomainResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'domain',
            'start',
            'include_delivery_costs',
            'session',
            'com_patagona_pricemonitor_share_api_tag_filtered_vendors_request'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_vendors_by_domain_manufacturer_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_vendors_by_domain_manufacturer_v2`")  # noqa: E501
        # verify the required parameter 'domain' is set
        if self.api_client.client_side_validation and ('domain' not in local_var_params or  # noqa: E501
                                                        local_var_params['domain'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `domain` when calling `get_vendors_by_domain_manufacturer_v2`")  # noqa: E501
        # verify the required parameter 'start' is set
        if self.api_client.client_side_validation and ('start' not in local_var_params or  # noqa: E501
                                                        local_var_params['start'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `start` when calling `get_vendors_by_domain_manufacturer_v2`")  # noqa: E501
        # verify the required parameter 'include_delivery_costs' is set
        if self.api_client.client_side_validation and ('include_delivery_costs' not in local_var_params or  # noqa: E501
                                                        local_var_params['include_delivery_costs'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `include_delivery_costs` when calling `get_vendors_by_domain_manufacturer_v2`")  # noqa: E501
        # verify the required parameter 'session' is set
        if self.api_client.client_side_validation and ('session' not in local_var_params or  # noqa: E501
                                                        local_var_params['session'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `session` when calling `get_vendors_by_domain_manufacturer_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []
        if 'domain' in local_var_params and local_var_params['domain'] is not None:  # noqa: E501
            query_params.append(('domain', local_var_params['domain']))  # noqa: E501
        if 'start' in local_var_params and local_var_params['start'] is not None:  # noqa: E501
            query_params.append(('start', local_var_params['start']))  # noqa: E501
        if 'include_delivery_costs' in local_var_params and local_var_params['include_delivery_costs'] is not None:  # noqa: E501
            query_params.append(('includeDeliveryCosts', local_var_params['include_delivery_costs']))  # noqa: E501
        if 'session' in local_var_params and local_var_params['session'] is not None:  # noqa: E501
            query_params.append(('session', local_var_params['session']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'com_patagona_pricemonitor_share_api_tag_filtered_vendors_request' in local_var_params:
            body_params = local_var_params['com_patagona_pricemonitor_share_api_tag_filtered_vendors_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/m/contracts/{contractId}/result/vendors/list', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ComPatagonaPricemonitorShareApiPostVendorsByDomainResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_vendors(self, name_filter, **kwargs):  # noqa: E501
        """Get list of vendors  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_vendors(name_filter, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str name_filter: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_vendors_with_http_info(name_filter, **kwargs)  # noqa: E501

    def list_vendors_with_http_info(self, name_filter, **kwargs):  # noqa: E501
        """Get list of vendors  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_vendors_with_http_info(name_filter, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str name_filter: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'name_filter'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_vendors" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'name_filter' is set
        if self.api_client.client_side_validation and ('name_filter' not in local_var_params or  # noqa: E501
                                                        local_var_params['name_filter'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `name_filter` when calling `list_vendors`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'name_filter' in local_var_params and local_var_params['name_filter'] is not None:  # noqa: E501
            query_params.append(('nameFilter', local_var_params['name_filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/controlpanel/vendors', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def login_by_auth_token(self, token, **kwargs):  # noqa: E501
        """Log in with authentication token  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.login_by_auth_token(token, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str token: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.login_by_auth_token_with_http_info(token, **kwargs)  # noqa: E501

    def login_by_auth_token_with_http_info(self, token, **kwargs):  # noqa: E501
        """Log in with authentication token  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.login_by_auth_token_with_http_info(token, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str token: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'token'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method login_by_auth_token" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'token' is set
        if self.api_client.client_side_validation and ('token' not in local_var_params or  # noqa: E501
                                                        local_var_params['token'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `token` when calling `login_by_auth_token`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'token' in local_var_params:
            path_params['token'] = local_var_params['token']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/login/token/{token}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def logout(self, **kwargs):  # noqa: E501
        """Log out  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.logout(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.logout_with_http_info(**kwargs)  # noqa: E501

    def logout_with_http_info(self, **kwargs):  # noqa: E501
        """Log out  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.logout_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method logout" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/logout', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def monitoring_pipeline_post_request_manufacturer_v3(self, contract_id, path, **kwargs):  # noqa: E501
        """Update monitoring pipeline [manufacturer]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.monitoring_pipeline_post_request_manufacturer_v3(contract_id, path, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str path: The monitoring-pipeline path to be called (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.monitoring_pipeline_post_request_manufacturer_v3_with_http_info(contract_id, path, **kwargs)  # noqa: E501

    def monitoring_pipeline_post_request_manufacturer_v3_with_http_info(self, contract_id, path, **kwargs):  # noqa: E501
        """Update monitoring pipeline [manufacturer]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.monitoring_pipeline_post_request_manufacturer_v3_with_http_info(contract_id, path, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str path: The monitoring-pipeline path to be called (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'path'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method monitoring_pipeline_post_request_manufacturer_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `monitoring_pipeline_post_request_manufacturer_v3`")  # noqa: E501
        # verify the required parameter 'path' is set
        if self.api_client.client_side_validation and ('path' not in local_var_params or  # noqa: E501
                                                        local_var_params['path'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `path` when calling `monitoring_pipeline_post_request_manufacturer_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'path' in local_var_params:
            path_params['path'] = local_var_params['path']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/manufacturer/contracts/{contractId}/monitoringpipeline/{path}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def monitoring_pipeline_post_request_vendor_v3(self, contract_id, path, **kwargs):  # noqa: E501
        """Update monitoring pipeline [vendor]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.monitoring_pipeline_post_request_vendor_v3(contract_id, path, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str path: The monitoring-pipeline path to be called (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.monitoring_pipeline_post_request_vendor_v3_with_http_info(contract_id, path, **kwargs)  # noqa: E501

    def monitoring_pipeline_post_request_vendor_v3_with_http_info(self, contract_id, path, **kwargs):  # noqa: E501
        """Update monitoring pipeline [vendor]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.monitoring_pipeline_post_request_vendor_v3_with_http_info(contract_id, path, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str path: The monitoring-pipeline path to be called (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'path'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method monitoring_pipeline_post_request_vendor_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `monitoring_pipeline_post_request_vendor_v3`")  # noqa: E501
        # verify the required parameter 'path' is set
        if self.api_client.client_side_validation and ('path' not in local_var_params or  # noqa: E501
                                                        local_var_params['path'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `path` when calling `monitoring_pipeline_post_request_vendor_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'path' in local_var_params:
            path_params['path'] = local_var_params['path']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/vendor/contracts/{contractId}/monitoringpipeline/{path}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def monitoring_pipeline_upsert_search_attempts_manufacturer_v3(self, contract_id, **kwargs):  # noqa: E501
        """Update monitoring pipeline search attempts [manufacturer]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.monitoring_pipeline_upsert_search_attempts_manufacturer_v3(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.monitoring_pipeline_upsert_search_attempts_manufacturer_v3_with_http_info(contract_id, **kwargs)  # noqa: E501

    def monitoring_pipeline_upsert_search_attempts_manufacturer_v3_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Update monitoring pipeline search attempts [manufacturer]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.monitoring_pipeline_upsert_search_attempts_manufacturer_v3_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method monitoring_pipeline_upsert_search_attempts_manufacturer_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `monitoring_pipeline_upsert_search_attempts_manufacturer_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/manufacturer/contracts/{contractId}/monitoringpipeline/v1/searchattempts', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def monitoring_pipeline_upsert_search_attempts_vendor_v3(self, contract_id, **kwargs):  # noqa: E501
        """Update monitoring pipeline search attempts [vendor]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.monitoring_pipeline_upsert_search_attempts_vendor_v3(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.monitoring_pipeline_upsert_search_attempts_vendor_v3_with_http_info(contract_id, **kwargs)  # noqa: E501

    def monitoring_pipeline_upsert_search_attempts_vendor_v3_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Update monitoring pipeline search attempts [vendor]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.monitoring_pipeline_upsert_search_attempts_vendor_v3_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method monitoring_pipeline_upsert_search_attempts_vendor_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `monitoring_pipeline_upsert_search_attempts_vendor_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/vendor/contracts/{contractId}/monitoringpipeline/v1/searchattempts', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_product_manufacturer_v3(self, contract_id, product_id, **kwargs):  # noqa: E501
        """Update product [manufacturer]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_product_manufacturer_v3(contract_id, product_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str product_id: (required)
        :param object body: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.patch_product_manufacturer_v3_with_http_info(contract_id, product_id, **kwargs)  # noqa: E501

    def patch_product_manufacturer_v3_with_http_info(self, contract_id, product_id, **kwargs):  # noqa: E501
        """Update product [manufacturer]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_product_manufacturer_v3_with_http_info(contract_id, product_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str product_id: (required)
        :param object body: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'product_id',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_product_manufacturer_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `patch_product_manufacturer_v3`")  # noqa: E501
        # verify the required parameter 'product_id' is set
        if self.api_client.client_side_validation and ('product_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['product_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `product_id` when calling `patch_product_manufacturer_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'product_id' in local_var_params:
            path_params['productId'] = local_var_params['product_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/manufacturer/contracts/{contractId}/products/{productId}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_product_vendor_v3(self, contract_id, product_id, **kwargs):  # noqa: E501
        """Update product [vendor]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_product_vendor_v3(contract_id, product_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str product_id: (required)
        :param object body: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.patch_product_vendor_v3_with_http_info(contract_id, product_id, **kwargs)  # noqa: E501

    def patch_product_vendor_v3_with_http_info(self, contract_id, product_id, **kwargs):  # noqa: E501
        """Update product [vendor]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_product_vendor_v3_with_http_info(contract_id, product_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str product_id: (required)
        :param object body: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'product_id',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_product_vendor_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `patch_product_vendor_v3`")  # noqa: E501
        # verify the required parameter 'product_id' is set
        if self.api_client.client_side_validation and ('product_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['product_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `product_id` when calling `patch_product_vendor_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'product_id' in local_var_params:
            path_params['productId'] = local_var_params['product_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/vendor/contracts/{contractId}/products/{productId}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def position_distribution(self, contract_id, vendor, day, **kwargs):  # noqa: E501
        """Update position distribution  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.position_distribution(contract_id, vendor, day, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str vendor: (required)
        :param datetime day: (required)
        :param object body: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.position_distribution_with_http_info(contract_id, vendor, day, **kwargs)  # noqa: E501

    def position_distribution_with_http_info(self, contract_id, vendor, day, **kwargs):  # noqa: E501
        """Update position distribution  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.position_distribution_with_http_info(contract_id, vendor, day, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str vendor: (required)
        :param datetime day: (required)
        :param object body: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'vendor',
            'day',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method position_distribution" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `position_distribution`")  # noqa: E501
        # verify the required parameter 'vendor' is set
        if self.api_client.client_side_validation and ('vendor' not in local_var_params or  # noqa: E501
                                                        local_var_params['vendor'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `vendor` when calling `position_distribution`")  # noqa: E501
        # verify the required parameter 'day' is set
        if self.api_client.client_side_validation and ('day' not in local_var_params or  # noqa: E501
                                                        local_var_params['day'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `day` when calling `position_distribution`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'vendor' in local_var_params:
            path_params['vendor'] = local_var_params['vendor']  # noqa: E501

        query_params = []
        if 'day' in local_var_params and local_var_params['day'] is not None:  # noqa: E501
            query_params.append(('day', local_var_params['day']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/1/{contractId}/vendors/{vendor}/positions', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_account_v3(self, **kwargs):  # noqa: E501
        """Create user account  # noqa: E501

        Create a new user account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_account_v3(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param ComPatagonaPricemonitorShareApiPostAccountRequestV3 com_patagona_pricemonitor_share_api_post_account_request_v3: Request body for creating a new user account. It must contain name, email and password.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: PostAccountResponseV3ApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.post_account_v3_with_http_info(**kwargs)  # noqa: E501

    def post_account_v3_with_http_info(self, **kwargs):  # noqa: E501
        """Create user account  # noqa: E501

        Create a new user account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_account_v3_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param ComPatagonaPricemonitorShareApiPostAccountRequestV3 com_patagona_pricemonitor_share_api_post_account_request_v3: Request body for creating a new user account. It must contain name, email and password.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(PostAccountResponseV3ApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'com_patagona_pricemonitor_share_api_post_account_request_v3'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_account_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'com_patagona_pricemonitor_share_api_post_account_request_v3' in local_var_params:
            body_params = local_var_params['com_patagona_pricemonitor_share_api_post_account_request_v3']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/account', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PostAccountResponseV3ApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_activate_marketplace_vendor_v3(self, company_id, **kwargs):  # noqa: E501
        """Activate Amazon marketplace  # noqa: E501

        Activate marketplace of a customer in our system. By activation, it means that our system can write prices back into the customer's Amazon shop.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_activate_marketplace_vendor_v3(company_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int company_id: ID of a company (required)
        :param ComPatagonaPricemonitorShareApiPostActivateMarketplaceRequestV3 com_patagona_pricemonitor_share_api_post_activate_marketplace_request_v3: Marketplace of a customer to be activated.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ActivateMarketplaceResponseV3ApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.post_activate_marketplace_vendor_v3_with_http_info(company_id, **kwargs)  # noqa: E501

    def post_activate_marketplace_vendor_v3_with_http_info(self, company_id, **kwargs):  # noqa: E501
        """Activate Amazon marketplace  # noqa: E501

        Activate marketplace of a customer in our system. By activation, it means that our system can write prices back into the customer's Amazon shop.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_activate_marketplace_vendor_v3_with_http_info(company_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int company_id: ID of a company (required)
        :param ComPatagonaPricemonitorShareApiPostActivateMarketplaceRequestV3 com_patagona_pricemonitor_share_api_post_activate_marketplace_request_v3: Marketplace of a customer to be activated.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ActivateMarketplaceResponseV3ApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'company_id',
            'com_patagona_pricemonitor_share_api_post_activate_marketplace_request_v3'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_activate_marketplace_vendor_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'company_id' is set
        if self.api_client.client_side_validation and ('company_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['company_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `company_id` when calling `post_activate_marketplace_vendor_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'company_id' in local_var_params:
            path_params['companyId'] = local_var_params['company_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'com_patagona_pricemonitor_share_api_post_activate_marketplace_request_v3' in local_var_params:
            body_params = local_var_params['com_patagona_pricemonitor_share_api_post_activate_marketplace_request_v3']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/companies/{companyId}/amazon/marketplace', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ActivateMarketplaceResponseV3ApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_authorize_seller_vendor_v3(self, company_id, **kwargs):  # noqa: E501
        """Set up authorization for Amazon seller account  # noqa: E501

        Set up an OAuth authorization for a customer's Amazon Seller Central account. It establishes a connection between our system and the customer's Amazon shop using the Amazon SP-API. Once connected, our system can write prices back to the customer's Amazon shop, allowing them to benefit from our price recommendations.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_authorize_seller_vendor_v3(company_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int company_id: ID of a company (required)
        :param ComPatagonaPricemonitorShareApiPostAuthorizeSellerRequestV3 com_patagona_pricemonitor_share_api_post_authorize_seller_request_v3: Customer's Amazon seller central account to be authorized.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: PostAuthorizeSellerResponseV3ApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.post_authorize_seller_vendor_v3_with_http_info(company_id, **kwargs)  # noqa: E501

    def post_authorize_seller_vendor_v3_with_http_info(self, company_id, **kwargs):  # noqa: E501
        """Set up authorization for Amazon seller account  # noqa: E501

        Set up an OAuth authorization for a customer's Amazon Seller Central account. It establishes a connection between our system and the customer's Amazon shop using the Amazon SP-API. Once connected, our system can write prices back to the customer's Amazon shop, allowing them to benefit from our price recommendations.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_authorize_seller_vendor_v3_with_http_info(company_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int company_id: ID of a company (required)
        :param ComPatagonaPricemonitorShareApiPostAuthorizeSellerRequestV3 com_patagona_pricemonitor_share_api_post_authorize_seller_request_v3: Customer's Amazon seller central account to be authorized.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(PostAuthorizeSellerResponseV3ApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'company_id',
            'com_patagona_pricemonitor_share_api_post_authorize_seller_request_v3'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_authorize_seller_vendor_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'company_id' is set
        if self.api_client.client_side_validation and ('company_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['company_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `company_id` when calling `post_authorize_seller_vendor_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'company_id' in local_var_params:
            path_params['companyId'] = local_var_params['company_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'com_patagona_pricemonitor_share_api_post_authorize_seller_request_v3' in local_var_params:
            body_params = local_var_params['com_patagona_pricemonitor_share_api_post_authorize_seller_request_v3']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/companies/{companyId}/amazon/authorization', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PostAuthorizeSellerResponseV3ApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_ebay_authorization_vendor_v2(self, contract_id, **kwargs):  # noqa: E501
        """Update Ebay authorization  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_ebay_authorization_vendor_v2(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.post_ebay_authorization_vendor_v2_with_http_info(contract_id, **kwargs)  # noqa: E501

    def post_ebay_authorization_vendor_v2_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Update Ebay authorization  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_ebay_authorization_vendor_v2_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_ebay_authorization_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `post_ebay_authorization_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/settings/ebay/authorizations', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_embed_sso_url_manufacturer(self, contract_id, **kwargs):  # noqa: E501
        """Retrieve Looker embed SSO url [manufacturer]  # noqa: E501

        Retrieve an embed SSO url for Looker for a manufacturer contract.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_embed_sso_url_manufacturer(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param ComPatagonaPricemonitorShareApiPostEmbedSSOUrlRequestV3 com_patagona_pricemonitor_share_api_post_embed_sso_url_request_v3: Payload for retrieving a signed embed SSO url using Looker API.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: EmbedSSOUrlResponseV3ApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.post_embed_sso_url_manufacturer_with_http_info(contract_id, **kwargs)  # noqa: E501

    def post_embed_sso_url_manufacturer_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Retrieve Looker embed SSO url [manufacturer]  # noqa: E501

        Retrieve an embed SSO url for Looker for a manufacturer contract.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_embed_sso_url_manufacturer_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param ComPatagonaPricemonitorShareApiPostEmbedSSOUrlRequestV3 com_patagona_pricemonitor_share_api_post_embed_sso_url_request_v3: Payload for retrieving a signed embed SSO url using Looker API.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(EmbedSSOUrlResponseV3ApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'com_patagona_pricemonitor_share_api_post_embed_sso_url_request_v3'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_embed_sso_url_manufacturer" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `post_embed_sso_url_manufacturer`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'com_patagona_pricemonitor_share_api_post_embed_sso_url_request_v3' in local_var_params:
            body_params = local_var_params['com_patagona_pricemonitor_share_api_post_embed_sso_url_request_v3']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/manufacturer/contracts/{contractId}/looker/sso/embed/url', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EmbedSSOUrlResponseV3ApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_embed_sso_url_vendor(self, contract_id, **kwargs):  # noqa: E501
        """Retrieve Looker embed SSO url [vendor]  # noqa: E501

        Retrieve an embed SSO url for Looker for a vendor contract.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_embed_sso_url_vendor(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param ComPatagonaPricemonitorShareApiPostEmbedSSOUrlRequestV3 com_patagona_pricemonitor_share_api_post_embed_sso_url_request_v3: Payload for retrieving a signed embed SSO url using Looker API.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: EmbedSSOUrlResponseV3ApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.post_embed_sso_url_vendor_with_http_info(contract_id, **kwargs)  # noqa: E501

    def post_embed_sso_url_vendor_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Retrieve Looker embed SSO url [vendor]  # noqa: E501

        Retrieve an embed SSO url for Looker for a vendor contract.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_embed_sso_url_vendor_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param ComPatagonaPricemonitorShareApiPostEmbedSSOUrlRequestV3 com_patagona_pricemonitor_share_api_post_embed_sso_url_request_v3: Payload for retrieving a signed embed SSO url using Looker API.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(EmbedSSOUrlResponseV3ApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'com_patagona_pricemonitor_share_api_post_embed_sso_url_request_v3'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_embed_sso_url_vendor" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `post_embed_sso_url_vendor`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'com_patagona_pricemonitor_share_api_post_embed_sso_url_request_v3' in local_var_params:
            body_params = local_var_params['com_patagona_pricemonitor_share_api_post_embed_sso_url_request_v3']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/vendor/contracts/{contractId}/looker/sso/embed/url', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EmbedSSOUrlResponseV3ApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_feed_vendor_v2(self, contract_id, **kwargs):  # noqa: E501
        """Create feed  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_feed_vendor_v2(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.post_feed_vendor_v2_with_http_info(contract_id, **kwargs)  # noqa: E501

    def post_feed_vendor_v2_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Create feed  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_feed_vendor_v2_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_feed_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `post_feed_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/feeds', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_mappings_vendor_v2(self, contract_id, **kwargs):  # noqa: E501
        """Update product identifier mapping  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_mappings_vendor_v2(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.post_mappings_vendor_v2_with_http_info(contract_id, **kwargs)  # noqa: E501

    def post_mappings_vendor_v2_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Update product identifier mapping  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_mappings_vendor_v2_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_mappings_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `post_mappings_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/productidentifiermapping', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_monitoring_schedule_manufacturer_v3(self, contract_id, **kwargs):  # noqa: E501
        """Add monitoring schedule for contract [manufacturer]  # noqa: E501

        Add a monitoring schedule for a given manufacturer contract.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_monitoring_schedule_manufacturer_v3(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param ComPatagonaPricemonitorShareApiPostMonitoringScheduleRequestV3 com_patagona_pricemonitor_share_api_post_monitoring_schedule_request_v3: Request body for creating monitoring schedule.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: PutMonitoringSchedulesApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.post_monitoring_schedule_manufacturer_v3_with_http_info(contract_id, **kwargs)  # noqa: E501

    def post_monitoring_schedule_manufacturer_v3_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Add monitoring schedule for contract [manufacturer]  # noqa: E501

        Add a monitoring schedule for a given manufacturer contract.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_monitoring_schedule_manufacturer_v3_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param ComPatagonaPricemonitorShareApiPostMonitoringScheduleRequestV3 com_patagona_pricemonitor_share_api_post_monitoring_schedule_request_v3: Request body for creating monitoring schedule.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(PutMonitoringSchedulesApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'com_patagona_pricemonitor_share_api_post_monitoring_schedule_request_v3'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_monitoring_schedule_manufacturer_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `post_monitoring_schedule_manufacturer_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'com_patagona_pricemonitor_share_api_post_monitoring_schedule_request_v3' in local_var_params:
            body_params = local_var_params['com_patagona_pricemonitor_share_api_post_monitoring_schedule_request_v3']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/manufacturer/contracts/{contractId}/settings/monitoringschedules', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PutMonitoringSchedulesApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_monitoring_schedule_vendor_v3(self, contract_id, **kwargs):  # noqa: E501
        """Add monitoring schedule for contract  # noqa: E501

        Add a monitoring schedule for a given contract.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_monitoring_schedule_vendor_v3(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param ComPatagonaPricemonitorShareApiPostMonitoringScheduleRequestV3 com_patagona_pricemonitor_share_api_post_monitoring_schedule_request_v3: Request body for creating monitoring schedule.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: PutMonitoringSchedulesApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.post_monitoring_schedule_vendor_v3_with_http_info(contract_id, **kwargs)  # noqa: E501

    def post_monitoring_schedule_vendor_v3_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Add monitoring schedule for contract  # noqa: E501

        Add a monitoring schedule for a given contract.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_monitoring_schedule_vendor_v3_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param ComPatagonaPricemonitorShareApiPostMonitoringScheduleRequestV3 com_patagona_pricemonitor_share_api_post_monitoring_schedule_request_v3: Request body for creating monitoring schedule.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(PutMonitoringSchedulesApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'com_patagona_pricemonitor_share_api_post_monitoring_schedule_request_v3'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_monitoring_schedule_vendor_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `post_monitoring_schedule_vendor_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'com_patagona_pricemonitor_share_api_post_monitoring_schedule_request_v3' in local_var_params:
            body_params = local_var_params['com_patagona_pricemonitor_share_api_post_monitoring_schedule_request_v3']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/vendor/contracts/{contractId}/settings/monitoringschedules', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PutMonitoringSchedulesApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_offer_statistics_vendor_query(self, contract_id, post_offer_statistics_request, **kwargs):  # noqa: E501
        """Get offer statistics per product  # noqa: E501

        This operation is used to get offer statistics (e.g. offer count, average price) grouped by product and domain.  Warning: This endpoint contains complex filter structure and will be replaced in the future. Currently, we only allow filtering by a list of internal pricemonitor product ids. Please note that offer statistics can only be computed for at **maximum 2500** products at a time.  To use the example request body from below, you have to adjust the `ownShopNames`, the `range` and `filter.right.value`. Where `filter.right.value` has to be a list of internal pricemonitor product ids corresponding to the `contractId` provided as part of the URL.  All prices will be with or without delivery costs depending on the `includeDeliveryCosts` parameter in the body.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_offer_statistics_vendor_query(contract_id, post_offer_statistics_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param PostOfferStatisticsRequest post_offer_statistics_request: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: PostOfferStatisticsApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.post_offer_statistics_vendor_query_with_http_info(contract_id, post_offer_statistics_request, **kwargs)  # noqa: E501

    def post_offer_statistics_vendor_query_with_http_info(self, contract_id, post_offer_statistics_request, **kwargs):  # noqa: E501
        """Get offer statistics per product  # noqa: E501

        This operation is used to get offer statistics (e.g. offer count, average price) grouped by product and domain.  Warning: This endpoint contains complex filter structure and will be replaced in the future. Currently, we only allow filtering by a list of internal pricemonitor product ids. Please note that offer statistics can only be computed for at **maximum 2500** products at a time.  To use the example request body from below, you have to adjust the `ownShopNames`, the `range` and `filter.right.value`. Where `filter.right.value` has to be a list of internal pricemonitor product ids corresponding to the `contractId` provided as part of the URL.  All prices will be with or without delivery costs depending on the `includeDeliveryCosts` parameter in the body.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_offer_statistics_vendor_query_with_http_info(contract_id, post_offer_statistics_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param PostOfferStatisticsRequest post_offer_statistics_request: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(PostOfferStatisticsApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'post_offer_statistics_request'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_offer_statistics_vendor_query" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `post_offer_statistics_vendor_query`")  # noqa: E501
        # verify the required parameter 'post_offer_statistics_request' is set
        if self.api_client.client_side_validation and ('post_offer_statistics_request' not in local_var_params or  # noqa: E501
                                                        local_var_params['post_offer_statistics_request'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `post_offer_statistics_request` when calling `post_offer_statistics_vendor_query`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'post_offer_statistics_request' in local_var_params:
            body_params = local_var_params['post_offer_statistics_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/vendor/contracts/{contractId}/offers/stats/query', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PostOfferStatisticsApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_vendor_shop_mapping_manufacturer_v3(self, contract_id, **kwargs):  # noqa: E501
        """Add new vendor to contract and associate shops  # noqa: E501

        Add a new vendor for a given manufacturer contract and associate shops with the given vendor.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_vendor_shop_mapping_manufacturer_v3(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param ComPatagonaPricemonitorShareApiPostVendorShopMappingRequestV3 com_patagona_pricemonitor_share_api_post_vendor_shop_mapping_request_v3: Request body for creating a new vendor and associate shops with it. Please note that atleast one shop is required for a successful creation.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: VendorShopMappingV3ApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.post_vendor_shop_mapping_manufacturer_v3_with_http_info(contract_id, **kwargs)  # noqa: E501

    def post_vendor_shop_mapping_manufacturer_v3_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Add new vendor to contract and associate shops  # noqa: E501

        Add a new vendor for a given manufacturer contract and associate shops with the given vendor.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_vendor_shop_mapping_manufacturer_v3_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param ComPatagonaPricemonitorShareApiPostVendorShopMappingRequestV3 com_patagona_pricemonitor_share_api_post_vendor_shop_mapping_request_v3: Request body for creating a new vendor and associate shops with it. Please note that atleast one shop is required for a successful creation.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(VendorShopMappingV3ApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'com_patagona_pricemonitor_share_api_post_vendor_shop_mapping_request_v3'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_vendor_shop_mapping_manufacturer_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `post_vendor_shop_mapping_manufacturer_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'com_patagona_pricemonitor_share_api_post_vendor_shop_mapping_request_v3' in local_var_params:
            body_params = local_var_params['com_patagona_pricemonitor_share_api_post_vendor_shop_mapping_request_v3']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/manufacturer/contracts/{contractId}/vendors', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='VendorShopMappingV3ApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def prices_by_day_by_product_id_manufacturer_v2(self, contract_id, product_id, **kwargs):  # noqa: E501
        """Query prices by day by product  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.prices_by_day_by_product_id_manufacturer_v2(contract_id, product_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str product_id: The product ID to filter for (required)
        :param ComPatagonaPricemonitorShareApiPricesByDayByProductIdRequestV2 com_patagona_pricemonitor_share_api_prices_by_day_by_product_id_request_v2: Query all known prices for a given day & product ID. Can be filtered by using the selectors.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: list[ComPatagonaPricemonitorShareApiPricesByDayByProductIdResponseV2]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.prices_by_day_by_product_id_manufacturer_v2_with_http_info(contract_id, product_id, **kwargs)  # noqa: E501

    def prices_by_day_by_product_id_manufacturer_v2_with_http_info(self, contract_id, product_id, **kwargs):  # noqa: E501
        """Query prices by day by product  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.prices_by_day_by_product_id_manufacturer_v2_with_http_info(contract_id, product_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str product_id: The product ID to filter for (required)
        :param ComPatagonaPricemonitorShareApiPricesByDayByProductIdRequestV2 com_patagona_pricemonitor_share_api_prices_by_day_by_product_id_request_v2: Query all known prices for a given day & product ID. Can be filtered by using the selectors.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(list[ComPatagonaPricemonitorShareApiPricesByDayByProductIdResponseV2], status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'product_id',
            'com_patagona_pricemonitor_share_api_prices_by_day_by_product_id_request_v2'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method prices_by_day_by_product_id_manufacturer_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `prices_by_day_by_product_id_manufacturer_v2`")  # noqa: E501
        # verify the required parameter 'product_id' is set
        if self.api_client.client_side_validation and ('product_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['product_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `product_id` when calling `prices_by_day_by_product_id_manufacturer_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'product_id' in local_var_params:
            path_params['productId'] = local_var_params['product_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'com_patagona_pricemonitor_share_api_prices_by_day_by_product_id_request_v2' in local_var_params:
            body_params = local_var_params['com_patagona_pricemonitor_share_api_prices_by_day_by_product_id_request_v2']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/m/contracts/{contractId}/result/pricesbyday/productid/{productId}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ComPatagonaPricemonitorShareApiPricesByDayByProductIdResponseV2]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def publish_preprocessing_task_vendor_v3(self, retrospective_in_minutes, contract_id, **kwargs):  # noqa: E501
        """Publish preprocessing task [vendor]  # noqa: E501

        Publish a preprocessing task for a vendor.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.publish_preprocessing_task_vendor_v3(retrospective_in_minutes, contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int retrospective_in_minutes: The timespan, in minutes, for considering offers in preprocessing. Allowed value is between 1 and 10080 (required)
        :param str contract_id: ID of the contract (required)
        :param bool trigger_follow_up_task:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: EmptyApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.publish_preprocessing_task_vendor_v3_with_http_info(retrospective_in_minutes, contract_id, **kwargs)  # noqa: E501

    def publish_preprocessing_task_vendor_v3_with_http_info(self, retrospective_in_minutes, contract_id, **kwargs):  # noqa: E501
        """Publish preprocessing task [vendor]  # noqa: E501

        Publish a preprocessing task for a vendor.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.publish_preprocessing_task_vendor_v3_with_http_info(retrospective_in_minutes, contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int retrospective_in_minutes: The timespan, in minutes, for considering offers in preprocessing. Allowed value is between 1 and 10080 (required)
        :param str contract_id: ID of the contract (required)
        :param bool trigger_follow_up_task:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(EmptyApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'retrospective_in_minutes',
            'contract_id',
            'trigger_follow_up_task'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method publish_preprocessing_task_vendor_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'retrospective_in_minutes' is set
        if self.api_client.client_side_validation and ('retrospective_in_minutes' not in local_var_params or  # noqa: E501
                                                        local_var_params['retrospective_in_minutes'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `retrospective_in_minutes` when calling `publish_preprocessing_task_vendor_v3`")  # noqa: E501
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `publish_preprocessing_task_vendor_v3`")  # noqa: E501

        if self.api_client.client_side_validation and 'retrospective_in_minutes' in local_var_params and local_var_params['retrospective_in_minutes'] > 10080:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `retrospective_in_minutes` when calling `publish_preprocessing_task_vendor_v3`, must be a value less than or equal to `10080`")  # noqa: E501
        if self.api_client.client_side_validation and 'retrospective_in_minutes' in local_var_params and local_var_params['retrospective_in_minutes'] < 1:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `retrospective_in_minutes` when calling `publish_preprocessing_task_vendor_v3`, must be a value greater than or equal to `1`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []
        if 'retrospective_in_minutes' in local_var_params and local_var_params['retrospective_in_minutes'] is not None:  # noqa: E501
            query_params.append(('retrospectiveInMinutes', local_var_params['retrospective_in_minutes']))  # noqa: E501
        if 'trigger_follow_up_task' in local_var_params and local_var_params['trigger_follow_up_task'] is not None:  # noqa: E501
            query_params.append(('triggerFollowUpTask', local_var_params['trigger_follow_up_task']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/vendor/contracts/{contractId}/tasks/preprocessing', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EmptyApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_callbacks(self, contract_id, callbacks, **kwargs):  # noqa: E501
        """Update callbacks [manufacturer]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_callbacks(contract_id, callbacks, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param Callbacks callbacks: Callbacks (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.put_callbacks_with_http_info(contract_id, callbacks, **kwargs)  # noqa: E501

    def put_callbacks_with_http_info(self, contract_id, callbacks, **kwargs):  # noqa: E501
        """Update callbacks [manufacturer]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_callbacks_with_http_info(contract_id, callbacks, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param Callbacks callbacks: Callbacks (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'callbacks'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_callbacks" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `put_callbacks`")  # noqa: E501
        # verify the required parameter 'callbacks' is set
        if self.api_client.client_side_validation and ('callbacks' not in local_var_params or  # noqa: E501
                                                        local_var_params['callbacks'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `callbacks` when calling `put_callbacks`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'callbacks' in local_var_params:
            body_params = local_var_params['callbacks']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/m/contracts/{contractId}/settings/callbacks', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_callbacks_vendor_v2(self, contract_id, **kwargs):  # noqa: E501
        """Update callbacks [vendor]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_callbacks_vendor_v2(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.put_callbacks_vendor_v2_with_http_info(contract_id, **kwargs)  # noqa: E501

    def put_callbacks_vendor_v2_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Update callbacks [vendor]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_callbacks_vendor_v2_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_callbacks_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `put_callbacks_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/settings/callbacks', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_complex_offer_filters_vendor_v2(self, contract_id, list_type, **kwargs):  # noqa: E501
        """Add the complex filters for the given contract.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_complex_offer_filters_vendor_v2(contract_id, list_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str list_type: (required)
        :param list[AndOfferFilter] and_offer_filter: List of the filter that needs to be considered to ignore the individual offers.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: OfferFilterApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.put_complex_offer_filters_vendor_v2_with_http_info(contract_id, list_type, **kwargs)  # noqa: E501

    def put_complex_offer_filters_vendor_v2_with_http_info(self, contract_id, list_type, **kwargs):  # noqa: E501
        """Add the complex filters for the given contract.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_complex_offer_filters_vendor_v2_with_http_info(contract_id, list_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str list_type: (required)
        :param list[AndOfferFilter] and_offer_filter: List of the filter that needs to be considered to ignore the individual offers.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(OfferFilterApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'list_type',
            'and_offer_filter'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_complex_offer_filters_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `put_complex_offer_filters_vendor_v2`")  # noqa: E501
        # verify the required parameter 'list_type' is set
        if self.api_client.client_side_validation and ('list_type' not in local_var_params or  # noqa: E501
                                                        local_var_params['list_type'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `list_type` when calling `put_complex_offer_filters_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'list_type' in local_var_params:
            path_params['listType'] = local_var_params['list_type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'and_offer_filter' in local_var_params:
            body_params = local_var_params['and_offer_filter']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/offerfilters/{listType}/complex', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='OfferFilterApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_csv_products(self, contract_id, body, **kwargs):  # noqa: E501
        """Set products via CSV file (V2)  # noqa: E501

        Warning: Deletes all existing products.         <br/>Note that this will not happen immediately. Instead, you receive the ID of a task that has been created.         <br/>Furthermore you receive an URL which you can use to check if the task was executed successfully.         <br>The csv file must contain following columns:         <ul>           <li>productId - arbitrary string, can be used for the systems product id.</li>           <li>gtin - the GTIN of the product           <li>description - name or short description of the product           <li>referencePrice - arbitrary decimal number, usually the current price or recommended retail price (gross)           <li>minPriceBoundary - decimal number defining the lower price boundary (gross)           <li>maxPriceBoundary - decimal number defining the upper price boundary (gross)           <li>Additional columns are added as product tags. Tags are used for repricing strategies and several other           purpose.         </ul>         <br/>Column separator must be semicolon, the decimal separator must be dot. File encoding must be UTF-8.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_csv_products(contract_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str body: CSV file containing the products (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.put_csv_products_with_http_info(contract_id, body, **kwargs)  # noqa: E501

    def put_csv_products_with_http_info(self, contract_id, body, **kwargs):  # noqa: E501
        """Set products via CSV file (V2)  # noqa: E501

        Warning: Deletes all existing products.         <br/>Note that this will not happen immediately. Instead, you receive the ID of a task that has been created.         <br/>Furthermore you receive an URL which you can use to check if the task was executed successfully.         <br>The csv file must contain following columns:         <ul>           <li>productId - arbitrary string, can be used for the systems product id.</li>           <li>gtin - the GTIN of the product           <li>description - name or short description of the product           <li>referencePrice - arbitrary decimal number, usually the current price or recommended retail price (gross)           <li>minPriceBoundary - decimal number defining the lower price boundary (gross)           <li>maxPriceBoundary - decimal number defining the upper price boundary (gross)           <li>Additional columns are added as product tags. Tags are used for repricing strategies and several other           purpose.         </ul>         <br/>Column separator must be semicolon, the decimal separator must be dot. File encoding must be UTF-8.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_csv_products_with_http_info(contract_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str body: CSV file containing the products (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_csv_products" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `put_csv_products`")  # noqa: E501
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in local_var_params or  # noqa: E501
                                                        local_var_params['body'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `body` when calling `put_csv_products`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['text/csv'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/products/csv', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_csv_products_manufacturer_v3(self, contract_id, content_type, patagona_product_identifying_attributes, patagona_product_name, patagona_product_reference_price, patagona_decimal_separator, patagona_csv_column_separator, patagona_csv_quotation_character, body, **kwargs):  # noqa: E501
        """Set products via CSV file (V3)  # noqa: E501

        This operation is used to import products into the pricemonitor. This process is represented by a task, which is processed asynchronously. In the response you will receive a url which is used to check the status of the import process. <br>  When the process is done all products in csv file from the request body will be in the pricemonitor. Products that were already present before have been updated and new products have been added. <br>  Warning: All products that were in the pricemonitor before but are not present in the new import will be deleted.  Identification of the products is done based on the identifying attributes (see parameter: patagona-product-identifying-attributes)'  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_csv_products_manufacturer_v3(contract_id, content_type, patagona_product_identifying_attributes, patagona_product_name, patagona_product_reference_price, patagona_decimal_separator, patagona_csv_column_separator, patagona_csv_quotation_character, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str content_type: (required)
        :param str patagona_product_identifying_attributes: Comma separated list of csv columns that identify a product uniquely (required)
        :param str patagona_product_name: Csv column that contains the product name (required)
        :param str patagona_product_reference_price: Csv column that contains the reference price (required)
        :param str patagona_decimal_separator: Decimal separator used for parsing numbers \\ The values for patagona-decimal-separator, patagona-csv-column-separator and patagona-csv-quotation-character must be different from one another. \\ Available values: \",\", \".\" (required)
        :param str patagona_csv_column_separator: The csv column separator \\ The values for patagona-decimal-separator, patagona-csv-column-separator and patagona-csv-quotation-character must be different from one another. (required)
        :param str patagona_csv_quotation_character: The csv quotation character \\ The values for patagona-decimal-separator, patagona-csv-column-separator and patagona-csv-quotation-character must be different from one another. (required)
        :param str body: CSV file containing the products. Note: The CSV file should be encoded in UTF-8. (required)
        :param str patagona_product_gtin: Csv column that contains the gtin
        :param str patagona_product_customer_id: Csv column that contains an id (There is no requirement for this field to be unique)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: PutProductsApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.put_csv_products_manufacturer_v3_with_http_info(contract_id, content_type, patagona_product_identifying_attributes, patagona_product_name, patagona_product_reference_price, patagona_decimal_separator, patagona_csv_column_separator, patagona_csv_quotation_character, body, **kwargs)  # noqa: E501

    def put_csv_products_manufacturer_v3_with_http_info(self, contract_id, content_type, patagona_product_identifying_attributes, patagona_product_name, patagona_product_reference_price, patagona_decimal_separator, patagona_csv_column_separator, patagona_csv_quotation_character, body, **kwargs):  # noqa: E501
        """Set products via CSV file (V3)  # noqa: E501

        This operation is used to import products into the pricemonitor. This process is represented by a task, which is processed asynchronously. In the response you will receive a url which is used to check the status of the import process. <br>  When the process is done all products in csv file from the request body will be in the pricemonitor. Products that were already present before have been updated and new products have been added. <br>  Warning: All products that were in the pricemonitor before but are not present in the new import will be deleted.  Identification of the products is done based on the identifying attributes (see parameter: patagona-product-identifying-attributes)'  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_csv_products_manufacturer_v3_with_http_info(contract_id, content_type, patagona_product_identifying_attributes, patagona_product_name, patagona_product_reference_price, patagona_decimal_separator, patagona_csv_column_separator, patagona_csv_quotation_character, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str content_type: (required)
        :param str patagona_product_identifying_attributes: Comma separated list of csv columns that identify a product uniquely (required)
        :param str patagona_product_name: Csv column that contains the product name (required)
        :param str patagona_product_reference_price: Csv column that contains the reference price (required)
        :param str patagona_decimal_separator: Decimal separator used for parsing numbers \\ The values for patagona-decimal-separator, patagona-csv-column-separator and patagona-csv-quotation-character must be different from one another. \\ Available values: \",\", \".\" (required)
        :param str patagona_csv_column_separator: The csv column separator \\ The values for patagona-decimal-separator, patagona-csv-column-separator and patagona-csv-quotation-character must be different from one another. (required)
        :param str patagona_csv_quotation_character: The csv quotation character \\ The values for patagona-decimal-separator, patagona-csv-column-separator and patagona-csv-quotation-character must be different from one another. (required)
        :param str body: CSV file containing the products. Note: The CSV file should be encoded in UTF-8. (required)
        :param str patagona_product_gtin: Csv column that contains the gtin
        :param str patagona_product_customer_id: Csv column that contains an id (There is no requirement for this field to be unique)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(PutProductsApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'content_type',
            'patagona_product_identifying_attributes',
            'patagona_product_name',
            'patagona_product_reference_price',
            'patagona_decimal_separator',
            'patagona_csv_column_separator',
            'patagona_csv_quotation_character',
            'body',
            'patagona_product_gtin',
            'patagona_product_customer_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_csv_products_manufacturer_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `put_csv_products_manufacturer_v3`")  # noqa: E501
        # verify the required parameter 'content_type' is set
        if self.api_client.client_side_validation and ('content_type' not in local_var_params or  # noqa: E501
                                                        local_var_params['content_type'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `content_type` when calling `put_csv_products_manufacturer_v3`")  # noqa: E501
        # verify the required parameter 'patagona_product_identifying_attributes' is set
        if self.api_client.client_side_validation and ('patagona_product_identifying_attributes' not in local_var_params or  # noqa: E501
                                                        local_var_params['patagona_product_identifying_attributes'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `patagona_product_identifying_attributes` when calling `put_csv_products_manufacturer_v3`")  # noqa: E501
        # verify the required parameter 'patagona_product_name' is set
        if self.api_client.client_side_validation and ('patagona_product_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['patagona_product_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `patagona_product_name` when calling `put_csv_products_manufacturer_v3`")  # noqa: E501
        # verify the required parameter 'patagona_product_reference_price' is set
        if self.api_client.client_side_validation and ('patagona_product_reference_price' not in local_var_params or  # noqa: E501
                                                        local_var_params['patagona_product_reference_price'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `patagona_product_reference_price` when calling `put_csv_products_manufacturer_v3`")  # noqa: E501
        # verify the required parameter 'patagona_decimal_separator' is set
        if self.api_client.client_side_validation and ('patagona_decimal_separator' not in local_var_params or  # noqa: E501
                                                        local_var_params['patagona_decimal_separator'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `patagona_decimal_separator` when calling `put_csv_products_manufacturer_v3`")  # noqa: E501
        # verify the required parameter 'patagona_csv_column_separator' is set
        if self.api_client.client_side_validation and ('patagona_csv_column_separator' not in local_var_params or  # noqa: E501
                                                        local_var_params['patagona_csv_column_separator'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `patagona_csv_column_separator` when calling `put_csv_products_manufacturer_v3`")  # noqa: E501
        # verify the required parameter 'patagona_csv_quotation_character' is set
        if self.api_client.client_side_validation and ('patagona_csv_quotation_character' not in local_var_params or  # noqa: E501
                                                        local_var_params['patagona_csv_quotation_character'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `patagona_csv_quotation_character` when calling `put_csv_products_manufacturer_v3`")  # noqa: E501
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in local_var_params or  # noqa: E501
                                                        local_var_params['body'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `body` when calling `put_csv_products_manufacturer_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'content_type' in local_var_params:
            header_params['content-type'] = local_var_params['content_type']  # noqa: E501
        if 'patagona_product_identifying_attributes' in local_var_params:
            header_params['patagona-product-identifying-attributes'] = local_var_params['patagona_product_identifying_attributes']  # noqa: E501
        if 'patagona_product_name' in local_var_params:
            header_params['patagona-product-name'] = local_var_params['patagona_product_name']  # noqa: E501
        if 'patagona_product_reference_price' in local_var_params:
            header_params['patagona-product-reference-price'] = local_var_params['patagona_product_reference_price']  # noqa: E501
        if 'patagona_product_gtin' in local_var_params:
            header_params['patagona-product-gtin'] = local_var_params['patagona_product_gtin']  # noqa: E501
        if 'patagona_product_customer_id' in local_var_params:
            header_params['patagona-product-customer-id'] = local_var_params['patagona_product_customer_id']  # noqa: E501
        if 'patagona_decimal_separator' in local_var_params:
            header_params['patagona-decimal-separator'] = local_var_params['patagona_decimal_separator']  # noqa: E501
        if 'patagona_csv_column_separator' in local_var_params:
            header_params['patagona-csv-column-separator'] = local_var_params['patagona_csv_column_separator']  # noqa: E501
        if 'patagona_csv_quotation_character' in local_var_params:
            header_params['patagona-csv-quotation-character'] = local_var_params['patagona_csv_quotation_character']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['text/csv'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/manufacturer/contracts/{contractId}/products', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PutProductsApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_currency_vendor_v2(self, contract_id, **kwargs):  # noqa: E501
        """Update currency settings [vendor]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_currency_vendor_v2(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.put_currency_vendor_v2_with_http_info(contract_id, **kwargs)  # noqa: E501

    def put_currency_vendor_v2_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Update currency settings [vendor]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_currency_vendor_v2_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_currency_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `put_currency_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/settings/currency', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_customer_contract_settings_manufacturer_v3(self, contract_id, **kwargs):  # noqa: E501
        """Update contract settings [manufacturer]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_customer_contract_settings_manufacturer_v3(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param ComPatagonaPricemonitorShareApiCustomerContractSettings com_patagona_pricemonitor_share_api_customer_contract_settings: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: PutCustomerContractSettingsApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.put_customer_contract_settings_manufacturer_v3_with_http_info(contract_id, **kwargs)  # noqa: E501

    def put_customer_contract_settings_manufacturer_v3_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Update contract settings [manufacturer]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_customer_contract_settings_manufacturer_v3_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param ComPatagonaPricemonitorShareApiCustomerContractSettings com_patagona_pricemonitor_share_api_customer_contract_settings: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(PutCustomerContractSettingsApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'com_patagona_pricemonitor_share_api_customer_contract_settings'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_customer_contract_settings_manufacturer_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `put_customer_contract_settings_manufacturer_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'com_patagona_pricemonitor_share_api_customer_contract_settings' in local_var_params:
            body_params = local_var_params['com_patagona_pricemonitor_share_api_customer_contract_settings']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/manufacturer/contracts/{contractId}/settings/customer', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PutCustomerContractSettingsApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_customer_contract_settings_vendor_v3(self, contract_id, **kwargs):  # noqa: E501
        """Update customer contract settings [vendor]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_customer_contract_settings_vendor_v3(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param ComPatagonaPricemonitorShareApiCustomerContractSettings com_patagona_pricemonitor_share_api_customer_contract_settings: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: PutCustomerContractSettingsApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.put_customer_contract_settings_vendor_v3_with_http_info(contract_id, **kwargs)  # noqa: E501

    def put_customer_contract_settings_vendor_v3_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Update customer contract settings [vendor]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_customer_contract_settings_vendor_v3_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param ComPatagonaPricemonitorShareApiCustomerContractSettings com_patagona_pricemonitor_share_api_customer_contract_settings: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(PutCustomerContractSettingsApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'com_patagona_pricemonitor_share_api_customer_contract_settings'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_customer_contract_settings_vendor_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `put_customer_contract_settings_vendor_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'com_patagona_pricemonitor_share_api_customer_contract_settings' in local_var_params:
            body_params = local_var_params['com_patagona_pricemonitor_share_api_customer_contract_settings']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/vendor/contracts/{contractId}/settings/customer', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PutCustomerContractSettingsApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_dynamic_monitoring_settings(self, contract_id, **kwargs):  # noqa: E501
        """Update dynamic monitoring settings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_dynamic_monitoring_settings(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.put_dynamic_monitoring_settings_with_http_info(contract_id, **kwargs)  # noqa: E501

    def put_dynamic_monitoring_settings_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Update dynamic monitoring settings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_dynamic_monitoring_settings_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_dynamic_monitoring_settings" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `put_dynamic_monitoring_settings`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/1/{contractId}/settings/dynamicmonitoring', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_feed_vendor_v2(self, contract_id, feed_id, **kwargs):  # noqa: E501
        """Update feed  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_feed_vendor_v2(contract_id, feed_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str feed_id: (required)
        :param object body: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.put_feed_vendor_v2_with_http_info(contract_id, feed_id, **kwargs)  # noqa: E501

    def put_feed_vendor_v2_with_http_info(self, contract_id, feed_id, **kwargs):  # noqa: E501
        """Update feed  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_feed_vendor_v2_with_http_info(contract_id, feed_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str feed_id: (required)
        :param object body: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'feed_id',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_feed_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `put_feed_vendor_v2`")  # noqa: E501
        # verify the required parameter 'feed_id' is set
        if self.api_client.client_side_validation and ('feed_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['feed_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `feed_id` when calling `put_feed_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'feed_id' in local_var_params:
            path_params['feedId'] = local_var_params['feed_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/feeds/{feedId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_image_tag_manufacturer_v2(self, contract_id, **kwargs):  # noqa: E501
        """Update image tag [manufacturer]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_image_tag_manufacturer_v2(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.put_image_tag_manufacturer_v2_with_http_info(contract_id, **kwargs)  # noqa: E501

    def put_image_tag_manufacturer_v2_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Update image tag [manufacturer]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_image_tag_manufacturer_v2_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_image_tag_manufacturer_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `put_image_tag_manufacturer_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/m/contracts/{contractId}/settings/imagetag', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_image_tag_vendor_v2(self, contract_id, **kwargs):  # noqa: E501
        """Update image tag [vendor]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_image_tag_vendor_v2(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.put_image_tag_vendor_v2_with_http_info(contract_id, **kwargs)  # noqa: E501

    def put_image_tag_vendor_v2_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Update image tag [vendor]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_image_tag_vendor_v2_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_image_tag_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `put_image_tag_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/settings/imagetag', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_import_settings_vendor_v2(self, contract_id, **kwargs):  # noqa: E501
        """Update import settings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_import_settings_vendor_v2(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.put_import_settings_vendor_v2_with_http_info(contract_id, **kwargs)  # noqa: E501

    def put_import_settings_vendor_v2_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Update import settings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_import_settings_vendor_v2_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_import_settings_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `put_import_settings_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/settings/import', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_monitoring_schedule_manufacturer_v3(self, contract_id, schedule_id, **kwargs):  # noqa: E501
        """Update monitoring schedule for contract [manufacturer]  # noqa: E501

        Update a monitoring schedule for a given manufacturer contract.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_monitoring_schedule_manufacturer_v3(contract_id, schedule_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param int schedule_id: ID of a monitoring schedule (required)
        :param ComPatagonaPricemonitorShareApiPostMonitoringScheduleRequestV3 com_patagona_pricemonitor_share_api_post_monitoring_schedule_request_v3: Request body for updating monitoring schedule.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: PutMonitoringSchedulesApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.put_monitoring_schedule_manufacturer_v3_with_http_info(contract_id, schedule_id, **kwargs)  # noqa: E501

    def put_monitoring_schedule_manufacturer_v3_with_http_info(self, contract_id, schedule_id, **kwargs):  # noqa: E501
        """Update monitoring schedule for contract [manufacturer]  # noqa: E501

        Update a monitoring schedule for a given manufacturer contract.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_monitoring_schedule_manufacturer_v3_with_http_info(contract_id, schedule_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param int schedule_id: ID of a monitoring schedule (required)
        :param ComPatagonaPricemonitorShareApiPostMonitoringScheduleRequestV3 com_patagona_pricemonitor_share_api_post_monitoring_schedule_request_v3: Request body for updating monitoring schedule.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(PutMonitoringSchedulesApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'schedule_id',
            'com_patagona_pricemonitor_share_api_post_monitoring_schedule_request_v3'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_monitoring_schedule_manufacturer_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `put_monitoring_schedule_manufacturer_v3`")  # noqa: E501
        # verify the required parameter 'schedule_id' is set
        if self.api_client.client_side_validation and ('schedule_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['schedule_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `schedule_id` when calling `put_monitoring_schedule_manufacturer_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'schedule_id' in local_var_params:
            path_params['scheduleId'] = local_var_params['schedule_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'com_patagona_pricemonitor_share_api_post_monitoring_schedule_request_v3' in local_var_params:
            body_params = local_var_params['com_patagona_pricemonitor_share_api_post_monitoring_schedule_request_v3']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/manufacturer/contracts/{contractId}/settings/monitoringschedules/{scheduleId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PutMonitoringSchedulesApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_monitoring_schedule_vendor_v3(self, contract_id, schedule_id, **kwargs):  # noqa: E501
        """Update monitoring schedule for contract [vendor]  # noqa: E501

        Update a monitoring schedule for a given vendor contract.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_monitoring_schedule_vendor_v3(contract_id, schedule_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param int schedule_id: ID of a monitoring schedule (required)
        :param ComPatagonaPricemonitorShareApiPostMonitoringScheduleRequestV3 com_patagona_pricemonitor_share_api_post_monitoring_schedule_request_v3: Request body for updating monitoring schedule.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: PutMonitoringSchedulesApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.put_monitoring_schedule_vendor_v3_with_http_info(contract_id, schedule_id, **kwargs)  # noqa: E501

    def put_monitoring_schedule_vendor_v3_with_http_info(self, contract_id, schedule_id, **kwargs):  # noqa: E501
        """Update monitoring schedule for contract [vendor]  # noqa: E501

        Update a monitoring schedule for a given vendor contract.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_monitoring_schedule_vendor_v3_with_http_info(contract_id, schedule_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param int schedule_id: ID of a monitoring schedule (required)
        :param ComPatagonaPricemonitorShareApiPostMonitoringScheduleRequestV3 com_patagona_pricemonitor_share_api_post_monitoring_schedule_request_v3: Request body for updating monitoring schedule.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(PutMonitoringSchedulesApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'schedule_id',
            'com_patagona_pricemonitor_share_api_post_monitoring_schedule_request_v3'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_monitoring_schedule_vendor_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `put_monitoring_schedule_vendor_v3`")  # noqa: E501
        # verify the required parameter 'schedule_id' is set
        if self.api_client.client_side_validation and ('schedule_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['schedule_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `schedule_id` when calling `put_monitoring_schedule_vendor_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'schedule_id' in local_var_params:
            path_params['scheduleId'] = local_var_params['schedule_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'com_patagona_pricemonitor_share_api_post_monitoring_schedule_request_v3' in local_var_params:
            body_params = local_var_params['com_patagona_pricemonitor_share_api_post_monitoring_schedule_request_v3']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/vendor/contracts/{contractId}/settings/monitoringschedules/{scheduleId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PutMonitoringSchedulesApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_monitoring_settings_manufacturer_v2(self, contract_id, **kwargs):  # noqa: E501
        """Update monitoring settings for contract  # noqa: E501

        Update the monitoring settings for a given contract  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_monitoring_settings_manufacturer_v2(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: The monitoring settings object to be written to the database
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.put_monitoring_settings_manufacturer_v2_with_http_info(contract_id, **kwargs)  # noqa: E501

    def put_monitoring_settings_manufacturer_v2_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Update monitoring settings for contract  # noqa: E501

        Update the monitoring settings for a given contract  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_monitoring_settings_manufacturer_v2_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: The monitoring settings object to be written to the database
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_monitoring_settings_manufacturer_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `put_monitoring_settings_manufacturer_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/m/contracts/{contractId}/settings/monitoring', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_monitoring_settings_manufacturer_v3(self, contract_id, **kwargs):  # noqa: E501
        """Update monitoring settings [manufacturer]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_monitoring_settings_manufacturer_v3(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.put_monitoring_settings_manufacturer_v3_with_http_info(contract_id, **kwargs)  # noqa: E501

    def put_monitoring_settings_manufacturer_v3_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Update monitoring settings [manufacturer]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_monitoring_settings_manufacturer_v3_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_monitoring_settings_manufacturer_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `put_monitoring_settings_manufacturer_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/manufacturer/contracts/{contractId}/settings/monitoring', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_monitoring_settings_vendor_v2(self, contract_id, **kwargs):  # noqa: E501
        """Update monitoring settings [vendor]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_monitoring_settings_vendor_v2(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.put_monitoring_settings_vendor_v2_with_http_info(contract_id, **kwargs)  # noqa: E501

    def put_monitoring_settings_vendor_v2_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Update monitoring settings [vendor]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_monitoring_settings_vendor_v2_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_monitoring_settings_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `put_monitoring_settings_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/settings/monitoring', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_monitoring_settings_vendor_v3(self, contract_id, **kwargs):  # noqa: E501
        """Update monitoring settings [vendor]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_monitoring_settings_vendor_v3(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.put_monitoring_settings_vendor_v3_with_http_info(contract_id, **kwargs)  # noqa: E501

    def put_monitoring_settings_vendor_v3_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Update monitoring settings [vendor]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_monitoring_settings_vendor_v3_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_monitoring_settings_vendor_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `put_monitoring_settings_vendor_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/vendor/contracts/{contractId}/settings/monitoring', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_offer_filters_vendor_v2(self, contract_id, list_type, **kwargs):  # noqa: E501
        """Store vendor filters for contract  # noqa: E501

        Store the vendor filters for the given contract.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_offer_filters_vendor_v2(contract_id, list_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str list_type: (required)
        :param object body: List of the filters that needs to be considered to ignore the individual offers.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.put_offer_filters_vendor_v2_with_http_info(contract_id, list_type, **kwargs)  # noqa: E501

    def put_offer_filters_vendor_v2_with_http_info(self, contract_id, list_type, **kwargs):  # noqa: E501
        """Store vendor filters for contract  # noqa: E501

        Store the vendor filters for the given contract.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_offer_filters_vendor_v2_with_http_info(contract_id, list_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str list_type: (required)
        :param object body: List of the filters that needs to be considered to ignore the individual offers.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'list_type',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_offer_filters_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `put_offer_filters_vendor_v2`")  # noqa: E501
        # verify the required parameter 'list_type' is set
        if self.api_client.client_side_validation and ('list_type' not in local_var_params or  # noqa: E501
                                                        local_var_params['list_type'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `list_type` when calling `put_offer_filters_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'list_type' in local_var_params:
            path_params['listType'] = local_var_params['list_type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/offerfilters/{listType}/vendors', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_offer_retention_settings_manufacturer_v3(self, contract_id, contract_type, **kwargs):  # noqa: E501
        """Update offer retention settings [manufacturer]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_offer_retention_settings_manufacturer_v3(contract_id, contract_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str contract_type: (required)
        :param object body: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.put_offer_retention_settings_manufacturer_v3_with_http_info(contract_id, contract_type, **kwargs)  # noqa: E501

    def put_offer_retention_settings_manufacturer_v3_with_http_info(self, contract_id, contract_type, **kwargs):  # noqa: E501
        """Update offer retention settings [manufacturer]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_offer_retention_settings_manufacturer_v3_with_http_info(contract_id, contract_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str contract_type: (required)
        :param object body: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'contract_type',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_offer_retention_settings_manufacturer_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `put_offer_retention_settings_manufacturer_v3`")  # noqa: E501
        # verify the required parameter 'contract_type' is set
        if self.api_client.client_side_validation and ('contract_type' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_type'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_type` when calling `put_offer_retention_settings_manufacturer_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []
        if 'contract_type' in local_var_params and local_var_params['contract_type'] is not None:  # noqa: E501
            query_params.append(('contractType', local_var_params['contract_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/manufacturer/contracts/{contractId}/settings/offerretention', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_offer_retention_settings_vendor_v3(self, contract_id, contract_type, **kwargs):  # noqa: E501
        """Update offer retention settings [vendor]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_offer_retention_settings_vendor_v3(contract_id, contract_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str contract_type: (required)
        :param object body: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.put_offer_retention_settings_vendor_v3_with_http_info(contract_id, contract_type, **kwargs)  # noqa: E501

    def put_offer_retention_settings_vendor_v3_with_http_info(self, contract_id, contract_type, **kwargs):  # noqa: E501
        """Update offer retention settings [vendor]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_offer_retention_settings_vendor_v3_with_http_info(contract_id, contract_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str contract_type: (required)
        :param object body: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'contract_type',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_offer_retention_settings_vendor_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `put_offer_retention_settings_vendor_v3`")  # noqa: E501
        # verify the required parameter 'contract_type' is set
        if self.api_client.client_side_validation and ('contract_type' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_type'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_type` when calling `put_offer_retention_settings_vendor_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []
        if 'contract_type' in local_var_params and local_var_params['contract_type'] is not None:  # noqa: E501
            query_params.append(('contractType', local_var_params['contract_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/vendor/contracts/{contractId}/settings/offerretention', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_product_filters_vendor_v2(self, contract_id, list_type, product_id, **kwargs):  # noqa: E501
        """Store the filters of a given product for the given contract.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_product_filters_vendor_v2(contract_id, list_type, product_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str list_type: (required)
        :param str product_id: (required)
        :param list[AndOfferFilter] and_offer_filter: List of the filter that needs to be considered to ignore the individual offers.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: OfferFilterApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.put_product_filters_vendor_v2_with_http_info(contract_id, list_type, product_id, **kwargs)  # noqa: E501

    def put_product_filters_vendor_v2_with_http_info(self, contract_id, list_type, product_id, **kwargs):  # noqa: E501
        """Store the filters of a given product for the given contract.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_product_filters_vendor_v2_with_http_info(contract_id, list_type, product_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str list_type: (required)
        :param str product_id: (required)
        :param list[AndOfferFilter] and_offer_filter: List of the filter that needs to be considered to ignore the individual offers.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(OfferFilterApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'list_type',
            'product_id',
            'and_offer_filter'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_product_filters_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `put_product_filters_vendor_v2`")  # noqa: E501
        # verify the required parameter 'list_type' is set
        if self.api_client.client_side_validation and ('list_type' not in local_var_params or  # noqa: E501
                                                        local_var_params['list_type'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `list_type` when calling `put_product_filters_vendor_v2`")  # noqa: E501
        # verify the required parameter 'product_id' is set
        if self.api_client.client_side_validation and ('product_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['product_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `product_id` when calling `put_product_filters_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'list_type' in local_var_params:
            path_params['listType'] = local_var_params['list_type']  # noqa: E501
        if 'product_id' in local_var_params:
            path_params['productId'] = local_var_params['product_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'and_offer_filter' in local_var_params:
            body_params = local_var_params['and_offer_filter']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/offerfilters/{listType}/products/{productId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='OfferFilterApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_product_properties_v3(self, contract_id, product_id, com_patagona_pricemonitor_share_api_put_product_properties_request_v3, **kwargs):  # noqa: E501
        """Manage product properties for a product  # noqa: E501

        This endpoint allows creating, updating, or deleting product properties for a certain product and contract. For deleting product properties, it's sufficient to provide an empty list of product properties. When providing dates, please use the ISO 8601 format. When providing numbers, please use dot as decimal separator.  Product properties represent additional information for a product, independent of imported products and tags.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_product_properties_v3(contract_id, product_id, com_patagona_pricemonitor_share_api_put_product_properties_request_v3, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param int product_id: ID of the product (Omnia's internal product id) (required)
        :param ComPatagonaPricemonitorShareApiPutProductPropertiesRequestV3 com_patagona_pricemonitor_share_api_put_product_properties_request_v3: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: EmptyApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.put_product_properties_v3_with_http_info(contract_id, product_id, com_patagona_pricemonitor_share_api_put_product_properties_request_v3, **kwargs)  # noqa: E501

    def put_product_properties_v3_with_http_info(self, contract_id, product_id, com_patagona_pricemonitor_share_api_put_product_properties_request_v3, **kwargs):  # noqa: E501
        """Manage product properties for a product  # noqa: E501

        This endpoint allows creating, updating, or deleting product properties for a certain product and contract. For deleting product properties, it's sufficient to provide an empty list of product properties. When providing dates, please use the ISO 8601 format. When providing numbers, please use dot as decimal separator.  Product properties represent additional information for a product, independent of imported products and tags.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_product_properties_v3_with_http_info(contract_id, product_id, com_patagona_pricemonitor_share_api_put_product_properties_request_v3, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param int product_id: ID of the product (Omnia's internal product id) (required)
        :param ComPatagonaPricemonitorShareApiPutProductPropertiesRequestV3 com_patagona_pricemonitor_share_api_put_product_properties_request_v3: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(EmptyApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'product_id',
            'com_patagona_pricemonitor_share_api_put_product_properties_request_v3'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_product_properties_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `put_product_properties_v3`")  # noqa: E501
        # verify the required parameter 'product_id' is set
        if self.api_client.client_side_validation and ('product_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['product_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `product_id` when calling `put_product_properties_v3`")  # noqa: E501
        # verify the required parameter 'com_patagona_pricemonitor_share_api_put_product_properties_request_v3' is set
        if self.api_client.client_side_validation and ('com_patagona_pricemonitor_share_api_put_product_properties_request_v3' not in local_var_params or  # noqa: E501
                                                        local_var_params['com_patagona_pricemonitor_share_api_put_product_properties_request_v3'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `com_patagona_pricemonitor_share_api_put_product_properties_request_v3` when calling `put_product_properties_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'product_id' in local_var_params:
            path_params['productId'] = local_var_params['product_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'com_patagona_pricemonitor_share_api_put_product_properties_request_v3' in local_var_params:
            body_params = local_var_params['com_patagona_pricemonitor_share_api_put_product_properties_request_v3']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/vendor/contracts/{contractId}/products/{productId}/properties', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EmptyApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_products_csv_manufacturer_v2(self, contract_id, **kwargs):  # noqa: E501
        """Set products via CSV file [manufacturer]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_products_csv_manufacturer_v2(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.put_products_csv_manufacturer_v2_with_http_info(contract_id, **kwargs)  # noqa: E501

    def put_products_csv_manufacturer_v2_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Set products via CSV file [manufacturer]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_products_csv_manufacturer_v2_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_products_csv_manufacturer_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `put_products_csv_manufacturer_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/m/contracts/{contractId}/products/csv', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_products_vendor_v2(self, contract_id, **kwargs):  # noqa: E501
        """Update products in bulk (JSON)  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_products_vendor_v2(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.put_products_vendor_v2_with_http_info(contract_id, **kwargs)  # noqa: E501

    def put_products_vendor_v2_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Update products in bulk (JSON)  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_products_vendor_v2_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_products_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `put_products_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/products', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_repricing_strategy_vendor_v2(self, contract_id, **kwargs):  # noqa: E501
        """Update repricing strategy  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_repricing_strategy_vendor_v2(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.put_repricing_strategy_vendor_v2_with_http_info(contract_id, **kwargs)  # noqa: E501

    def put_repricing_strategy_vendor_v2_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Update repricing strategy  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_repricing_strategy_vendor_v2_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_repricing_strategy_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `put_repricing_strategy_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/settings/repricingstrategy', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_settings(self, contract_id, **kwargs):  # noqa: E501
        """Update settings for contract  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_settings(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param ComPatagonaPricemonitorShareApiPutAdminContractSettingsBody com_patagona_pricemonitor_share_api_put_admin_contract_settings_body: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ComPatagonaPricemonitorShareApiPutAdminContractSettingsBody
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.put_settings_with_http_info(contract_id, **kwargs)  # noqa: E501

    def put_settings_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Update settings for contract  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_settings_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param ComPatagonaPricemonitorShareApiPutAdminContractSettingsBody com_patagona_pricemonitor_share_api_put_admin_contract_settings_body: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ComPatagonaPricemonitorShareApiPutAdminContractSettingsBody, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'com_patagona_pricemonitor_share_api_put_admin_contract_settings_body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_settings" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `put_settings`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'com_patagona_pricemonitor_share_api_put_admin_contract_settings_body' in local_var_params:
            body_params = local_var_params['com_patagona_pricemonitor_share_api_put_admin_contract_settings_body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/1/{contractId}/settings', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ComPatagonaPricemonitorShareApiPutAdminContractSettingsBody',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_user_access_to_contracts_of_company_v3(self, company_id, **kwargs):  # noqa: E501
        """Set contract access of users  # noqa: E501

        Users can either access all contracts of a company or only dedicated contracts. With this api endpoint one can control the access rights of a user.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_user_access_to_contracts_of_company_v3(company_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int company_id: ID of a company (required)
        :param ComPatagonaPricemonitorShareApiUserAccessToContractsOfCompany com_patagona_pricemonitor_share_api_user_access_to_contracts_of_company: All users and their accessible contracts
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: EmptyApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.put_user_access_to_contracts_of_company_v3_with_http_info(company_id, **kwargs)  # noqa: E501

    def put_user_access_to_contracts_of_company_v3_with_http_info(self, company_id, **kwargs):  # noqa: E501
        """Set contract access of users  # noqa: E501

        Users can either access all contracts of a company or only dedicated contracts. With this api endpoint one can control the access rights of a user.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_user_access_to_contracts_of_company_v3_with_http_info(company_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int company_id: ID of a company (required)
        :param ComPatagonaPricemonitorShareApiUserAccessToContractsOfCompany com_patagona_pricemonitor_share_api_user_access_to_contracts_of_company: All users and their accessible contracts
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(EmptyApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'company_id',
            'com_patagona_pricemonitor_share_api_user_access_to_contracts_of_company'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_user_access_to_contracts_of_company_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'company_id' is set
        if self.api_client.client_side_validation and ('company_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['company_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `company_id` when calling `put_user_access_to_contracts_of_company_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'company_id' in local_var_params:
            path_params['companyId'] = local_var_params['company_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'com_patagona_pricemonitor_share_api_user_access_to_contracts_of_company' in local_var_params:
            body_params = local_var_params['com_patagona_pricemonitor_share_api_user_access_to_contracts_of_company']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/companies/{companyId}/users/contractaccess', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EmptyApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_vendor_settings_vendor_v2(self, contract_id, **kwargs):  # noqa: E501
        """Update repricing settings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_vendor_settings_vendor_v2(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.put_vendor_settings_vendor_v2_with_http_info(contract_id, **kwargs)  # noqa: E501

    def put_vendor_settings_vendor_v2_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Update repricing settings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_vendor_settings_vendor_v2_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_vendor_settings_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `put_vendor_settings_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/settings/repricing', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_vendor_shop_mapping_manufacturer_v3(self, contract_id, vendor_id, **kwargs):  # noqa: E501
        """Update vendor for contract and associate shops  # noqa: E501

        Update an existing vendor for a given manufacturer contract and associate shops with the given vendor.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_vendor_shop_mapping_manufacturer_v3(contract_id, vendor_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param int vendor_id: ID of vendor shop mapping (required)
        :param ComPatagonaPricemonitorShareApiPostVendorShopMappingRequestV3 com_patagona_pricemonitor_share_api_post_vendor_shop_mapping_request_v3: Request body for updating an existing vendor and associate shops with it. Please note that at least one shop is required for a successful creation.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: VendorShopMappingV3ApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.put_vendor_shop_mapping_manufacturer_v3_with_http_info(contract_id, vendor_id, **kwargs)  # noqa: E501

    def put_vendor_shop_mapping_manufacturer_v3_with_http_info(self, contract_id, vendor_id, **kwargs):  # noqa: E501
        """Update vendor for contract and associate shops  # noqa: E501

        Update an existing vendor for a given manufacturer contract and associate shops with the given vendor.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_vendor_shop_mapping_manufacturer_v3_with_http_info(contract_id, vendor_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param int vendor_id: ID of vendor shop mapping (required)
        :param ComPatagonaPricemonitorShareApiPostVendorShopMappingRequestV3 com_patagona_pricemonitor_share_api_post_vendor_shop_mapping_request_v3: Request body for updating an existing vendor and associate shops with it. Please note that at least one shop is required for a successful creation.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(VendorShopMappingV3ApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'vendor_id',
            'com_patagona_pricemonitor_share_api_post_vendor_shop_mapping_request_v3'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_vendor_shop_mapping_manufacturer_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `put_vendor_shop_mapping_manufacturer_v3`")  # noqa: E501
        # verify the required parameter 'vendor_id' is set
        if self.api_client.client_side_validation and ('vendor_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['vendor_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `vendor_id` when calling `put_vendor_shop_mapping_manufacturer_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'vendor_id' in local_var_params:
            path_params['vendorId'] = local_var_params['vendor_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'com_patagona_pricemonitor_share_api_post_vendor_shop_mapping_request_v3' in local_var_params:
            body_params = local_var_params['com_patagona_pricemonitor_share_api_post_vendor_shop_mapping_request_v3']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/manufacturer/contracts/{contractId}/vendors/{vendorId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='VendorShopMappingV3ApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def query_offers_manufacturer_v3(self, contract_id, **kwargs):  # noqa: E501
        """Query offers [manufacturer]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.query_offers_manufacturer_v3(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.query_offers_manufacturer_v3_with_http_info(contract_id, **kwargs)  # noqa: E501

    def query_offers_manufacturer_v3_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Query offers [manufacturer]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.query_offers_manufacturer_v3_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method query_offers_manufacturer_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `query_offers_manufacturer_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/manufacturer/contracts/{contractId}/offers/query', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def query_offers_price_dumping_stats_manufacturer_v3(self, contract_id, com_patagona_pricemonitor_share_api_price_dumping_stats_request, **kwargs):  # noqa: E501
        """Query price dumping statistics  # noqa: E501

        This operation is used to query price dumping statistics for a time range for a set of shops.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.query_offers_price_dumping_stats_manufacturer_v3(contract_id, com_patagona_pricemonitor_share_api_price_dumping_stats_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param ComPatagonaPricemonitorShareApiPriceDumpingStatsRequest com_patagona_pricemonitor_share_api_price_dumping_stats_request: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: QueryPriceDumpingStatsApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.query_offers_price_dumping_stats_manufacturer_v3_with_http_info(contract_id, com_patagona_pricemonitor_share_api_price_dumping_stats_request, **kwargs)  # noqa: E501

    def query_offers_price_dumping_stats_manufacturer_v3_with_http_info(self, contract_id, com_patagona_pricemonitor_share_api_price_dumping_stats_request, **kwargs):  # noqa: E501
        """Query price dumping statistics  # noqa: E501

        This operation is used to query price dumping statistics for a time range for a set of shops.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.query_offers_price_dumping_stats_manufacturer_v3_with_http_info(contract_id, com_patagona_pricemonitor_share_api_price_dumping_stats_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param ComPatagonaPricemonitorShareApiPriceDumpingStatsRequest com_patagona_pricemonitor_share_api_price_dumping_stats_request: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(QueryPriceDumpingStatsApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'com_patagona_pricemonitor_share_api_price_dumping_stats_request'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method query_offers_price_dumping_stats_manufacturer_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `query_offers_price_dumping_stats_manufacturer_v3`")  # noqa: E501
        # verify the required parameter 'com_patagona_pricemonitor_share_api_price_dumping_stats_request' is set
        if self.api_client.client_side_validation and ('com_patagona_pricemonitor_share_api_price_dumping_stats_request' not in local_var_params or  # noqa: E501
                                                        local_var_params['com_patagona_pricemonitor_share_api_price_dumping_stats_request'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `com_patagona_pricemonitor_share_api_price_dumping_stats_request` when calling `query_offers_price_dumping_stats_manufacturer_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'com_patagona_pricemonitor_share_api_price_dumping_stats_request' in local_var_params:
            body_params = local_var_params['com_patagona_pricemonitor_share_api_price_dumping_stats_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/manufacturer/contracts/{contractId}/offers/pricedumpingstats', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='QueryPriceDumpingStatsApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def query_offers_price_dumping_stats_vendor_v3(self, contract_id, com_patagona_pricemonitor_share_api_price_dumping_stats_request, **kwargs):  # noqa: E501
        """Query price dumping statistics  # noqa: E501

        This operation is used to query price dumping statistics for a time range for a set of shops.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.query_offers_price_dumping_stats_vendor_v3(contract_id, com_patagona_pricemonitor_share_api_price_dumping_stats_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param ComPatagonaPricemonitorShareApiPriceDumpingStatsRequest com_patagona_pricemonitor_share_api_price_dumping_stats_request: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: QueryPriceDumpingStatsApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.query_offers_price_dumping_stats_vendor_v3_with_http_info(contract_id, com_patagona_pricemonitor_share_api_price_dumping_stats_request, **kwargs)  # noqa: E501

    def query_offers_price_dumping_stats_vendor_v3_with_http_info(self, contract_id, com_patagona_pricemonitor_share_api_price_dumping_stats_request, **kwargs):  # noqa: E501
        """Query price dumping statistics  # noqa: E501

        This operation is used to query price dumping statistics for a time range for a set of shops.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.query_offers_price_dumping_stats_vendor_v3_with_http_info(contract_id, com_patagona_pricemonitor_share_api_price_dumping_stats_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param ComPatagonaPricemonitorShareApiPriceDumpingStatsRequest com_patagona_pricemonitor_share_api_price_dumping_stats_request: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(QueryPriceDumpingStatsApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'com_patagona_pricemonitor_share_api_price_dumping_stats_request'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method query_offers_price_dumping_stats_vendor_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `query_offers_price_dumping_stats_vendor_v3`")  # noqa: E501
        # verify the required parameter 'com_patagona_pricemonitor_share_api_price_dumping_stats_request' is set
        if self.api_client.client_side_validation and ('com_patagona_pricemonitor_share_api_price_dumping_stats_request' not in local_var_params or  # noqa: E501
                                                        local_var_params['com_patagona_pricemonitor_share_api_price_dumping_stats_request'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `com_patagona_pricemonitor_share_api_price_dumping_stats_request` when calling `query_offers_price_dumping_stats_vendor_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'com_patagona_pricemonitor_share_api_price_dumping_stats_request' in local_var_params:
            body_params = local_var_params['com_patagona_pricemonitor_share_api_price_dumping_stats_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/vendor/contracts/{contractId}/offers/pricedumpingstats', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='QueryPriceDumpingStatsApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def query_offers_shop_manufacturer_v3(self, contract_id, com_patagona_pricemonitor_share_api_query_offers_of_shop_request_v3, **kwargs):  # noqa: E501
        """Get all offers [manufacturer]  # noqa: E501

        Get all offers of a shop. Please note that it might return offers for inactive products.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.query_offers_shop_manufacturer_v3(contract_id, com_patagona_pricemonitor_share_api_query_offers_of_shop_request_v3, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param ComPatagonaPricemonitorShareApiQueryOffersOfShopRequestV3 com_patagona_pricemonitor_share_api_query_offers_of_shop_request_v3: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: QueryOffersOfShopV3ApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.query_offers_shop_manufacturer_v3_with_http_info(contract_id, com_patagona_pricemonitor_share_api_query_offers_of_shop_request_v3, **kwargs)  # noqa: E501

    def query_offers_shop_manufacturer_v3_with_http_info(self, contract_id, com_patagona_pricemonitor_share_api_query_offers_of_shop_request_v3, **kwargs):  # noqa: E501
        """Get all offers [manufacturer]  # noqa: E501

        Get all offers of a shop. Please note that it might return offers for inactive products.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.query_offers_shop_manufacturer_v3_with_http_info(contract_id, com_patagona_pricemonitor_share_api_query_offers_of_shop_request_v3, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param ComPatagonaPricemonitorShareApiQueryOffersOfShopRequestV3 com_patagona_pricemonitor_share_api_query_offers_of_shop_request_v3: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(QueryOffersOfShopV3ApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'com_patagona_pricemonitor_share_api_query_offers_of_shop_request_v3'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method query_offers_shop_manufacturer_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `query_offers_shop_manufacturer_v3`")  # noqa: E501
        # verify the required parameter 'com_patagona_pricemonitor_share_api_query_offers_of_shop_request_v3' is set
        if self.api_client.client_side_validation and ('com_patagona_pricemonitor_share_api_query_offers_of_shop_request_v3' not in local_var_params or  # noqa: E501
                                                        local_var_params['com_patagona_pricemonitor_share_api_query_offers_of_shop_request_v3'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `com_patagona_pricemonitor_share_api_query_offers_of_shop_request_v3` when calling `query_offers_shop_manufacturer_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'com_patagona_pricemonitor_share_api_query_offers_of_shop_request_v3' in local_var_params:
            body_params = local_var_params['com_patagona_pricemonitor_share_api_query_offers_of_shop_request_v3']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/manufacturer/contracts/{contractId}/offers/shop/query', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='QueryOffersOfShopV3ApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def query_offers_shop_vendor_v3(self, contract_id, com_patagona_pricemonitor_share_api_query_offers_of_shop_request_v3, **kwargs):  # noqa: E501
        """Get all offers [vendor]  # noqa: E501

        Get all offers of a shop. Please note that it might return offers for inactive products.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.query_offers_shop_vendor_v3(contract_id, com_patagona_pricemonitor_share_api_query_offers_of_shop_request_v3, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param ComPatagonaPricemonitorShareApiQueryOffersOfShopRequestV3 com_patagona_pricemonitor_share_api_query_offers_of_shop_request_v3: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: QueryOffersOfShopV3ApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.query_offers_shop_vendor_v3_with_http_info(contract_id, com_patagona_pricemonitor_share_api_query_offers_of_shop_request_v3, **kwargs)  # noqa: E501

    def query_offers_shop_vendor_v3_with_http_info(self, contract_id, com_patagona_pricemonitor_share_api_query_offers_of_shop_request_v3, **kwargs):  # noqa: E501
        """Get all offers [vendor]  # noqa: E501

        Get all offers of a shop. Please note that it might return offers for inactive products.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.query_offers_shop_vendor_v3_with_http_info(contract_id, com_patagona_pricemonitor_share_api_query_offers_of_shop_request_v3, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param ComPatagonaPricemonitorShareApiQueryOffersOfShopRequestV3 com_patagona_pricemonitor_share_api_query_offers_of_shop_request_v3: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(QueryOffersOfShopV3ApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'com_patagona_pricemonitor_share_api_query_offers_of_shop_request_v3'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method query_offers_shop_vendor_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `query_offers_shop_vendor_v3`")  # noqa: E501
        # verify the required parameter 'com_patagona_pricemonitor_share_api_query_offers_of_shop_request_v3' is set
        if self.api_client.client_side_validation and ('com_patagona_pricemonitor_share_api_query_offers_of_shop_request_v3' not in local_var_params or  # noqa: E501
                                                        local_var_params['com_patagona_pricemonitor_share_api_query_offers_of_shop_request_v3'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `com_patagona_pricemonitor_share_api_query_offers_of_shop_request_v3` when calling `query_offers_shop_vendor_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'com_patagona_pricemonitor_share_api_query_offers_of_shop_request_v3' in local_var_params:
            body_params = local_var_params['com_patagona_pricemonitor_share_api_query_offers_of_shop_request_v3']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/vendor/contracts/{contractId}/offers/shop/query', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='QueryOffersOfShopV3ApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def query_offers_stats_manufacturer_v3(self, contract_id, post_offer_statistics_request, **kwargs):  # noqa: E501
        """Query offer statistics per product  # noqa: E501

        This operation is used to get offer statistics (e.g. offer count, average price) grouped by product and domain. Warning: This endpoint contains complex query structure and will be replaced in the future. Please note that offer statistics can only be computed for at maximum 2500 products at a time.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.query_offers_stats_manufacturer_v3(contract_id, post_offer_statistics_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param PostOfferStatisticsRequest post_offer_statistics_request: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: PostOfferStatisticsApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.query_offers_stats_manufacturer_v3_with_http_info(contract_id, post_offer_statistics_request, **kwargs)  # noqa: E501

    def query_offers_stats_manufacturer_v3_with_http_info(self, contract_id, post_offer_statistics_request, **kwargs):  # noqa: E501
        """Query offer statistics per product  # noqa: E501

        This operation is used to get offer statistics (e.g. offer count, average price) grouped by product and domain. Warning: This endpoint contains complex query structure and will be replaced in the future. Please note that offer statistics can only be computed for at maximum 2500 products at a time.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.query_offers_stats_manufacturer_v3_with_http_info(contract_id, post_offer_statistics_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param PostOfferStatisticsRequest post_offer_statistics_request: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(PostOfferStatisticsApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'post_offer_statistics_request'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method query_offers_stats_manufacturer_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `query_offers_stats_manufacturer_v3`")  # noqa: E501
        # verify the required parameter 'post_offer_statistics_request' is set
        if self.api_client.client_side_validation and ('post_offer_statistics_request' not in local_var_params or  # noqa: E501
                                                        local_var_params['post_offer_statistics_request'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `post_offer_statistics_request` when calling `query_offers_stats_manufacturer_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'post_offer_statistics_request' in local_var_params:
            body_params = local_var_params['post_offer_statistics_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/manufacturer/contracts/{contractId}/offers/stats/query', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PostOfferStatisticsApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def query_offers_stats_manufacturer_v31(self, contract_id, **kwargs):  # noqa: E501
        """Query offer statistics per product  # noqa: E501

        This endpoint can be used to query offer statistics (e.g. offer count, average price) grouped by product. Only the most recent market data is considered per product and domain.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.query_offers_stats_manufacturer_v31(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param ComPatagonaPricemonitorShareApiPostOfferStatisticsRequestV31 com_patagona_pricemonitor_share_api_post_offer_statistics_request_v31: The request body may include an optional products query. If omitted, all products are queried. Currently, product queries can be performed on two attributes:   - \"customerProductId\"   - \"productId\" (Patagona's internal product id; must be a numerical integer)  Pagination is supported with a maximum limit of 10,000. For optimized performance:   - Use a limit of 10,000 products per page when querying all products of a contract.   - Prefer using \"productId\" for queries when a product query is utilized.  Pagination operates based on the provided products query. This is particularly useful when querying a set of customerProductId's. For chunked requests over a set of ids, it's straightforward to specify up to 10,000 customerProductId's in the query with pagination set at start: 0, limit: 10,000. The allowed query pattern is structured as follows: ``` json {   \"pagination\": {     \"start\": ${start},     \"limit\": ${limit}   },   \"range\": {     \"start\": ${start},     \"end\": ${end}   },   \"filter\": {     \"oneOf\": {       \"field\": \"customerProductId\",       \"values\": [${customerProductIds as a list of strings}]     }   } } ```
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: QueryOfferStatisticsV31ApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.query_offers_stats_manufacturer_v31_with_http_info(contract_id, **kwargs)  # noqa: E501

    def query_offers_stats_manufacturer_v31_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Query offer statistics per product  # noqa: E501

        This endpoint can be used to query offer statistics (e.g. offer count, average price) grouped by product. Only the most recent market data is considered per product and domain.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.query_offers_stats_manufacturer_v31_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param ComPatagonaPricemonitorShareApiPostOfferStatisticsRequestV31 com_patagona_pricemonitor_share_api_post_offer_statistics_request_v31: The request body may include an optional products query. If omitted, all products are queried. Currently, product queries can be performed on two attributes:   - \"customerProductId\"   - \"productId\" (Patagona's internal product id; must be a numerical integer)  Pagination is supported with a maximum limit of 10,000. For optimized performance:   - Use a limit of 10,000 products per page when querying all products of a contract.   - Prefer using \"productId\" for queries when a product query is utilized.  Pagination operates based on the provided products query. This is particularly useful when querying a set of customerProductId's. For chunked requests over a set of ids, it's straightforward to specify up to 10,000 customerProductId's in the query with pagination set at start: 0, limit: 10,000. The allowed query pattern is structured as follows: ``` json {   \"pagination\": {     \"start\": ${start},     \"limit\": ${limit}   },   \"range\": {     \"start\": ${start},     \"end\": ${end}   },   \"filter\": {     \"oneOf\": {       \"field\": \"customerProductId\",       \"values\": [${customerProductIds as a list of strings}]     }   } } ```
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(QueryOfferStatisticsV31ApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'com_patagona_pricemonitor_share_api_post_offer_statistics_request_v31'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method query_offers_stats_manufacturer_v31" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `query_offers_stats_manufacturer_v31`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'com_patagona_pricemonitor_share_api_post_offer_statistics_request_v31' in local_var_params:
            body_params = local_var_params['com_patagona_pricemonitor_share_api_post_offer_statistics_request_v31']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3.1/manufacturer/contracts/{contractId}/offers/stats/query', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='QueryOfferStatisticsV31ApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def query_price_recommendations_vendor_v2(self, contract_id, **kwargs):  # noqa: E501
        """Query price recommendations  # noqa: E501

        This endpoint is used to query certain price recommendations. It supports a rather complex filtering structure. Most commonly it's used for querying by our internal product id.  Here you can find an example request body for querying one product id (here `123456`):  <details> <summary>Click to expand</summary>  ``` json {   \"pagination\": {     \"start\": 0,     \"limit\": 500   },   \"range\": {     \"start\": \"2023-01-07T12:05:01.000Z\",     \"end\": \"2023-01-09T12:05:01.000Z\"   },   \"filter\": {     \"filters\": [{       \"left\": {         \"attributeName\": \"productId\",         \"type\": \"StringValueProvider\"       },       \"right\": {         \"value\": \"123456\",         \"type\": \"StringConstantValueProvider\"       },       \"comparison\": {         \"type\": \"StringEquality\"       },       \"type\": \"ComparisonFilter\"     }],     \"type\": \"OrFilter\"   } } ``` </details>  If you want to query for multiple product ids, then you need to provide one object per product id in the filters-array.  It's recommended to query for at most 1000 price recommendations at once.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.query_price_recommendations_vendor_v2(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param PriceRecommendationApiQueryV2 price_recommendation_api_query_v2: The request body specifies which price recommendations will be searched for.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: QueryPriceRecommendationsV2ApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.query_price_recommendations_vendor_v2_with_http_info(contract_id, **kwargs)  # noqa: E501

    def query_price_recommendations_vendor_v2_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Query price recommendations  # noqa: E501

        This endpoint is used to query certain price recommendations. It supports a rather complex filtering structure. Most commonly it's used for querying by our internal product id.  Here you can find an example request body for querying one product id (here `123456`):  <details> <summary>Click to expand</summary>  ``` json {   \"pagination\": {     \"start\": 0,     \"limit\": 500   },   \"range\": {     \"start\": \"2023-01-07T12:05:01.000Z\",     \"end\": \"2023-01-09T12:05:01.000Z\"   },   \"filter\": {     \"filters\": [{       \"left\": {         \"attributeName\": \"productId\",         \"type\": \"StringValueProvider\"       },       \"right\": {         \"value\": \"123456\",         \"type\": \"StringConstantValueProvider\"       },       \"comparison\": {         \"type\": \"StringEquality\"       },       \"type\": \"ComparisonFilter\"     }],     \"type\": \"OrFilter\"   } } ``` </details>  If you want to query for multiple product ids, then you need to provide one object per product id in the filters-array.  It's recommended to query for at most 1000 price recommendations at once.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.query_price_recommendations_vendor_v2_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param PriceRecommendationApiQueryV2 price_recommendation_api_query_v2: The request body specifies which price recommendations will be searched for.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(QueryPriceRecommendationsV2ApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'price_recommendation_api_query_v2'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method query_price_recommendations_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `query_price_recommendations_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'price_recommendation_api_query_v2' in local_var_params:
            body_params = local_var_params['price_recommendation_api_query_v2']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/result/pricerecommendations/query', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='QueryPriceRecommendationsV2ApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def query_products_by_filter_manufacturer_v3(self, contract_id, **kwargs):  # noqa: E501
        """Get products of a contract  # noqa: E501

        This endpoint can be used for querying either all products or certain products by product ids.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.query_products_by_filter_manufacturer_v3(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param QueryProductsRequestV3 query_products_request_v3: The body contains the products query.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: QueryProductsByFilterManufacturerV3ApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.query_products_by_filter_manufacturer_v3_with_http_info(contract_id, **kwargs)  # noqa: E501

    def query_products_by_filter_manufacturer_v3_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Get products of a contract  # noqa: E501

        This endpoint can be used for querying either all products or certain products by product ids.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.query_products_by_filter_manufacturer_v3_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param QueryProductsRequestV3 query_products_request_v3: The body contains the products query.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(QueryProductsByFilterManufacturerV3ApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'query_products_request_v3'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method query_products_by_filter_manufacturer_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `query_products_by_filter_manufacturer_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'query_products_request_v3' in local_var_params:
            body_params = local_var_params['query_products_request_v3']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/manufacturer/contracts/{contractId}/products/query', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='QueryProductsByFilterManufacturerV3ApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def query_products_by_filter_vendor_v3(self, contract_id, **kwargs):  # noqa: E501
        """Query products of a contract  # noqa: E501

        This endpoint can be used for querying either all products or certain products by product ids.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.query_products_by_filter_vendor_v3(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param QueryProductsRequestV3 query_products_request_v3: The body contains the products query.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: QueryProductsByFilterVendorV3ApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.query_products_by_filter_vendor_v3_with_http_info(contract_id, **kwargs)  # noqa: E501

    def query_products_by_filter_vendor_v3_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Query products of a contract  # noqa: E501

        This endpoint can be used for querying either all products or certain products by product ids.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.query_products_by_filter_vendor_v3_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param QueryProductsRequestV3 query_products_request_v3: The body contains the products query.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(QueryProductsByFilterVendorV3ApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'query_products_request_v3'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method query_products_by_filter_vendor_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `query_products_by_filter_vendor_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'query_products_request_v3' in local_var_params:
            body_params = local_var_params['query_products_request_v3']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/vendor/contracts/{contractId}/products/query', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='QueryProductsByFilterVendorV3ApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def query_products_manufacturer_v3(self, contract_id, **kwargs):  # noqa: E501
        """Query products for manufacturer  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.query_products_manufacturer_v3(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param ComPatagonaPricemonitorShareApiApiQuery com_patagona_pricemonitor_share_api_api_query: The body contains the products query. <br> Currently, it supports only product queries for two attributes:<br> <ul>   <li> by \"customerProductId\"</li>   <li> by \"productId\" (Patagona's internal product id). Allowed values for 'productId' are numerical integer values</li> </ul> The maximum allowed limit in the pagination is 10000. <br> For better performance, when paginating over all products of a contract, we recommend to use a limit of 10000 products per page. Pagination works with respective to the given products query. <br> This is most relevant when querying for a set of customerProductId's. <br> When the requests are chunked over a set of ids, it is easiest to provide up to 10000 customerProductId's in the query and keep the pagination at start: 0, limit: 10000. <br> The only allowed pattern is currently: <br> { <br> &nbsp;&nbsp;\"pagination\": { <br> &nbsp;&nbsp;&nbsp;&nbsp;\"start\": ${start}, <br> &nbsp;&nbsp;&nbsp;&nbsp;\"limit\": ${limit} <br> &nbsp;&nbsp;}, <br> &nbsp;&nbsp;\"filter\": { <br> &nbsp;&nbsp;&nbsp;&nbsp;\"oneOf\": { <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"field\": \"customerProductId\", <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"values\": [${customerProductIds as a list of strings}] <br> &nbsp;&nbsp;&nbsp;&nbsp;} <br> &nbsp;&nbsp;} <br> } <br> <br> example: <br> { <br> &nbsp;&nbsp;\"pagination\": { <br> &nbsp;&nbsp;&nbsp;&nbsp;\"start\": 0, <br> &nbsp;&nbsp;&nbsp;&nbsp;\"limit\": 10 <br> &nbsp;&nbsp;}, <br> &nbsp;&nbsp;\"filter\": { <br> &nbsp;&nbsp;\"oneOf\": { <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"field\": \"customerProductId\", <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"values\": [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\"] <br> &nbsp;&nbsp;&nbsp;&nbsp;} <br> &nbsp;&nbsp;} <br> } <br> 
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: QueryProductsManufacturerV3ApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.query_products_manufacturer_v3_with_http_info(contract_id, **kwargs)  # noqa: E501

    def query_products_manufacturer_v3_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Query products for manufacturer  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.query_products_manufacturer_v3_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param ComPatagonaPricemonitorShareApiApiQuery com_patagona_pricemonitor_share_api_api_query: The body contains the products query. <br> Currently, it supports only product queries for two attributes:<br> <ul>   <li> by \"customerProductId\"</li>   <li> by \"productId\" (Patagona's internal product id). Allowed values for 'productId' are numerical integer values</li> </ul> The maximum allowed limit in the pagination is 10000. <br> For better performance, when paginating over all products of a contract, we recommend to use a limit of 10000 products per page. Pagination works with respective to the given products query. <br> This is most relevant when querying for a set of customerProductId's. <br> When the requests are chunked over a set of ids, it is easiest to provide up to 10000 customerProductId's in the query and keep the pagination at start: 0, limit: 10000. <br> The only allowed pattern is currently: <br> { <br> &nbsp;&nbsp;\"pagination\": { <br> &nbsp;&nbsp;&nbsp;&nbsp;\"start\": ${start}, <br> &nbsp;&nbsp;&nbsp;&nbsp;\"limit\": ${limit} <br> &nbsp;&nbsp;}, <br> &nbsp;&nbsp;\"filter\": { <br> &nbsp;&nbsp;&nbsp;&nbsp;\"oneOf\": { <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"field\": \"customerProductId\", <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"values\": [${customerProductIds as a list of strings}] <br> &nbsp;&nbsp;&nbsp;&nbsp;} <br> &nbsp;&nbsp;} <br> } <br> <br> example: <br> { <br> &nbsp;&nbsp;\"pagination\": { <br> &nbsp;&nbsp;&nbsp;&nbsp;\"start\": 0, <br> &nbsp;&nbsp;&nbsp;&nbsp;\"limit\": 10 <br> &nbsp;&nbsp;}, <br> &nbsp;&nbsp;\"filter\": { <br> &nbsp;&nbsp;\"oneOf\": { <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"field\": \"customerProductId\", <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"values\": [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\"] <br> &nbsp;&nbsp;&nbsp;&nbsp;} <br> &nbsp;&nbsp;} <br> } <br> 
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(QueryProductsManufacturerV3ApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'com_patagona_pricemonitor_share_api_api_query'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method query_products_manufacturer_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `query_products_manufacturer_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'com_patagona_pricemonitor_share_api_api_query' in local_var_params:
            body_params = local_var_params['com_patagona_pricemonitor_share_api_api_query']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3.1/manufacturer/contracts/{contractId}/products/query', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='QueryProductsManufacturerV3ApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def raw_offers(self, contract_id, start, limit, **kwargs):  # noqa: E501
        """Get offers for contract  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.raw_offers(contract_id, start, limit, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param int start: (required)
        :param int limit: (required)
        :param datetime since:
        :param datetime until:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.raw_offers_with_http_info(contract_id, start, limit, **kwargs)  # noqa: E501

    def raw_offers_with_http_info(self, contract_id, start, limit, **kwargs):  # noqa: E501
        """Get offers for contract  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.raw_offers_with_http_info(contract_id, start, limit, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param int start: (required)
        :param int limit: (required)
        :param datetime since:
        :param datetime until:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'start',
            'limit',
            'since',
            'until'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method raw_offers" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `raw_offers`")  # noqa: E501
        # verify the required parameter 'start' is set
        if self.api_client.client_side_validation and ('start' not in local_var_params or  # noqa: E501
                                                        local_var_params['start'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `start` when calling `raw_offers`")  # noqa: E501
        # verify the required parameter 'limit' is set
        if self.api_client.client_side_validation and ('limit' not in local_var_params or  # noqa: E501
                                                        local_var_params['limit'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `limit` when calling `raw_offers`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []
        if 'start' in local_var_params and local_var_params['start'] is not None:  # noqa: E501
            query_params.append(('start', local_var_params['start']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'since' in local_var_params and local_var_params['since'] is not None:  # noqa: E501
            query_params.append(('since', local_var_params['since']))  # noqa: E501
        if 'until' in local_var_params and local_var_params['until'] is not None:  # noqa: E501
            query_params.append(('until', local_var_params['until']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/1/{contractId}/products/offers', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remove_user(self, company_id, user_id, **kwargs):  # noqa: E501
        """Remove user from company  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_user(company_id, user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int company_id: ID of a company (required)
        :param int user_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.remove_user_with_http_info(company_id, user_id, **kwargs)  # noqa: E501

    def remove_user_with_http_info(self, company_id, user_id, **kwargs):  # noqa: E501
        """Remove user from company  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_user_with_http_info(company_id, user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int company_id: ID of a company (required)
        :param int user_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'company_id',
            'user_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remove_user" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'company_id' is set
        if self.api_client.client_side_validation and ('company_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['company_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `company_id` when calling `remove_user`")  # noqa: E501
        # verify the required parameter 'user_id' is set
        if self.api_client.client_side_validation and ('user_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['user_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `user_id` when calling `remove_user`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'company_id' in local_var_params:
            path_params['companyId'] = local_var_params['company_id']  # noqa: E501
        if 'user_id' in local_var_params:
            path_params['userId'] = local_var_params['user_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/controlpanel/api/companies/{companyId}/users/{userId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def request_new_password(self, **kwargs):  # noqa: E501
        """Request a new password  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.request_new_password(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param ComPatagonaPricemonitorShareApiPostNewPasswordRequest com_patagona_pricemonitor_share_api_post_new_password_request: Request a new password.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.request_new_password_with_http_info(**kwargs)  # noqa: E501

    def request_new_password_with_http_info(self, **kwargs):  # noqa: E501
        """Request a new password  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.request_new_password_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param ComPatagonaPricemonitorShareApiPostNewPasswordRequest com_patagona_pricemonitor_share_api_post_new_password_request: Request a new password.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(str, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'com_patagona_pricemonitor_share_api_post_new_password_request'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method request_new_password" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'com_patagona_pricemonitor_share_api_post_new_password_request' in local_var_params:
            body_params = local_var_params['com_patagona_pricemonitor_share_api_post_new_password_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/account/password/reset', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def reset_password(self, **kwargs):  # noqa: E501
        """Reset the password  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.reset_password(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param ComPatagonaPricemonitorShareApiPutResetPasswordRequest com_patagona_pricemonitor_share_api_put_reset_password_request: Reset a password
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.reset_password_with_http_info(**kwargs)  # noqa: E501

    def reset_password_with_http_info(self, **kwargs):  # noqa: E501
        """Reset the password  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.reset_password_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param ComPatagonaPricemonitorShareApiPutResetPasswordRequest com_patagona_pricemonitor_share_api_put_reset_password_request: Reset a password
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(str, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'com_patagona_pricemonitor_share_api_put_reset_password_request'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method reset_password" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'com_patagona_pricemonitor_share_api_put_reset_password_request' in local_var_params:
            body_params = local_var_params['com_patagona_pricemonitor_share_api_put_reset_password_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/account/password/reset', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def save_include_delivery_costs(self, contract_id, **kwargs):  # noqa: E501
        """Update includes delivery costs setting  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.save_include_delivery_costs(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.save_include_delivery_costs_with_http_info(contract_id, **kwargs)  # noqa: E501

    def save_include_delivery_costs_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Update includes delivery costs setting  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.save_include_delivery_costs_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method save_include_delivery_costs" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `save_include_delivery_costs`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/1/{contractId}/settings/include_delivery_costs', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def scheduler_delete_request_manufacturer_v3(self, contract_id, path, **kwargs):  # noqa: E501
        """Delete scheduler operation [manufacturer]  # noqa: E501

        The DELETE request is proxied to the internal Scheduler API.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.scheduler_delete_request_manufacturer_v3(contract_id, path, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str path: The scheduler path to be called (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.scheduler_delete_request_manufacturer_v3_with_http_info(contract_id, path, **kwargs)  # noqa: E501

    def scheduler_delete_request_manufacturer_v3_with_http_info(self, contract_id, path, **kwargs):  # noqa: E501
        """Delete scheduler operation [manufacturer]  # noqa: E501

        The DELETE request is proxied to the internal Scheduler API.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.scheduler_delete_request_manufacturer_v3_with_http_info(contract_id, path, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str path: The scheduler path to be called (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'path'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method scheduler_delete_request_manufacturer_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `scheduler_delete_request_manufacturer_v3`")  # noqa: E501
        # verify the required parameter 'path' is set
        if self.api_client.client_side_validation and ('path' not in local_var_params or  # noqa: E501
                                                        local_var_params['path'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `path` when calling `scheduler_delete_request_manufacturer_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'path' in local_var_params:
            path_params['path'] = local_var_params['path']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/manufacturer/contracts/{contractId}/scheduler/{path}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def scheduler_delete_request_vendor_v3(self, contract_id, path, **kwargs):  # noqa: E501
        """Delete scheduler operation  # noqa: E501

        The DELETE request is proxied to the internal Scheduler API.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.scheduler_delete_request_vendor_v3(contract_id, path, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str path: The scheduler path to be called (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.scheduler_delete_request_vendor_v3_with_http_info(contract_id, path, **kwargs)  # noqa: E501

    def scheduler_delete_request_vendor_v3_with_http_info(self, contract_id, path, **kwargs):  # noqa: E501
        """Delete scheduler operation  # noqa: E501

        The DELETE request is proxied to the internal Scheduler API.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.scheduler_delete_request_vendor_v3_with_http_info(contract_id, path, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str path: The scheduler path to be called (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'path'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method scheduler_delete_request_vendor_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `scheduler_delete_request_vendor_v3`")  # noqa: E501
        # verify the required parameter 'path' is set
        if self.api_client.client_side_validation and ('path' not in local_var_params or  # noqa: E501
                                                        local_var_params['path'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `path` when calling `scheduler_delete_request_vendor_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'path' in local_var_params:
            path_params['path'] = local_var_params['path']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/vendor/contracts/{contractId}/scheduler/{path}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def scheduler_get_request_manufacturer_v3(self, contract_id, path, **kwargs):  # noqa: E501
        """Get scheduler operation [manufacturer]  # noqa: E501

        The GET request is proxied to the internal Scheduler API.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.scheduler_get_request_manufacturer_v3(contract_id, path, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str path: The scheduler path to be called (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.scheduler_get_request_manufacturer_v3_with_http_info(contract_id, path, **kwargs)  # noqa: E501

    def scheduler_get_request_manufacturer_v3_with_http_info(self, contract_id, path, **kwargs):  # noqa: E501
        """Get scheduler operation [manufacturer]  # noqa: E501

        The GET request is proxied to the internal Scheduler API.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.scheduler_get_request_manufacturer_v3_with_http_info(contract_id, path, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str path: The scheduler path to be called (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'path'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method scheduler_get_request_manufacturer_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `scheduler_get_request_manufacturer_v3`")  # noqa: E501
        # verify the required parameter 'path' is set
        if self.api_client.client_side_validation and ('path' not in local_var_params or  # noqa: E501
                                                        local_var_params['path'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `path` when calling `scheduler_get_request_manufacturer_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'path' in local_var_params:
            path_params['path'] = local_var_params['path']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/manufacturer/contracts/{contractId}/scheduler/{path}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def scheduler_get_request_vendor_v3(self, contract_id, path, **kwargs):  # noqa: E501
        """Get scheduler operation [vendor]  # noqa: E501

        The GET request is proxied to the internal Scheduler API.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.scheduler_get_request_vendor_v3(contract_id, path, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str path: The scheduler path to be called (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.scheduler_get_request_vendor_v3_with_http_info(contract_id, path, **kwargs)  # noqa: E501

    def scheduler_get_request_vendor_v3_with_http_info(self, contract_id, path, **kwargs):  # noqa: E501
        """Get scheduler operation [vendor]  # noqa: E501

        The GET request is proxied to the internal Scheduler API.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.scheduler_get_request_vendor_v3_with_http_info(contract_id, path, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str path: The scheduler path to be called (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'path'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method scheduler_get_request_vendor_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `scheduler_get_request_vendor_v3`")  # noqa: E501
        # verify the required parameter 'path' is set
        if self.api_client.client_side_validation and ('path' not in local_var_params or  # noqa: E501
                                                        local_var_params['path'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `path` when calling `scheduler_get_request_vendor_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'path' in local_var_params:
            path_params['path'] = local_var_params['path']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/vendor/contracts/{contractId}/scheduler/{path}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def scheduler_post_request_manufacturer_v3(self, contract_id, path, **kwargs):  # noqa: E501
        """Create scheduler operation [manufacturer]  # noqa: E501

        The POST request is proxied to the internal Scheduler API.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.scheduler_post_request_manufacturer_v3(contract_id, path, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str path: The scheduler path to be called (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.scheduler_post_request_manufacturer_v3_with_http_info(contract_id, path, **kwargs)  # noqa: E501

    def scheduler_post_request_manufacturer_v3_with_http_info(self, contract_id, path, **kwargs):  # noqa: E501
        """Create scheduler operation [manufacturer]  # noqa: E501

        The POST request is proxied to the internal Scheduler API.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.scheduler_post_request_manufacturer_v3_with_http_info(contract_id, path, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str path: The scheduler path to be called (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'path'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method scheduler_post_request_manufacturer_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `scheduler_post_request_manufacturer_v3`")  # noqa: E501
        # verify the required parameter 'path' is set
        if self.api_client.client_side_validation and ('path' not in local_var_params or  # noqa: E501
                                                        local_var_params['path'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `path` when calling `scheduler_post_request_manufacturer_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'path' in local_var_params:
            path_params['path'] = local_var_params['path']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/manufacturer/contracts/{contractId}/scheduler/{path}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def scheduler_post_request_vendor_v3(self, contract_id, path, **kwargs):  # noqa: E501
        """Create scheduler operation  # noqa: E501

        The POST request is proxied to the internal Scheduler API.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.scheduler_post_request_vendor_v3(contract_id, path, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str path: The scheduler path to be called (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.scheduler_post_request_vendor_v3_with_http_info(contract_id, path, **kwargs)  # noqa: E501

    def scheduler_post_request_vendor_v3_with_http_info(self, contract_id, path, **kwargs):  # noqa: E501
        """Create scheduler operation  # noqa: E501

        The POST request is proxied to the internal Scheduler API.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.scheduler_post_request_vendor_v3_with_http_info(contract_id, path, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str path: The scheduler path to be called (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'path'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method scheduler_post_request_vendor_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `scheduler_post_request_vendor_v3`")  # noqa: E501
        # verify the required parameter 'path' is set
        if self.api_client.client_side_validation and ('path' not in local_var_params or  # noqa: E501
                                                        local_var_params['path'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `path` when calling `scheduler_post_request_vendor_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'path' in local_var_params:
            path_params['path'] = local_var_params['path']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/vendor/contracts/{contractId}/scheduler/{path}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def scheduler_put_request_manufacturer_v3(self, contract_id, path, **kwargs):  # noqa: E501
        """Update scheduler operation [manufacturer]  # noqa: E501

        The PUT request is proxied to the internal Scheduler API.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.scheduler_put_request_manufacturer_v3(contract_id, path, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str path: The scheduler path to be called (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.scheduler_put_request_manufacturer_v3_with_http_info(contract_id, path, **kwargs)  # noqa: E501

    def scheduler_put_request_manufacturer_v3_with_http_info(self, contract_id, path, **kwargs):  # noqa: E501
        """Update scheduler operation [manufacturer]  # noqa: E501

        The PUT request is proxied to the internal Scheduler API.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.scheduler_put_request_manufacturer_v3_with_http_info(contract_id, path, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str path: The scheduler path to be called (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'path'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method scheduler_put_request_manufacturer_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `scheduler_put_request_manufacturer_v3`")  # noqa: E501
        # verify the required parameter 'path' is set
        if self.api_client.client_side_validation and ('path' not in local_var_params or  # noqa: E501
                                                        local_var_params['path'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `path` when calling `scheduler_put_request_manufacturer_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'path' in local_var_params:
            path_params['path'] = local_var_params['path']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/manufacturer/contracts/{contractId}/scheduler/{path}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def scheduler_put_request_vendor_v3(self, contract_id, path, **kwargs):  # noqa: E501
        """Update scheduler operation  # noqa: E501

        The PUT request is proxied to the internal Scheduler API.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.scheduler_put_request_vendor_v3(contract_id, path, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str path: The scheduler path to be called (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.scheduler_put_request_vendor_v3_with_http_info(contract_id, path, **kwargs)  # noqa: E501

    def scheduler_put_request_vendor_v3_with_http_info(self, contract_id, path, **kwargs):  # noqa: E501
        """Update scheduler operation  # noqa: E501

        The PUT request is proxied to the internal Scheduler API.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.scheduler_put_request_vendor_v3_with_http_info(contract_id, path, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str path: The scheduler path to be called (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'path'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method scheduler_put_request_vendor_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `scheduler_put_request_vendor_v3`")  # noqa: E501
        # verify the required parameter 'path' is set
        if self.api_client.client_side_validation and ('path' not in local_var_params or  # noqa: E501
                                                        local_var_params['path'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `path` when calling `scheduler_put_request_vendor_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'path' in local_var_params:
            path_params['path'] = local_var_params['path']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/vendor/contracts/{contractId}/scheduler/{path}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def segment_offers_manufacturer_v2(self, contract_id, **kwargs):  # noqa: E501
        """Update segment offers [manufacturer]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.segment_offers_manufacturer_v2(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.segment_offers_manufacturer_v2_with_http_info(contract_id, **kwargs)  # noqa: E501

    def segment_offers_manufacturer_v2_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Update segment offers [manufacturer]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.segment_offers_manufacturer_v2_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method segment_offers_manufacturer_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `segment_offers_manufacturer_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/m/contracts/{contractId}/result/offersegmentation', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def segment_offers_vendor_v2(self, contract_id, **kwargs):  # noqa: E501
        """Update segment offers [vendor]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.segment_offers_vendor_v2(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.segment_offers_vendor_v2_with_http_info(contract_id, **kwargs)  # noqa: E501

    def segment_offers_vendor_v2_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Update segment offers [vendor]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.segment_offers_vendor_v2_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method segment_offers_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `segment_offers_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/result/offersegmentation', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def shop_integration_get_request(self, contract_id, path, **kwargs):  # noqa: E501
        """Get shop integration  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.shop_integration_get_request(contract_id, path, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str path: The shop-integration path to be called (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.shop_integration_get_request_with_http_info(contract_id, path, **kwargs)  # noqa: E501

    def shop_integration_get_request_with_http_info(self, contract_id, path, **kwargs):  # noqa: E501
        """Get shop integration  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.shop_integration_get_request_with_http_info(contract_id, path, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str path: The shop-integration path to be called (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'path'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method shop_integration_get_request" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `shop_integration_get_request`")  # noqa: E501
        # verify the required parameter 'path' is set
        if self.api_client.client_side_validation and ('path' not in local_var_params or  # noqa: E501
                                                        local_var_params['path'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `path` when calling `shop_integration_get_request`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'path' in local_var_params:
            path_params['path'] = local_var_params['path']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/shop-integration/{path}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def shop_integration_post_request(self, contract_id, path, **kwargs):  # noqa: E501
        """Update shop integration  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.shop_integration_post_request(contract_id, path, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str path: The shop-integration path to be called (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.shop_integration_post_request_with_http_info(contract_id, path, **kwargs)  # noqa: E501

    def shop_integration_post_request_with_http_info(self, contract_id, path, **kwargs):  # noqa: E501
        """Update shop integration  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.shop_integration_post_request_with_http_info(contract_id, path, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str path: The shop-integration path to be called (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'path'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method shop_integration_post_request" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `shop_integration_post_request`")  # noqa: E501
        # verify the required parameter 'path' is set
        if self.api_client.client_side_validation and ('path' not in local_var_params or  # noqa: E501
                                                        local_var_params['path'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `path` when calling `shop_integration_post_request`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'path' in local_var_params:
            path_params['path'] = local_var_params['path']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/shop-integration/{path}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def shop_integration_post_request_vendor_v2(self, contract_id, path, **kwargs):  # noqa: E501
        """Update shop integration import  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.shop_integration_post_request_vendor_v2(contract_id, path, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str path: (required)
        :param object body: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.shop_integration_post_request_vendor_v2_with_http_info(contract_id, path, **kwargs)  # noqa: E501

    def shop_integration_post_request_vendor_v2_with_http_info(self, contract_id, path, **kwargs):  # noqa: E501
        """Update shop integration import  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.shop_integration_post_request_vendor_v2_with_http_info(contract_id, path, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str path: (required)
        :param object body: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'path',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method shop_integration_post_request_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `shop_integration_post_request_vendor_v2`")  # noqa: E501
        # verify the required parameter 'path' is set
        if self.api_client.client_side_validation and ('path' not in local_var_params or  # noqa: E501
                                                        local_var_params['path'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `path` when calling `shop_integration_post_request_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []
        if 'path' in local_var_params and local_var_params['path'] is not None:  # noqa: E501
            query_params.append(('path', local_var_params['path']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/products/import', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def stats_manufacturer_v2(self, contract_id, session, **kwargs):  # noqa: E501
        """Get contract statistics [manufacturer]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.stats_manufacturer_v2(contract_id, session, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param datetime session: A ISO 8601 timestamp which marks the end of a 48h time range in which the data is collected (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ComPatagonaPricemonitorShareApiContractStats
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.stats_manufacturer_v2_with_http_info(contract_id, session, **kwargs)  # noqa: E501

    def stats_manufacturer_v2_with_http_info(self, contract_id, session, **kwargs):  # noqa: E501
        """Get contract statistics [manufacturer]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.stats_manufacturer_v2_with_http_info(contract_id, session, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param datetime session: A ISO 8601 timestamp which marks the end of a 48h time range in which the data is collected (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ComPatagonaPricemonitorShareApiContractStats, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'session'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stats_manufacturer_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `stats_manufacturer_v2`")  # noqa: E501
        # verify the required parameter 'session' is set
        if self.api_client.client_side_validation and ('session' not in local_var_params or  # noqa: E501
                                                        local_var_params['session'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `session` when calling `stats_manufacturer_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []
        if 'session' in local_var_params and local_var_params['session'] is not None:  # noqa: E501
            query_params.append(('session', local_var_params['session']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/m/contracts/{contractId}/result/contract/stats', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ComPatagonaPricemonitorShareApiContractStats',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def timestamps_manufacturer_v2(self, contract_id, limit, **kwargs):  # noqa: E501
        """Get timestamps  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.timestamps_manufacturer_v2(contract_id, limit, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param int limit: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.timestamps_manufacturer_v2_with_http_info(contract_id, limit, **kwargs)  # noqa: E501

    def timestamps_manufacturer_v2_with_http_info(self, contract_id, limit, **kwargs):  # noqa: E501
        """Get timestamps  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.timestamps_manufacturer_v2_with_http_info(contract_id, limit, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param int limit: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'limit'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method timestamps_manufacturer_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `timestamps_manufacturer_v2`")  # noqa: E501
        # verify the required parameter 'limit' is set
        if self.api_client.client_side_validation and ('limit' not in local_var_params or  # noqa: E501
                                                        local_var_params['limit'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `limit` when calling `timestamps_manufacturer_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/m/contracts/{contractId}/result/timestamps', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_alert_settings(self, contract_id, alert_id, **kwargs):  # noqa: E501
        """Update alert settings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_alert_settings(contract_id, alert_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str alert_id: (required)
        :param object body: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_alert_settings_with_http_info(contract_id, alert_id, **kwargs)  # noqa: E501

    def update_alert_settings_with_http_info(self, contract_id, alert_id, **kwargs):  # noqa: E501
        """Update alert settings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_alert_settings_with_http_info(contract_id, alert_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str alert_id: (required)
        :param object body: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'alert_id',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_alert_settings" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `update_alert_settings`")  # noqa: E501
        # verify the required parameter 'alert_id' is set
        if self.api_client.client_side_validation and ('alert_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['alert_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `alert_id` when calling `update_alert_settings`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'alert_id' in local_var_params:
            path_params['alertId'] = local_var_params['alert_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/1/{contractId}/settings/alerts/{alertId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_auth_token(self, email, token, **kwargs):  # noqa: E501
        """Update authentication token  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_auth_token(email, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str email: (required)
        :param str token: (required)
        :param object body: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_auth_token_with_http_info(email, token, **kwargs)  # noqa: E501

    def update_auth_token_with_http_info(self, email, token, **kwargs):  # noqa: E501
        """Update authentication token  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_auth_token_with_http_info(email, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str email: (required)
        :param str token: (required)
        :param object body: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'email',
            'token',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_auth_token" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'email' is set
        if self.api_client.client_side_validation and ('email' not in local_var_params or  # noqa: E501
                                                        local_var_params['email'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `email` when calling `update_auth_token`")  # noqa: E501
        # verify the required parameter 'token' is set
        if self.api_client.client_side_validation and ('token' not in local_var_params or  # noqa: E501
                                                        local_var_params['token'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `token` when calling `update_auth_token`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'email' in local_var_params:
            path_params['email'] = local_var_params['email']  # noqa: E501
        if 'token' in local_var_params:
            path_params['token'] = local_var_params['token']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/controlpanel/users/{email}/authtokens/{token}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_task_manufacturer_v2(self, contract_id, task_id, **kwargs):  # noqa: E501
        """Update task [manufacturer]  # noqa: E501

        Update an existing task.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_task_manufacturer_v2(contract_id, task_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str task_id: (required)
        :param UpdateTaskRequestV2 update_task_request_v2: The new task object to be written to the database
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: GenericTask
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_task_manufacturer_v2_with_http_info(contract_id, task_id, **kwargs)  # noqa: E501

    def update_task_manufacturer_v2_with_http_info(self, contract_id, task_id, **kwargs):  # noqa: E501
        """Update task [manufacturer]  # noqa: E501

        Update an existing task.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_task_manufacturer_v2_with_http_info(contract_id, task_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str task_id: (required)
        :param UpdateTaskRequestV2 update_task_request_v2: The new task object to be written to the database
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(GenericTask, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'task_id',
            'update_task_request_v2'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_task_manufacturer_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `update_task_manufacturer_v2`")  # noqa: E501
        # verify the required parameter 'task_id' is set
        if self.api_client.client_side_validation and ('task_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['task_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `task_id` when calling `update_task_manufacturer_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'task_id' in local_var_params:
            path_params['taskId'] = local_var_params['task_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'update_task_request_v2' in local_var_params:
            body_params = local_var_params['update_task_request_v2']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/m/contracts/{contractId}/tasks/{taskId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GenericTask',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_task_vendor_v2(self, contract_id, task_id, **kwargs):  # noqa: E501
        """Update a task  # noqa: E501

        Update the task with the specified id for the given contract.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_task_vendor_v2(contract_id, task_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str task_id: (required)
        :param object body: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_task_vendor_v2_with_http_info(contract_id, task_id, **kwargs)  # noqa: E501

    def update_task_vendor_v2_with_http_info(self, contract_id, task_id, **kwargs):  # noqa: E501
        """Update a task  # noqa: E501

        Update the task with the specified id for the given contract.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_task_vendor_v2_with_http_info(contract_id, task_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str task_id: (required)
        :param object body: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'task_id',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_task_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `update_task_vendor_v2`")  # noqa: E501
        # verify the required parameter 'task_id' is set
        if self.api_client.client_side_validation and ('task_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['task_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `task_id` when calling `update_task_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'task_id' in local_var_params:
            path_params['taskId'] = local_var_params['task_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/tasks/{taskId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_user_role(self, user_id, role_name, **kwargs):  # noqa: E501
        """Add user role  # noqa: E501

        Add the specified role to the given user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_user_role(user_id, role_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int user_id: (required)
        :param str role_name: (required)
        :param object body: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_user_role_with_http_info(user_id, role_name, **kwargs)  # noqa: E501

    def update_user_role_with_http_info(self, user_id, role_name, **kwargs):  # noqa: E501
        """Add user role  # noqa: E501

        Add the specified role to the given user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_user_role_with_http_info(user_id, role_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int user_id: (required)
        :param str role_name: (required)
        :param object body: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'user_id',
            'role_name',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_user_role" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'user_id' is set
        if self.api_client.client_side_validation and ('user_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['user_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `user_id` when calling `update_user_role`")  # noqa: E501
        # verify the required parameter 'role_name' is set
        if self.api_client.client_side_validation and ('role_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['role_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `role_name` when calling `update_user_role`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in local_var_params:
            path_params['userId'] = local_var_params['user_id']  # noqa: E501
        if 'role_name' in local_var_params:
            path_params['roleName'] = local_var_params['role_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/users/{userId}/role/{roleName}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def user_info(self, **kwargs):  # noqa: E501
        """Details of the current user  # noqa: E501

        Returns the current user with its companies and contracts  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.user_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ComPatagonaPricemonitorShareApiUserInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.user_info_with_http_info(**kwargs)  # noqa: E501

    def user_info_with_http_info(self, **kwargs):  # noqa: E501
        """Details of the current user  # noqa: E501

        Returns the current user with its companies and contracts  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.user_info_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ComPatagonaPricemonitorShareApiUserInfo, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method user_info" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/account', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ComPatagonaPricemonitorShareApiUserInfo',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def user_signup(self, user_signup_request, **kwargs):  # noqa: E501
        """Create a new user account in the system  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.user_signup(user_signup_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param UserSignupRequest user_signup_request: The user sign up data (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.user_signup_with_http_info(user_signup_request, **kwargs)  # noqa: E501

    def user_signup_with_http_info(self, user_signup_request, **kwargs):  # noqa: E501
        """Create a new user account in the system  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.user_signup_with_http_info(user_signup_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param UserSignupRequest user_signup_request: The user sign up data (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'user_signup_request'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method user_signup" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'user_signup_request' is set
        if self.api_client.client_side_validation and ('user_signup_request' not in local_var_params or  # noqa: E501
                                                        local_var_params['user_signup_request'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `user_signup_request` when calling `user_signup`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'user_signup_request' in local_var_params:
            body_params = local_var_params['user_signup_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/account', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def validate_offers_manufacturer_v2(self, contract_id, **kwargs):  # noqa: E501
        """Validate offers [manufacturer]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.validate_offers_manufacturer_v2(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.validate_offers_manufacturer_v2_with_http_info(contract_id, **kwargs)  # noqa: E501

    def validate_offers_manufacturer_v2_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Validate offers [manufacturer]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.validate_offers_manufacturer_v2_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method validate_offers_manufacturer_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `validate_offers_manufacturer_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/m/contracts/{contractId}/result/validation', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def validate_offers_vendor_v2(self, contract_id, **kwargs):  # noqa: E501
        """Validate offers [vendor]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.validate_offers_vendor_v2(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.validate_offers_vendor_v2_with_http_info(contract_id, **kwargs)  # noqa: E501

    def validate_offers_vendor_v2_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Validate offers [vendor]  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.validate_offers_vendor_v2_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method validate_offers_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `validate_offers_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/result/validation', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def vendor_data(self, vendor, min_price, max_price, **kwargs):  # noqa: E501
        """Get vendor export data  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.vendor_data(vendor, min_price, max_price, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str vendor: (required)
        :param float min_price: (required)
        :param float max_price: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.vendor_data_with_http_info(vendor, min_price, max_price, **kwargs)  # noqa: E501

    def vendor_data_with_http_info(self, vendor, min_price, max_price, **kwargs):  # noqa: E501
        """Get vendor export data  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.vendor_data_with_http_info(vendor, min_price, max_price, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str vendor: (required)
        :param float min_price: (required)
        :param float max_price: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'vendor',
            'min_price',
            'max_price'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method vendor_data" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'vendor' is set
        if self.api_client.client_side_validation and ('vendor' not in local_var_params or  # noqa: E501
                                                        local_var_params['vendor'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `vendor` when calling `vendor_data`")  # noqa: E501
        # verify the required parameter 'min_price' is set
        if self.api_client.client_side_validation and ('min_price' not in local_var_params or  # noqa: E501
                                                        local_var_params['min_price'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `min_price` when calling `vendor_data`")  # noqa: E501
        # verify the required parameter 'max_price' is set
        if self.api_client.client_side_validation and ('max_price' not in local_var_params or  # noqa: E501
                                                        local_var_params['max_price'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `max_price` when calling `vendor_data`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'vendor' in local_var_params:
            path_params['vendor'] = local_var_params['vendor']  # noqa: E501

        query_params = []
        if 'min_price' in local_var_params and local_var_params['min_price'] is not None:  # noqa: E501
            query_params.append(('minPrice', local_var_params['min_price']))  # noqa: E501
        if 'max_price' in local_var_params and local_var_params['max_price'] is not None:  # noqa: E501
            query_params.append(('maxPrice', local_var_params['max_price']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/controlpanel/vendorexport/{vendor}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def version(self, **kwargs):  # noqa: E501
        """Get application version  # noqa: E501

        Get the current application version  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.version(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: VersionApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.version_with_http_info(**kwargs)  # noqa: E501

    def version_with_http_info(self, **kwargs):  # noqa: E501
        """Get application version  # noqa: E501

        Get the current application version  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.version_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(VersionApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method version" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/version', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='VersionApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)
