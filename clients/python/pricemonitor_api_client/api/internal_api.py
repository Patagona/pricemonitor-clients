# coding: utf-8

"""
    Pricemonitor API

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)  # noqa: E501

    The version of the OpenAPI document: 0.0.6435
    Generated by: https://openapi-generator.tech
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from pricemonitor_api_client.api_client import ApiClient
from pricemonitor_api_client.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError
)


class InternalApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def add_company(self, **kwargs):  # noqa: E501
        """add_company  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_company(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.add_company_with_http_info(**kwargs)  # noqa: E501

    def add_company_with_http_info(self, **kwargs):  # noqa: E501
        """add_company  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_company_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_company" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/controlpanel/api/companies', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_company_user(self, id, email, **kwargs):  # noqa: E501
        """add_company_user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_company_user(id, email, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: (required)
        :param str email: (required)
        :param object body: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.add_company_user_with_http_info(id, email, **kwargs)  # noqa: E501

    def add_company_user_with_http_info(self, id, email, **kwargs):  # noqa: E501
        """add_company_user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_company_user_with_http_info(id, email, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int id: (required)
        :param str email: (required)
        :param object body: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'id',
            'email',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_company_user" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'id' is set
        if self.api_client.client_side_validation and ('id' not in local_var_params or  # noqa: E501
                                                        local_var_params['id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `id` when calling `add_company_user`")  # noqa: E501
        # verify the required parameter 'email' is set
        if self.api_client.client_side_validation and ('email' not in local_var_params or  # noqa: E501
                                                        local_var_params['email'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `email` when calling `add_company_user`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in local_var_params:
            path_params['id'] = local_var_params['id']  # noqa: E501
        if 'email' in local_var_params:
            path_params['email'] = local_var_params['email']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/controlpanel/companies/{id}/users/{email}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_user(self, **kwargs):  # noqa: E501
        """Add a new user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_user(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.add_user_with_http_info(**kwargs)  # noqa: E501

    def add_user_with_http_info(self, **kwargs):  # noqa: E501
        """Add a new user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_user_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_user" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/controlpanel/users', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def api_v3_manufacturer_contracts_contract_id_offers_shop_query_post(self, contract_id, com_patagona_pricemonitor_share_api_query_offers_of_shop_request_v3, **kwargs):  # noqa: E501
        """api_v3_manufacturer_contracts_contract_id_offers_shop_query_post  # noqa: E501

        Get all offers of a shop. Please note that it might return offers for inactive products.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_v3_manufacturer_contracts_contract_id_offers_shop_query_post(contract_id, com_patagona_pricemonitor_share_api_query_offers_of_shop_request_v3, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param ComPatagonaPricemonitorShareApiQueryOffersOfShopRequestV3 com_patagona_pricemonitor_share_api_query_offers_of_shop_request_v3: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: QueryOffersOfShopV3ApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.api_v3_manufacturer_contracts_contract_id_offers_shop_query_post_with_http_info(contract_id, com_patagona_pricemonitor_share_api_query_offers_of_shop_request_v3, **kwargs)  # noqa: E501

    def api_v3_manufacturer_contracts_contract_id_offers_shop_query_post_with_http_info(self, contract_id, com_patagona_pricemonitor_share_api_query_offers_of_shop_request_v3, **kwargs):  # noqa: E501
        """api_v3_manufacturer_contracts_contract_id_offers_shop_query_post  # noqa: E501

        Get all offers of a shop. Please note that it might return offers for inactive products.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_v3_manufacturer_contracts_contract_id_offers_shop_query_post_with_http_info(contract_id, com_patagona_pricemonitor_share_api_query_offers_of_shop_request_v3, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param ComPatagonaPricemonitorShareApiQueryOffersOfShopRequestV3 com_patagona_pricemonitor_share_api_query_offers_of_shop_request_v3: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(QueryOffersOfShopV3ApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'com_patagona_pricemonitor_share_api_query_offers_of_shop_request_v3'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v3_manufacturer_contracts_contract_id_offers_shop_query_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `api_v3_manufacturer_contracts_contract_id_offers_shop_query_post`")  # noqa: E501
        # verify the required parameter 'com_patagona_pricemonitor_share_api_query_offers_of_shop_request_v3' is set
        if self.api_client.client_side_validation and ('com_patagona_pricemonitor_share_api_query_offers_of_shop_request_v3' not in local_var_params or  # noqa: E501
                                                        local_var_params['com_patagona_pricemonitor_share_api_query_offers_of_shop_request_v3'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `com_patagona_pricemonitor_share_api_query_offers_of_shop_request_v3` when calling `api_v3_manufacturer_contracts_contract_id_offers_shop_query_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'com_patagona_pricemonitor_share_api_query_offers_of_shop_request_v3' in local_var_params:
            body_params = local_var_params['com_patagona_pricemonitor_share_api_query_offers_of_shop_request_v3']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/manufacturer/contracts/{contractId}/offers/shop/query', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='QueryOffersOfShopV3ApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def api_v3_manufacturer_contracts_contract_id_offers_shops_get(self, contract_id, **kwargs):  # noqa: E501
        """Returns all shops which have at least one offer for a given time range per domain.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_v3_manufacturer_contracts_contract_id_offers_shops_get(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param datetime start_date: Timestamp of start of time range, formatted as ISO Date (i.e. 2018-04-06T13:46:13Z) in UTC. If this value is omitted and {endDate} is given, {startDate} is set to {endDate} - 48 hours. If both values are omitted, the range is 'NOW - 48 hours to NOW'. The time range may not exceed 1 week.
        :param datetime end_date: Timestamp of end of time range, formatted as ISO Date (i.e. 2018-04-06T13:46:13Z) in UTC. If this value is omitted and {startDate} is given, {endDate} is set to {startDate} + 48 hours. If both values are omitted, the range is 'NOW - 48 hours to NOW'. The time range may not exceed 1 week.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: GetShopsByDomainResponseV3ApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.api_v3_manufacturer_contracts_contract_id_offers_shops_get_with_http_info(contract_id, **kwargs)  # noqa: E501

    def api_v3_manufacturer_contracts_contract_id_offers_shops_get_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Returns all shops which have at least one offer for a given time range per domain.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_v3_manufacturer_contracts_contract_id_offers_shops_get_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param datetime start_date: Timestamp of start of time range, formatted as ISO Date (i.e. 2018-04-06T13:46:13Z) in UTC. If this value is omitted and {endDate} is given, {startDate} is set to {endDate} - 48 hours. If both values are omitted, the range is 'NOW - 48 hours to NOW'. The time range may not exceed 1 week.
        :param datetime end_date: Timestamp of end of time range, formatted as ISO Date (i.e. 2018-04-06T13:46:13Z) in UTC. If this value is omitted and {startDate} is given, {endDate} is set to {startDate} + 48 hours. If both values are omitted, the range is 'NOW - 48 hours to NOW'. The time range may not exceed 1 week.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(GetShopsByDomainResponseV3ApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'start_date',
            'end_date'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v3_manufacturer_contracts_contract_id_offers_shops_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `api_v3_manufacturer_contracts_contract_id_offers_shops_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []
        if 'start_date' in local_var_params and local_var_params['start_date'] is not None:  # noqa: E501
            query_params.append(('startDate', local_var_params['start_date']))  # noqa: E501
        if 'end_date' in local_var_params and local_var_params['end_date'] is not None:  # noqa: E501
            query_params.append(('endDate', local_var_params['end_date']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/manufacturer/contracts/{contractId}/offers/shops', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetShopsByDomainResponseV3ApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def api_v3_manufacturer_contracts_contract_id_offers_stats_query_post(self, contract_id, post_offer_statistics_request, **kwargs):  # noqa: E501
        """api_v3_manufacturer_contracts_contract_id_offers_stats_query_post  # noqa: E501

        This operation is used to get offer statistics (e.g. offer count, average price) grouped by product and domain. Warning: This endpoint contains complex query structure and will be replaced in the future. Please note that offer statistics can only be computed for at maximum 2500 products at a time.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_v3_manufacturer_contracts_contract_id_offers_stats_query_post(contract_id, post_offer_statistics_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param PostOfferStatisticsRequest post_offer_statistics_request: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: PostOfferStatisticsApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.api_v3_manufacturer_contracts_contract_id_offers_stats_query_post_with_http_info(contract_id, post_offer_statistics_request, **kwargs)  # noqa: E501

    def api_v3_manufacturer_contracts_contract_id_offers_stats_query_post_with_http_info(self, contract_id, post_offer_statistics_request, **kwargs):  # noqa: E501
        """api_v3_manufacturer_contracts_contract_id_offers_stats_query_post  # noqa: E501

        This operation is used to get offer statistics (e.g. offer count, average price) grouped by product and domain. Warning: This endpoint contains complex query structure and will be replaced in the future. Please note that offer statistics can only be computed for at maximum 2500 products at a time.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_v3_manufacturer_contracts_contract_id_offers_stats_query_post_with_http_info(contract_id, post_offer_statistics_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param PostOfferStatisticsRequest post_offer_statistics_request: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(PostOfferStatisticsApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'post_offer_statistics_request'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v3_manufacturer_contracts_contract_id_offers_stats_query_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `api_v3_manufacturer_contracts_contract_id_offers_stats_query_post`")  # noqa: E501
        # verify the required parameter 'post_offer_statistics_request' is set
        if self.api_client.client_side_validation and ('post_offer_statistics_request' not in local_var_params or  # noqa: E501
                                                        local_var_params['post_offer_statistics_request'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `post_offer_statistics_request` when calling `api_v3_manufacturer_contracts_contract_id_offers_stats_query_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'post_offer_statistics_request' in local_var_params:
            body_params = local_var_params['post_offer_statistics_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/manufacturer/contracts/{contractId}/offers/stats/query', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PostOfferStatisticsApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def api_v3_vendor_contracts_contract_id_offers_shop_query_post(self, contract_id, com_patagona_pricemonitor_share_api_query_offers_of_shop_request_v3, **kwargs):  # noqa: E501
        """api_v3_vendor_contracts_contract_id_offers_shop_query_post  # noqa: E501

        Get all offers of a shop. Please note that it might return offers for inactive products.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_v3_vendor_contracts_contract_id_offers_shop_query_post(contract_id, com_patagona_pricemonitor_share_api_query_offers_of_shop_request_v3, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param ComPatagonaPricemonitorShareApiQueryOffersOfShopRequestV3 com_patagona_pricemonitor_share_api_query_offers_of_shop_request_v3: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: QueryOffersOfShopV3ApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.api_v3_vendor_contracts_contract_id_offers_shop_query_post_with_http_info(contract_id, com_patagona_pricemonitor_share_api_query_offers_of_shop_request_v3, **kwargs)  # noqa: E501

    def api_v3_vendor_contracts_contract_id_offers_shop_query_post_with_http_info(self, contract_id, com_patagona_pricemonitor_share_api_query_offers_of_shop_request_v3, **kwargs):  # noqa: E501
        """api_v3_vendor_contracts_contract_id_offers_shop_query_post  # noqa: E501

        Get all offers of a shop. Please note that it might return offers for inactive products.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_v3_vendor_contracts_contract_id_offers_shop_query_post_with_http_info(contract_id, com_patagona_pricemonitor_share_api_query_offers_of_shop_request_v3, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param ComPatagonaPricemonitorShareApiQueryOffersOfShopRequestV3 com_patagona_pricemonitor_share_api_query_offers_of_shop_request_v3: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(QueryOffersOfShopV3ApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'com_patagona_pricemonitor_share_api_query_offers_of_shop_request_v3'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v3_vendor_contracts_contract_id_offers_shop_query_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `api_v3_vendor_contracts_contract_id_offers_shop_query_post`")  # noqa: E501
        # verify the required parameter 'com_patagona_pricemonitor_share_api_query_offers_of_shop_request_v3' is set
        if self.api_client.client_side_validation and ('com_patagona_pricemonitor_share_api_query_offers_of_shop_request_v3' not in local_var_params or  # noqa: E501
                                                        local_var_params['com_patagona_pricemonitor_share_api_query_offers_of_shop_request_v3'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `com_patagona_pricemonitor_share_api_query_offers_of_shop_request_v3` when calling `api_v3_vendor_contracts_contract_id_offers_shop_query_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'com_patagona_pricemonitor_share_api_query_offers_of_shop_request_v3' in local_var_params:
            body_params = local_var_params['com_patagona_pricemonitor_share_api_query_offers_of_shop_request_v3']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/vendor/contracts/{contractId}/offers/shop/query', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='QueryOffersOfShopV3ApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def api_v3_vendor_contracts_contract_id_offers_shops_get(self, contract_id, **kwargs):  # noqa: E501
        """Returns all shops which have at least one offer for a given time range per domain.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_v3_vendor_contracts_contract_id_offers_shops_get(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param datetime start_date: Timestamp of start of time range, formatted as ISO Date (i.e. 2018-04-06T13:46:13Z) in UTC. If this value is omitted and {endDate} is given, {startDate} is set to {endDate} - 48 hours. If both values are omitted, the range is 'NOW - 48 hours to NOW'. The time range may not exceed 1 week.
        :param datetime end_date: Timestamp of end of time range, formatted as ISO Date (i.e. 2018-04-06T13:46:13Z) in UTC. If this value is omitted and {startDate} is given, {endDate} is set to {startDate} + 48 hours. If both values are omitted, the range is 'NOW - 48 hours to NOW'. The time range may not exceed 1 week.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: GetShopsByDomainResponseV3ApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.api_v3_vendor_contracts_contract_id_offers_shops_get_with_http_info(contract_id, **kwargs)  # noqa: E501

    def api_v3_vendor_contracts_contract_id_offers_shops_get_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Returns all shops which have at least one offer for a given time range per domain.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_v3_vendor_contracts_contract_id_offers_shops_get_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param datetime start_date: Timestamp of start of time range, formatted as ISO Date (i.e. 2018-04-06T13:46:13Z) in UTC. If this value is omitted and {endDate} is given, {startDate} is set to {endDate} - 48 hours. If both values are omitted, the range is 'NOW - 48 hours to NOW'. The time range may not exceed 1 week.
        :param datetime end_date: Timestamp of end of time range, formatted as ISO Date (i.e. 2018-04-06T13:46:13Z) in UTC. If this value is omitted and {startDate} is given, {endDate} is set to {startDate} + 48 hours. If both values are omitted, the range is 'NOW - 48 hours to NOW'. The time range may not exceed 1 week.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(GetShopsByDomainResponseV3ApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'start_date',
            'end_date'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v3_vendor_contracts_contract_id_offers_shops_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `api_v3_vendor_contracts_contract_id_offers_shops_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []
        if 'start_date' in local_var_params and local_var_params['start_date'] is not None:  # noqa: E501
            query_params.append(('startDate', local_var_params['start_date']))  # noqa: E501
        if 'end_date' in local_var_params and local_var_params['end_date'] is not None:  # noqa: E501
            query_params.append(('endDate', local_var_params['end_date']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/vendor/contracts/{contractId}/offers/shops', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetShopsByDomainResponseV3ApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def api_v3_vendor_contracts_contract_id_offers_stats_query_post(self, contract_id, post_offer_statistics_request, **kwargs):  # noqa: E501
        """api_v3_vendor_contracts_contract_id_offers_stats_query_post  # noqa: E501

        This operation is used to get offer statistics (e.g. offer count, average price) grouped by product and domain. Warning: This endpoint contains complex query structure and will be replaced in the future. Please note that offer statistics can only be computed for at maximum 2500 products at a time.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_v3_vendor_contracts_contract_id_offers_stats_query_post(contract_id, post_offer_statistics_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param PostOfferStatisticsRequest post_offer_statistics_request: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: PostOfferStatisticsApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.api_v3_vendor_contracts_contract_id_offers_stats_query_post_with_http_info(contract_id, post_offer_statistics_request, **kwargs)  # noqa: E501

    def api_v3_vendor_contracts_contract_id_offers_stats_query_post_with_http_info(self, contract_id, post_offer_statistics_request, **kwargs):  # noqa: E501
        """api_v3_vendor_contracts_contract_id_offers_stats_query_post  # noqa: E501

        This operation is used to get offer statistics (e.g. offer count, average price) grouped by product and domain. Warning: This endpoint contains complex query structure and will be replaced in the future. Please note that offer statistics can only be computed for at maximum 2500 products at a time.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_v3_vendor_contracts_contract_id_offers_stats_query_post_with_http_info(contract_id, post_offer_statistics_request, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param PostOfferStatisticsRequest post_offer_statistics_request: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(PostOfferStatisticsApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'post_offer_statistics_request'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v3_vendor_contracts_contract_id_offers_stats_query_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `api_v3_vendor_contracts_contract_id_offers_stats_query_post`")  # noqa: E501
        # verify the required parameter 'post_offer_statistics_request' is set
        if self.api_client.client_side_validation and ('post_offer_statistics_request' not in local_var_params or  # noqa: E501
                                                        local_var_params['post_offer_statistics_request'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `post_offer_statistics_request` when calling `api_v3_vendor_contracts_contract_id_offers_stats_query_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'post_offer_statistics_request' in local_var_params:
            body_params = local_var_params['post_offer_statistics_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/vendor/contracts/{contractId}/offers/stats/query', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PostOfferStatisticsApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def controlpanel_api_companies_get(self, **kwargs):  # noqa: E501
        """Get a list of all companies  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.controlpanel_api_companies_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int start: Start of the pagination
        :param int limit: Number of elements per page
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ComPatagonaPricemonitorShareApiAdminCompanyV2
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.controlpanel_api_companies_get_with_http_info(**kwargs)  # noqa: E501

    def controlpanel_api_companies_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get a list of all companies  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.controlpanel_api_companies_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int start: Start of the pagination
        :param int limit: Number of elements per page
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ComPatagonaPricemonitorShareApiAdminCompanyV2, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'start',
            'limit'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method controlpanel_api_companies_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'start' in local_var_params and local_var_params['start'] is not None:  # noqa: E501
            query_params.append(('start', local_var_params['start']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/controlpanel/api/companies', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ComPatagonaPricemonitorShareApiAdminCompanyV2',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def controlpanel_api_v3_domains_post(self, **kwargs):  # noqa: E501
        """Add a new domain  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.controlpanel_api_v3_domains_post(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param ComPatagonaPricemonitorShareApiPostAdminAddDomainBodyV3 com_patagona_pricemonitor_share_api_post_admin_add_domain_body_v3: The domain to be added and its offer sources
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: PostAdminAddDomainV3ApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.controlpanel_api_v3_domains_post_with_http_info(**kwargs)  # noqa: E501

    def controlpanel_api_v3_domains_post_with_http_info(self, **kwargs):  # noqa: E501
        """Add a new domain  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.controlpanel_api_v3_domains_post_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param ComPatagonaPricemonitorShareApiPostAdminAddDomainBodyV3 com_patagona_pricemonitor_share_api_post_admin_add_domain_body_v3: The domain to be added and its offer sources
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(PostAdminAddDomainV3ApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'com_patagona_pricemonitor_share_api_post_admin_add_domain_body_v3'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method controlpanel_api_v3_domains_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'com_patagona_pricemonitor_share_api_post_admin_add_domain_body_v3' in local_var_params:
            body_params = local_var_params['com_patagona_pricemonitor_share_api_post_admin_add_domain_body_v3']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/controlpanel/api/v3/domains', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PostAdminAddDomainV3ApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_alert_settings(self, contract_id, **kwargs):  # noqa: E501
        """create_alert_settings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_alert_settings(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_alert_settings_with_http_info(contract_id, **kwargs)  # noqa: E501

    def create_alert_settings_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """create_alert_settings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_alert_settings_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_alert_settings" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `create_alert_settings`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/1/{contractId}/settings/alerts', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_auth_token(self, email, **kwargs):  # noqa: E501
        """create_auth_token  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_auth_token(email, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str email: (required)
        :param object body: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_auth_token_with_http_info(email, **kwargs)  # noqa: E501

    def create_auth_token_with_http_info(self, email, **kwargs):  # noqa: E501
        """create_auth_token  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_auth_token_with_http_info(email, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str email: (required)
        :param object body: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'email',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_auth_token" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'email' is set
        if self.api_client.client_side_validation and ('email' not in local_var_params or  # noqa: E501
                                                        local_var_params['email'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `email` when calling `create_auth_token`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'email' in local_var_params:
            path_params['email'] = local_var_params['email']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/controlpanel/users/{email}/authtokens', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_task(self, contract_id, **kwargs):  # noqa: E501
        """create_task  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_task(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_task_with_http_info(contract_id, **kwargs)  # noqa: E501

    def create_task_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """create_task  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_task_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_task" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `create_task`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/1/{contractId}/tasks', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_task_manufacturer_v2(self, contract_id, **kwargs):  # noqa: E501
        """create_task_manufacturer_v2  # noqa: E501

        Create a new task  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_task_manufacturer_v2(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param ComPatagonaPricemonitorShareApiCreateTaskBodyV2 com_patagona_pricemonitor_share_api_create_task_body_v2: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: GenericTaskWithUrl
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_task_manufacturer_v2_with_http_info(contract_id, **kwargs)  # noqa: E501

    def create_task_manufacturer_v2_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """create_task_manufacturer_v2  # noqa: E501

        Create a new task  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_task_manufacturer_v2_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param ComPatagonaPricemonitorShareApiCreateTaskBodyV2 com_patagona_pricemonitor_share_api_create_task_body_v2: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(GenericTaskWithUrl, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'com_patagona_pricemonitor_share_api_create_task_body_v2'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_task_manufacturer_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `create_task_manufacturer_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'com_patagona_pricemonitor_share_api_create_task_body_v2' in local_var_params:
            body_params = local_var_params['com_patagona_pricemonitor_share_api_create_task_body_v2']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/m/contracts/{contractId}/tasks', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GenericTaskWithUrl',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_task_vendor_v2(self, contract_id, **kwargs):  # noqa: E501
        """create_task_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_task_vendor_v2(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_task_vendor_v2_with_http_info(contract_id, **kwargs)  # noqa: E501

    def create_task_vendor_v2_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """create_task_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_task_vendor_v2_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_task_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `create_task_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/tasks', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_alert_settings(self, contract_id, alert_id, **kwargs):  # noqa: E501
        """delete_alert_settings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_alert_settings(contract_id, alert_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str alert_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_alert_settings_with_http_info(contract_id, alert_id, **kwargs)  # noqa: E501

    def delete_alert_settings_with_http_info(self, contract_id, alert_id, **kwargs):  # noqa: E501
        """delete_alert_settings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_alert_settings_with_http_info(contract_id, alert_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str alert_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'alert_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_alert_settings" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `delete_alert_settings`")  # noqa: E501
        # verify the required parameter 'alert_id' is set
        if self.api_client.client_side_validation and ('alert_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['alert_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `alert_id` when calling `delete_alert_settings`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'alert_id' in local_var_params:
            path_params['alertId'] = local_var_params['alert_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/1/{contractId}/settings/alerts/{alertId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_auth_token(self, email, token, **kwargs):  # noqa: E501
        """delete_auth_token  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_auth_token(email, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str email: (required)
        :param str token: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_auth_token_with_http_info(email, token, **kwargs)  # noqa: E501

    def delete_auth_token_with_http_info(self, email, token, **kwargs):  # noqa: E501
        """delete_auth_token  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_auth_token_with_http_info(email, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str email: (required)
        :param str token: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'email',
            'token'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_auth_token" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'email' is set
        if self.api_client.client_side_validation and ('email' not in local_var_params or  # noqa: E501
                                                        local_var_params['email'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `email` when calling `delete_auth_token`")  # noqa: E501
        # verify the required parameter 'token' is set
        if self.api_client.client_side_validation and ('token' not in local_var_params or  # noqa: E501
                                                        local_var_params['token'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `token` when calling `delete_auth_token`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'email' in local_var_params:
            path_params['email'] = local_var_params['email']  # noqa: E501
        if 'token' in local_var_params:
            path_params['token'] = local_var_params['token']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/controlpanel/users/{email}/authtokens/{token}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_callback_settings_manufacturer_v2(self, contract_id, **kwargs):  # noqa: E501
        """delete_callback_settings_manufacturer_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_callback_settings_manufacturer_v2(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_callback_settings_manufacturer_v2_with_http_info(contract_id, **kwargs)  # noqa: E501

    def delete_callback_settings_manufacturer_v2_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """delete_callback_settings_manufacturer_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_callback_settings_manufacturer_v2_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_callback_settings_manufacturer_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `delete_callback_settings_manufacturer_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/m/contracts/{contractId}/settings/callbacks', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_callback_settings_vendor_v2(self, contract_id, **kwargs):  # noqa: E501
        """delete_callback_settings_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_callback_settings_vendor_v2(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_callback_settings_vendor_v2_with_http_info(contract_id, **kwargs)  # noqa: E501

    def delete_callback_settings_vendor_v2_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """delete_callback_settings_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_callback_settings_vendor_v2_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_callback_settings_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `delete_callback_settings_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/settings/callbacks', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_contract_vendor_v2(self, contract_id, **kwargs):  # noqa: E501
        """delete_contract_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_contract_vendor_v2(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_contract_vendor_v2_with_http_info(contract_id, **kwargs)  # noqa: E501

    def delete_contract_vendor_v2_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """delete_contract_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_contract_vendor_v2_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_contract_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `delete_contract_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_dynamic_monitoring_settings(self, contract_id, **kwargs):  # noqa: E501
        """delete_dynamic_monitoring_settings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_dynamic_monitoring_settings(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_dynamic_monitoring_settings_with_http_info(contract_id, **kwargs)  # noqa: E501

    def delete_dynamic_monitoring_settings_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """delete_dynamic_monitoring_settings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_dynamic_monitoring_settings_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_dynamic_monitoring_settings" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `delete_dynamic_monitoring_settings`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/1/{contractId}/settings/dynamicmonitoring', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_feed_vendor_v2(self, contract_id, feed_id, **kwargs):  # noqa: E501
        """delete_feed_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_feed_vendor_v2(contract_id, feed_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str feed_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_feed_vendor_v2_with_http_info(contract_id, feed_id, **kwargs)  # noqa: E501

    def delete_feed_vendor_v2_with_http_info(self, contract_id, feed_id, **kwargs):  # noqa: E501
        """delete_feed_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_feed_vendor_v2_with_http_info(contract_id, feed_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str feed_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'feed_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_feed_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `delete_feed_vendor_v2`")  # noqa: E501
        # verify the required parameter 'feed_id' is set
        if self.api_client.client_side_validation and ('feed_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['feed_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `feed_id` when calling `delete_feed_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'feed_id' in local_var_params:
            path_params['feedId'] = local_var_params['feed_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/feeds/{feedId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_import_settings_vendor_v2(self, contract_id, **kwargs):  # noqa: E501
        """delete_import_settings_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_import_settings_vendor_v2(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_import_settings_vendor_v2_with_http_info(contract_id, **kwargs)  # noqa: E501

    def delete_import_settings_vendor_v2_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """delete_import_settings_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_import_settings_vendor_v2_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_import_settings_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `delete_import_settings_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/settings/import', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_monitoring_schedule_manufacturer_v3(self, contract_id, schedule_id, **kwargs):  # noqa: E501
        """Delete a monitoring schedule for a given contract.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_monitoring_schedule_manufacturer_v3(contract_id, schedule_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param int schedule_id: ID of a monitoring schedule (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ComPatagonaPricemonitorShareApiDeleteByNumericIdApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_monitoring_schedule_manufacturer_v3_with_http_info(contract_id, schedule_id, **kwargs)  # noqa: E501

    def delete_monitoring_schedule_manufacturer_v3_with_http_info(self, contract_id, schedule_id, **kwargs):  # noqa: E501
        """Delete a monitoring schedule for a given contract.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_monitoring_schedule_manufacturer_v3_with_http_info(contract_id, schedule_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param int schedule_id: ID of a monitoring schedule (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ComPatagonaPricemonitorShareApiDeleteByNumericIdApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'schedule_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_monitoring_schedule_manufacturer_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `delete_monitoring_schedule_manufacturer_v3`")  # noqa: E501
        # verify the required parameter 'schedule_id' is set
        if self.api_client.client_side_validation and ('schedule_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['schedule_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `schedule_id` when calling `delete_monitoring_schedule_manufacturer_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'schedule_id' in local_var_params:
            path_params['scheduleId'] = local_var_params['schedule_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/manufacturer/contracts/{contractId}/settings/monitoringschedules/{scheduleId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ComPatagonaPricemonitorShareApiDeleteByNumericIdApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_monitoring_schedule_vendor_v3(self, contract_id, schedule_id, **kwargs):  # noqa: E501
        """Delete a monitoring schedule for a given contract.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_monitoring_schedule_vendor_v3(contract_id, schedule_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param int schedule_id: ID of a monitoring schedule (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ComPatagonaPricemonitorShareApiDeleteByNumericIdApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_monitoring_schedule_vendor_v3_with_http_info(contract_id, schedule_id, **kwargs)  # noqa: E501

    def delete_monitoring_schedule_vendor_v3_with_http_info(self, contract_id, schedule_id, **kwargs):  # noqa: E501
        """Delete a monitoring schedule for a given contract.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_monitoring_schedule_vendor_v3_with_http_info(contract_id, schedule_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param int schedule_id: ID of a monitoring schedule (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ComPatagonaPricemonitorShareApiDeleteByNumericIdApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'schedule_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_monitoring_schedule_vendor_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `delete_monitoring_schedule_vendor_v3`")  # noqa: E501
        # verify the required parameter 'schedule_id' is set
        if self.api_client.client_side_validation and ('schedule_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['schedule_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `schedule_id` when calling `delete_monitoring_schedule_vendor_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'schedule_id' in local_var_params:
            path_params['scheduleId'] = local_var_params['schedule_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/vendor/contracts/{contractId}/settings/monitoringschedules/{scheduleId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ComPatagonaPricemonitorShareApiDeleteByNumericIdApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_products_manufacturer_v3(self, contract_id, **kwargs):  # noqa: E501
        """delete_products_manufacturer_v3  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_products_manufacturer_v3(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param datetime updated_max:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_products_manufacturer_v3_with_http_info(contract_id, **kwargs)  # noqa: E501

    def delete_products_manufacturer_v3_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """delete_products_manufacturer_v3  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_products_manufacturer_v3_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param datetime updated_max:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'updated_max'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_products_manufacturer_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `delete_products_manufacturer_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []
        if 'updated_max' in local_var_params and local_var_params['updated_max'] is not None:  # noqa: E501
            query_params.append(('updatedMax', local_var_params['updated_max']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/manufacturer/contracts/{contractId}/products', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_repricing_strategy_vendor_v2(self, contract_id, **kwargs):  # noqa: E501
        """delete_repricing_strategy_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_repricing_strategy_vendor_v2(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_repricing_strategy_vendor_v2_with_http_info(contract_id, **kwargs)  # noqa: E501

    def delete_repricing_strategy_vendor_v2_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """delete_repricing_strategy_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_repricing_strategy_vendor_v2_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_repricing_strategy_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `delete_repricing_strategy_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/settings/repricingstrategy', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_user_role(self, user_id, role_name, **kwargs):  # noqa: E501
        """delete_user_role  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_user_role(user_id, role_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int user_id: (required)
        :param str role_name: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_user_role_with_http_info(user_id, role_name, **kwargs)  # noqa: E501

    def delete_user_role_with_http_info(self, user_id, role_name, **kwargs):  # noqa: E501
        """delete_user_role  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_user_role_with_http_info(user_id, role_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int user_id: (required)
        :param str role_name: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'user_id',
            'role_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_user_role" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'user_id' is set
        if self.api_client.client_side_validation and ('user_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['user_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `user_id` when calling `delete_user_role`")  # noqa: E501
        # verify the required parameter 'role_name' is set
        if self.api_client.client_side_validation and ('role_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['role_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `role_name` when calling `delete_user_role`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in local_var_params:
            path_params['userId'] = local_var_params['user_id']  # noqa: E501
        if 'role_name' in local_var_params:
            path_params['roleName'] = local_var_params['role_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/users/{userId}/role/{roleName}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_vendor_shop_mapping_manufacturer_v3(self, contract_id, vendor_id, **kwargs):  # noqa: E501
        """Delete a vendor and associated shops for a given contract.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_vendor_shop_mapping_manufacturer_v3(contract_id, vendor_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param int vendor_id: ID of vendor shop mapping (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ComPatagonaPricemonitorShareApiDeleteByNumericIdApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_vendor_shop_mapping_manufacturer_v3_with_http_info(contract_id, vendor_id, **kwargs)  # noqa: E501

    def delete_vendor_shop_mapping_manufacturer_v3_with_http_info(self, contract_id, vendor_id, **kwargs):  # noqa: E501
        """Delete a vendor and associated shops for a given contract.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_vendor_shop_mapping_manufacturer_v3_with_http_info(contract_id, vendor_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param int vendor_id: ID of vendor shop mapping (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ComPatagonaPricemonitorShareApiDeleteByNumericIdApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'vendor_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_vendor_shop_mapping_manufacturer_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `delete_vendor_shop_mapping_manufacturer_v3`")  # noqa: E501
        # verify the required parameter 'vendor_id' is set
        if self.api_client.client_side_validation and ('vendor_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['vendor_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `vendor_id` when calling `delete_vendor_shop_mapping_manufacturer_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'vendor_id' in local_var_params:
            path_params['vendorId'] = local_var_params['vendor_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/manufacturer/contracts/{contractId}/vendors/{vendorId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ComPatagonaPricemonitorShareApiDeleteByNumericIdApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def execute_monitoring_schedule_manufacturer_v3(self, contract_id, schedule_id, **kwargs):  # noqa: E501
        """Trigger a monitoring pipeline task for manufacturer for configured monitoring schedule  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.execute_monitoring_schedule_manufacturer_v3(contract_id, schedule_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param int schedule_id: ID of a monitoring schedule (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: EmptyApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.execute_monitoring_schedule_manufacturer_v3_with_http_info(contract_id, schedule_id, **kwargs)  # noqa: E501

    def execute_monitoring_schedule_manufacturer_v3_with_http_info(self, contract_id, schedule_id, **kwargs):  # noqa: E501
        """Trigger a monitoring pipeline task for manufacturer for configured monitoring schedule  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.execute_monitoring_schedule_manufacturer_v3_with_http_info(contract_id, schedule_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param int schedule_id: ID of a monitoring schedule (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(EmptyApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'schedule_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method execute_monitoring_schedule_manufacturer_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `execute_monitoring_schedule_manufacturer_v3`")  # noqa: E501
        # verify the required parameter 'schedule_id' is set
        if self.api_client.client_side_validation and ('schedule_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['schedule_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `schedule_id` when calling `execute_monitoring_schedule_manufacturer_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'schedule_id' in local_var_params:
            path_params['scheduleId'] = local_var_params['schedule_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/manufacturer/contracts/{contractId}/settings/monitoringschedules/{scheduleId}/execute', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EmptyApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def execute_monitoring_schedule_vendor_v3(self, contract_id, schedule_id, **kwargs):  # noqa: E501
        """Trigger a monitoring pipeline task for vendor for configured monitoring schedule  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.execute_monitoring_schedule_vendor_v3(contract_id, schedule_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param int schedule_id: ID of a monitoring schedule (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: EmptyApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.execute_monitoring_schedule_vendor_v3_with_http_info(contract_id, schedule_id, **kwargs)  # noqa: E501

    def execute_monitoring_schedule_vendor_v3_with_http_info(self, contract_id, schedule_id, **kwargs):  # noqa: E501
        """Trigger a monitoring pipeline task for vendor for configured monitoring schedule  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.execute_monitoring_schedule_vendor_v3_with_http_info(contract_id, schedule_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param int schedule_id: ID of a monitoring schedule (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(EmptyApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'schedule_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method execute_monitoring_schedule_vendor_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `execute_monitoring_schedule_vendor_v3`")  # noqa: E501
        # verify the required parameter 'schedule_id' is set
        if self.api_client.client_side_validation and ('schedule_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['schedule_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `schedule_id` when calling `execute_monitoring_schedule_vendor_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'schedule_id' in local_var_params:
            path_params['scheduleId'] = local_var_params['schedule_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/vendor/contracts/{contractId}/settings/monitoringschedules/{scheduleId}/execute', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EmptyApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_active_ebay_token_vendor_v2(self, contract_id, **kwargs):  # noqa: E501
        """get_active_ebay_token_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_active_ebay_token_vendor_v2(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_active_ebay_token_vendor_v2_with_http_info(contract_id, **kwargs)  # noqa: E501

    def get_active_ebay_token_vendor_v2_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """get_active_ebay_token_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_active_ebay_token_vendor_v2_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_active_ebay_token_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_active_ebay_token_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/settings/ebay/token', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_alert_settings(self, contract_id, **kwargs):  # noqa: E501
        """get_alert_settings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_alert_settings(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_alert_settings_with_http_info(contract_id, **kwargs)  # noqa: E501

    def get_alert_settings_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """get_alert_settings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_alert_settings_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_alert_settings" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_alert_settings`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/1/{contractId}/settings/alerts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_contracts(self, **kwargs):  # noqa: E501
        """Get a list of all contracts  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_contracts(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_all_contracts_with_http_info(**kwargs)  # noqa: E501

    def get_all_contracts_with_http_info(self, **kwargs):  # noqa: E501
        """Get a list of all contracts  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_contracts_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_contracts" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/controlpanel/api/contracts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_ebay_authorizations_vendor_v2(self, contract_id, start, limit, **kwargs):  # noqa: E501
        """get_all_ebay_authorizations_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_ebay_authorizations_vendor_v2(contract_id, start, limit, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param int start: (required)
        :param int limit: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_all_ebay_authorizations_vendor_v2_with_http_info(contract_id, start, limit, **kwargs)  # noqa: E501

    def get_all_ebay_authorizations_vendor_v2_with_http_info(self, contract_id, start, limit, **kwargs):  # noqa: E501
        """get_all_ebay_authorizations_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_ebay_authorizations_vendor_v2_with_http_info(contract_id, start, limit, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param int start: (required)
        :param int limit: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'start',
            'limit'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_ebay_authorizations_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_all_ebay_authorizations_vendor_v2`")  # noqa: E501
        # verify the required parameter 'start' is set
        if self.api_client.client_side_validation and ('start' not in local_var_params or  # noqa: E501
                                                        local_var_params['start'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `start` when calling `get_all_ebay_authorizations_vendor_v2`")  # noqa: E501
        # verify the required parameter 'limit' is set
        if self.api_client.client_side_validation and ('limit' not in local_var_params or  # noqa: E501
                                                        local_var_params['limit'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `limit` when calling `get_all_ebay_authorizations_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []
        if 'start' in local_var_params and local_var_params['start'] is not None:  # noqa: E501
            query_params.append(('start', local_var_params['start']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/settings/ebay/authorizations', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_ebay_tokens_vendor_v2(self, contract_id, start, limit, **kwargs):  # noqa: E501
        """get_all_ebay_tokens_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_ebay_tokens_vendor_v2(contract_id, start, limit, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param int start: (required)
        :param int limit: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_all_ebay_tokens_vendor_v2_with_http_info(contract_id, start, limit, **kwargs)  # noqa: E501

    def get_all_ebay_tokens_vendor_v2_with_http_info(self, contract_id, start, limit, **kwargs):  # noqa: E501
        """get_all_ebay_tokens_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_ebay_tokens_vendor_v2_with_http_info(contract_id, start, limit, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param int start: (required)
        :param int limit: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'start',
            'limit'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_ebay_tokens_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_all_ebay_tokens_vendor_v2`")  # noqa: E501
        # verify the required parameter 'start' is set
        if self.api_client.client_side_validation and ('start' not in local_var_params or  # noqa: E501
                                                        local_var_params['start'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `start` when calling `get_all_ebay_tokens_vendor_v2`")  # noqa: E501
        # verify the required parameter 'limit' is set
        if self.api_client.client_side_validation and ('limit' not in local_var_params or  # noqa: E501
                                                        local_var_params['limit'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `limit` when calling `get_all_ebay_tokens_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []
        if 'start' in local_var_params and local_var_params['start'] is not None:  # noqa: E501
            query_params.append(('start', local_var_params['start']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/settings/ebay/tokens', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_portals(self, **kwargs):  # noqa: E501
        """Get a list of all portals  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_portals(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_all_portals_with_http_info(**kwargs)  # noqa: E501

    def get_all_portals_with_http_info(self, **kwargs):  # noqa: E501
        """Get a list of all portals  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_portals_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_portals" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/controlpanel/api/portals', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_tasks(self, contract_id, task_id, task_type, task_state, limit, **kwargs):  # noqa: E501
        """get_all_tasks  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_tasks(contract_id, task_id, task_type, task_state, limit, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param list[str] contract_id: (required)
        :param list[str] task_id: (required)
        :param list[str] task_type: (required)
        :param list[str] task_state: (required)
        :param int limit: (required)
        :param datetime min_creation_date:
        :param datetime max_creation_date:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_all_tasks_with_http_info(contract_id, task_id, task_type, task_state, limit, **kwargs)  # noqa: E501

    def get_all_tasks_with_http_info(self, contract_id, task_id, task_type, task_state, limit, **kwargs):  # noqa: E501
        """get_all_tasks  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_tasks_with_http_info(contract_id, task_id, task_type, task_state, limit, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param list[str] contract_id: (required)
        :param list[str] task_id: (required)
        :param list[str] task_type: (required)
        :param list[str] task_state: (required)
        :param int limit: (required)
        :param datetime min_creation_date:
        :param datetime max_creation_date:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'task_id',
            'task_type',
            'task_state',
            'limit',
            'min_creation_date',
            'max_creation_date'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_tasks" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_all_tasks`")  # noqa: E501
        # verify the required parameter 'task_id' is set
        if self.api_client.client_side_validation and ('task_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['task_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `task_id` when calling `get_all_tasks`")  # noqa: E501
        # verify the required parameter 'task_type' is set
        if self.api_client.client_side_validation and ('task_type' not in local_var_params or  # noqa: E501
                                                        local_var_params['task_type'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `task_type` when calling `get_all_tasks`")  # noqa: E501
        # verify the required parameter 'task_state' is set
        if self.api_client.client_side_validation and ('task_state' not in local_var_params or  # noqa: E501
                                                        local_var_params['task_state'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `task_state` when calling `get_all_tasks`")  # noqa: E501
        # verify the required parameter 'limit' is set
        if self.api_client.client_side_validation and ('limit' not in local_var_params or  # noqa: E501
                                                        local_var_params['limit'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `limit` when calling `get_all_tasks`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'contract_id' in local_var_params and local_var_params['contract_id'] is not None:  # noqa: E501
            query_params.append(('contractId', local_var_params['contract_id']))  # noqa: E501
            collection_formats['contractId'] = 'multi'  # noqa: E501
        if 'task_id' in local_var_params and local_var_params['task_id'] is not None:  # noqa: E501
            query_params.append(('taskId', local_var_params['task_id']))  # noqa: E501
            collection_formats['taskId'] = 'multi'  # noqa: E501
        if 'task_type' in local_var_params and local_var_params['task_type'] is not None:  # noqa: E501
            query_params.append(('taskType', local_var_params['task_type']))  # noqa: E501
            collection_formats['taskType'] = 'multi'  # noqa: E501
        if 'task_state' in local_var_params and local_var_params['task_state'] is not None:  # noqa: E501
            query_params.append(('taskState', local_var_params['task_state']))  # noqa: E501
            collection_formats['taskState'] = 'multi'  # noqa: E501
        if 'min_creation_date' in local_var_params and local_var_params['min_creation_date'] is not None:  # noqa: E501
            query_params.append(('minCreationDate', local_var_params['min_creation_date']))  # noqa: E501
        if 'max_creation_date' in local_var_params and local_var_params['max_creation_date'] is not None:  # noqa: E501
            query_params.append(('maxCreationDate', local_var_params['max_creation_date']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/controlpanel/api/tasks', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_users(self, **kwargs):  # noqa: E501
        """Get a list of all users  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_users(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_all_users_with_http_info(**kwargs)  # noqa: E501

    def get_all_users_with_http_info(self, **kwargs):  # noqa: E501
        """Get a list of all users  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_users_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_users" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/controlpanel/api/users', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_authorization_status_vendor_v3(self, company_id, **kwargs):  # noqa: E501
        """Get OAuth authorization status for customer's Amazon seller central account. For setting up OAuth authorization, have a look at the endpoint POST /api/v3/companies/{companyId}/amazon/authorization.   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_authorization_status_vendor_v3(company_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int company_id: ID of a company (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: GetAuthorizationStatusResponseV3ApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_authorization_status_vendor_v3_with_http_info(company_id, **kwargs)  # noqa: E501

    def get_authorization_status_vendor_v3_with_http_info(self, company_id, **kwargs):  # noqa: E501
        """Get OAuth authorization status for customer's Amazon seller central account. For setting up OAuth authorization, have a look at the endpoint POST /api/v3/companies/{companyId}/amazon/authorization.   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_authorization_status_vendor_v3_with_http_info(company_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int company_id: ID of a company (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(GetAuthorizationStatusResponseV3ApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'company_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_authorization_status_vendor_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'company_id' is set
        if self.api_client.client_side_validation and ('company_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['company_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `company_id` when calling `get_authorization_status_vendor_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'company_id' in local_var_params:
            path_params['companyId'] = local_var_params['company_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/companies/{companyId}/amazon/authorization/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetAuthorizationStatusResponseV3ApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_callbacks_vendor_v2(self, contract_id, **kwargs):  # noqa: E501
        """get_callbacks_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_callbacks_vendor_v2(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_callbacks_vendor_v2_with_http_info(contract_id, **kwargs)  # noqa: E501

    def get_callbacks_vendor_v2_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """get_callbacks_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_callbacks_vendor_v2_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_callbacks_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_callbacks_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/settings/callbacks', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_cheapest_vendors_manufacturer_v2(self, contract_id, session, include_delivery_costs, **kwargs):  # noqa: E501
        """get_cheapest_vendors_manufacturer_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cheapest_vendors_manufacturer_v2(contract_id, session, include_delivery_costs, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param datetime session: (required)
        :param bool include_delivery_costs: (required)
        :param ComPatagonaPricemonitorShareApiTagFilteredVendorsRequest com_patagona_pricemonitor_share_api_tag_filtered_vendors_request: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_cheapest_vendors_manufacturer_v2_with_http_info(contract_id, session, include_delivery_costs, **kwargs)  # noqa: E501

    def get_cheapest_vendors_manufacturer_v2_with_http_info(self, contract_id, session, include_delivery_costs, **kwargs):  # noqa: E501
        """get_cheapest_vendors_manufacturer_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cheapest_vendors_manufacturer_v2_with_http_info(contract_id, session, include_delivery_costs, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param datetime session: (required)
        :param bool include_delivery_costs: (required)
        :param ComPatagonaPricemonitorShareApiTagFilteredVendorsRequest com_patagona_pricemonitor_share_api_tag_filtered_vendors_request: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'session',
            'include_delivery_costs',
            'com_patagona_pricemonitor_share_api_tag_filtered_vendors_request'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_cheapest_vendors_manufacturer_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_cheapest_vendors_manufacturer_v2`")  # noqa: E501
        # verify the required parameter 'session' is set
        if self.api_client.client_side_validation and ('session' not in local_var_params or  # noqa: E501
                                                        local_var_params['session'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `session` when calling `get_cheapest_vendors_manufacturer_v2`")  # noqa: E501
        # verify the required parameter 'include_delivery_costs' is set
        if self.api_client.client_side_validation and ('include_delivery_costs' not in local_var_params or  # noqa: E501
                                                        local_var_params['include_delivery_costs'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `include_delivery_costs` when calling `get_cheapest_vendors_manufacturer_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []
        if 'session' in local_var_params and local_var_params['session'] is not None:  # noqa: E501
            query_params.append(('session', local_var_params['session']))  # noqa: E501
        if 'include_delivery_costs' in local_var_params and local_var_params['include_delivery_costs'] is not None:  # noqa: E501
            query_params.append(('includeDeliveryCosts', local_var_params['include_delivery_costs']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'com_patagona_pricemonitor_share_api_tag_filtered_vendors_request' in local_var_params:
            body_params = local_var_params['com_patagona_pricemonitor_share_api_tag_filtered_vendors_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/m/contracts/{contractId}/result/vendors/cheapest', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_company(self, company_id, **kwargs):  # noqa: E501
        """get_company  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_company(company_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int company_id: ID of a company (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_company_with_http_info(company_id, **kwargs)  # noqa: E501

    def get_company_with_http_info(self, company_id, **kwargs):  # noqa: E501
        """get_company  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_company_with_http_info(company_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int company_id: ID of a company (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'company_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_company" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'company_id' is set
        if self.api_client.client_side_validation and ('company_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['company_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `company_id` when calling `get_company`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'company_id' in local_var_params:
            path_params['companyId'] = local_var_params['company_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/controlpanel/api/companies/{companyId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_complex_offer_filters_vendor_v2(self, contract_id, list_type, **kwargs):  # noqa: E501
        """Get all complex filters for the given contract.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_complex_offer_filters_vendor_v2(contract_id, list_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str list_type: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: OfferFilterApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_complex_offer_filters_vendor_v2_with_http_info(contract_id, list_type, **kwargs)  # noqa: E501

    def get_complex_offer_filters_vendor_v2_with_http_info(self, contract_id, list_type, **kwargs):  # noqa: E501
        """Get all complex filters for the given contract.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_complex_offer_filters_vendor_v2_with_http_info(contract_id, list_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str list_type: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(OfferFilterApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'list_type'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_complex_offer_filters_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_complex_offer_filters_vendor_v2`")  # noqa: E501
        # verify the required parameter 'list_type' is set
        if self.api_client.client_side_validation and ('list_type' not in local_var_params or  # noqa: E501
                                                        local_var_params['list_type'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `list_type` when calling `get_complex_offer_filters_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'list_type' in local_var_params:
            path_params['listType'] = local_var_params['list_type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/offerfilters/{listType}/complex', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='OfferFilterApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_contracts_vendor_v2(self, **kwargs):  # noqa: E501
        """get_contracts_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_contracts_vendor_v2(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param datetime max_creation_date:
        :param datetime min_expiration_date:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_contracts_vendor_v2_with_http_info(**kwargs)  # noqa: E501

    def get_contracts_vendor_v2_with_http_info(self, **kwargs):  # noqa: E501
        """get_contracts_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_contracts_vendor_v2_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param datetime max_creation_date:
        :param datetime min_expiration_date:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'max_creation_date',
            'min_expiration_date'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_contracts_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'max_creation_date' in local_var_params and local_var_params['max_creation_date'] is not None:  # noqa: E501
            query_params.append(('maxCreationDate', local_var_params['max_creation_date']))  # noqa: E501
        if 'min_expiration_date' in local_var_params and local_var_params['min_expiration_date'] is not None:  # noqa: E501
            query_params.append(('minExpirationDate', local_var_params['min_expiration_date']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_currency_vendor_v2(self, contract_id, **kwargs):  # noqa: E501
        """get_currency_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_currency_vendor_v2(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_currency_vendor_v2_with_http_info(contract_id, **kwargs)  # noqa: E501

    def get_currency_vendor_v2_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """get_currency_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_currency_vendor_v2_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_currency_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_currency_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/settings/currency', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_customer_contract_settings_manufaturer_v3(self, contract_id, **kwargs):  # noqa: E501
        """get_customer_contract_settings_manufaturer_v3  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_customer_contract_settings_manufaturer_v3(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: GetCustomerContractSettingsApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_customer_contract_settings_manufaturer_v3_with_http_info(contract_id, **kwargs)  # noqa: E501

    def get_customer_contract_settings_manufaturer_v3_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """get_customer_contract_settings_manufaturer_v3  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_customer_contract_settings_manufaturer_v3_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(GetCustomerContractSettingsApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_customer_contract_settings_manufaturer_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_customer_contract_settings_manufaturer_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/manufacturer/contracts/{contractId}/settings/customer', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetCustomerContractSettingsApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_customer_contract_settings_vendor_v3(self, contract_id, **kwargs):  # noqa: E501
        """get_customer_contract_settings_vendor_v3  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_customer_contract_settings_vendor_v3(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: GetCustomerContractSettingsApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_customer_contract_settings_vendor_v3_with_http_info(contract_id, **kwargs)  # noqa: E501

    def get_customer_contract_settings_vendor_v3_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """get_customer_contract_settings_vendor_v3  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_customer_contract_settings_vendor_v3_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(GetCustomerContractSettingsApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_customer_contract_settings_vendor_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_customer_contract_settings_vendor_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/vendor/contracts/{contractId}/settings/customer', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetCustomerContractSettingsApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_domains_vendor_v2(self, contract_id, **kwargs):  # noqa: E501
        """get_domains_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_domains_vendor_v2(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_domains_vendor_v2_with_http_info(contract_id, **kwargs)  # noqa: E501

    def get_domains_vendor_v2_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """get_domains_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_domains_vendor_v2_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_domains_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_domains_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/settings/domains', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_dynamic_monitoring_settings(self, contract_id, **kwargs):  # noqa: E501
        """get_dynamic_monitoring_settings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dynamic_monitoring_settings(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_dynamic_monitoring_settings_with_http_info(contract_id, **kwargs)  # noqa: E501

    def get_dynamic_monitoring_settings_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """get_dynamic_monitoring_settings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dynamic_monitoring_settings_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_dynamic_monitoring_settings" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_dynamic_monitoring_settings`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/1/{contractId}/settings/dynamicmonitoring', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_ebay_authorizations_vendor_v2(self, contract_id, auth_ids, **kwargs):  # noqa: E501
        """get_ebay_authorizations_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ebay_authorizations_vendor_v2(contract_id, auth_ids, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str auth_ids: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_ebay_authorizations_vendor_v2_with_http_info(contract_id, auth_ids, **kwargs)  # noqa: E501

    def get_ebay_authorizations_vendor_v2_with_http_info(self, contract_id, auth_ids, **kwargs):  # noqa: E501
        """get_ebay_authorizations_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ebay_authorizations_vendor_v2_with_http_info(contract_id, auth_ids, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str auth_ids: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'auth_ids'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_ebay_authorizations_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_ebay_authorizations_vendor_v2`")  # noqa: E501
        # verify the required parameter 'auth_ids' is set
        if self.api_client.client_side_validation and ('auth_ids' not in local_var_params or  # noqa: E501
                                                        local_var_params['auth_ids'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `auth_ids` when calling `get_ebay_authorizations_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'auth_ids' in local_var_params:
            path_params['authIds'] = local_var_params['auth_ids']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/settings/ebay/authorizations/{authIds}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_extended_tags_manufacturer_v3(self, contract_id, product_id, **kwargs):  # noqa: E501
        """get_extended_tags_manufacturer_v3  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_extended_tags_manufacturer_v3(contract_id, product_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str product_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_extended_tags_manufacturer_v3_with_http_info(contract_id, product_id, **kwargs)  # noqa: E501

    def get_extended_tags_manufacturer_v3_with_http_info(self, contract_id, product_id, **kwargs):  # noqa: E501
        """get_extended_tags_manufacturer_v3  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_extended_tags_manufacturer_v3_with_http_info(contract_id, product_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str product_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'product_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_extended_tags_manufacturer_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_extended_tags_manufacturer_v3`")  # noqa: E501
        # verify the required parameter 'product_id' is set
        if self.api_client.client_side_validation and ('product_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['product_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `product_id` when calling `get_extended_tags_manufacturer_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'product_id' in local_var_params:
            path_params['productId'] = local_var_params['product_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/manufacturer/contracts/{contractId}/products/{productId}/extendedtags', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_feed_export_delta_vendor_v2(self, contract_id, feed_id, **kwargs):  # noqa: E501
        """get_feed_export_delta_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_feed_export_delta_vendor_v2(contract_id, feed_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str feed_id: (required)
        :param str file_name:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_feed_export_delta_vendor_v2_with_http_info(contract_id, feed_id, **kwargs)  # noqa: E501

    def get_feed_export_delta_vendor_v2_with_http_info(self, contract_id, feed_id, **kwargs):  # noqa: E501
        """get_feed_export_delta_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_feed_export_delta_vendor_v2_with_http_info(contract_id, feed_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str feed_id: (required)
        :param str file_name:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'feed_id',
            'file_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_feed_export_delta_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_feed_export_delta_vendor_v2`")  # noqa: E501
        # verify the required parameter 'feed_id' is set
        if self.api_client.client_side_validation and ('feed_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['feed_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `feed_id` when calling `get_feed_export_delta_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'feed_id' in local_var_params:
            path_params['feedId'] = local_var_params['feed_id']  # noqa: E501

        query_params = []
        if 'file_name' in local_var_params and local_var_params['file_name'] is not None:  # noqa: E501
            query_params.append(('fileName', local_var_params['file_name']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/feeds/{feedId}/export/delta', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_feed_export_vendor_v2(self, contract_id, feed_id, **kwargs):  # noqa: E501
        """get_feed_export_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_feed_export_vendor_v2(contract_id, feed_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str feed_id: (required)
        :param str file_name:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_feed_export_vendor_v2_with_http_info(contract_id, feed_id, **kwargs)  # noqa: E501

    def get_feed_export_vendor_v2_with_http_info(self, contract_id, feed_id, **kwargs):  # noqa: E501
        """get_feed_export_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_feed_export_vendor_v2_with_http_info(contract_id, feed_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str feed_id: (required)
        :param str file_name:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'feed_id',
            'file_name'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_feed_export_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_feed_export_vendor_v2`")  # noqa: E501
        # verify the required parameter 'feed_id' is set
        if self.api_client.client_side_validation and ('feed_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['feed_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `feed_id` when calling `get_feed_export_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'feed_id' in local_var_params:
            path_params['feedId'] = local_var_params['feed_id']  # noqa: E501

        query_params = []
        if 'file_name' in local_var_params and local_var_params['file_name'] is not None:  # noqa: E501
            query_params.append(('fileName', local_var_params['file_name']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/feeds/{feedId}/export', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_import_settings_vendor_v2(self, contract_id, **kwargs):  # noqa: E501
        """get_import_settings_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_import_settings_vendor_v2(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_import_settings_vendor_v2_with_http_info(contract_id, **kwargs)  # noqa: E501

    def get_import_settings_vendor_v2_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """get_import_settings_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_import_settings_vendor_v2_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_import_settings_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_import_settings_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/settings/import', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_manufacturer_manufacturer_v2(self, contract_id, **kwargs):  # noqa: E501
        """get_manufacturer_manufacturer_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_manufacturer_manufacturer_v2(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_manufacturer_manufacturer_v2_with_http_info(contract_id, **kwargs)  # noqa: E501

    def get_manufacturer_manufacturer_v2_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """get_manufacturer_manufacturer_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_manufacturer_manufacturer_v2_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_manufacturer_manufacturer_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_manufacturer_manufacturer_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/m/contracts/{contractId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_manufacturer_v3(self, contract_id, **kwargs):  # noqa: E501
        """Get the contract information  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_manufacturer_v3(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: GetManufacturerV3ApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_manufacturer_v3_with_http_info(contract_id, **kwargs)  # noqa: E501

    def get_manufacturer_v3_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Get the contract information  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_manufacturer_v3_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(GetManufacturerV3ApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_manufacturer_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_manufacturer_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/manufacturer/contracts/{contractId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetManufacturerV3ApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_mappings_vendor_v2(self, contract_id, input_type, identifiers, **kwargs):  # noqa: E501
        """get_mappings_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_mappings_vendor_v2(contract_id, input_type, identifiers, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str input_type: (required)
        :param list[str] identifiers: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_mappings_vendor_v2_with_http_info(contract_id, input_type, identifiers, **kwargs)  # noqa: E501

    def get_mappings_vendor_v2_with_http_info(self, contract_id, input_type, identifiers, **kwargs):  # noqa: E501
        """get_mappings_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_mappings_vendor_v2_with_http_info(contract_id, input_type, identifiers, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str input_type: (required)
        :param list[str] identifiers: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'input_type',
            'identifiers'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_mappings_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_mappings_vendor_v2`")  # noqa: E501
        # verify the required parameter 'input_type' is set
        if self.api_client.client_side_validation and ('input_type' not in local_var_params or  # noqa: E501
                                                        local_var_params['input_type'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `input_type` when calling `get_mappings_vendor_v2`")  # noqa: E501
        # verify the required parameter 'identifiers' is set
        if self.api_client.client_side_validation and ('identifiers' not in local_var_params or  # noqa: E501
                                                        local_var_params['identifiers'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `identifiers` when calling `get_mappings_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []
        if 'input_type' in local_var_params and local_var_params['input_type'] is not None:  # noqa: E501
            query_params.append(('inputType', local_var_params['input_type']))  # noqa: E501
        if 'identifiers' in local_var_params and local_var_params['identifiers'] is not None:  # noqa: E501
            query_params.append(('identifiers', local_var_params['identifiers']))  # noqa: E501
            collection_formats['identifiers'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/productidentifiermapping', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_monitoring_schedules_manufacturer_v3(self, contract_id, **kwargs):  # noqa: E501
        """Get all the monitoring schedules for a specified contract.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_monitoring_schedules_manufacturer_v3(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: GetMonitoringSchedulesApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_monitoring_schedules_manufacturer_v3_with_http_info(contract_id, **kwargs)  # noqa: E501

    def get_monitoring_schedules_manufacturer_v3_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Get all the monitoring schedules for a specified contract.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_monitoring_schedules_manufacturer_v3_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(GetMonitoringSchedulesApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_monitoring_schedules_manufacturer_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_monitoring_schedules_manufacturer_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/manufacturer/contracts/{contractId}/settings/monitoringschedules', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetMonitoringSchedulesApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_monitoring_schedules_vendor_v3(self, contract_id, **kwargs):  # noqa: E501
        """Get all the monitoring schedules for a specified contract.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_monitoring_schedules_vendor_v3(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: GetMonitoringSchedulesApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_monitoring_schedules_vendor_v3_with_http_info(contract_id, **kwargs)  # noqa: E501

    def get_monitoring_schedules_vendor_v3_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Get all the monitoring schedules for a specified contract.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_monitoring_schedules_vendor_v3_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(GetMonitoringSchedulesApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_monitoring_schedules_vendor_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_monitoring_schedules_vendor_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/vendor/contracts/{contractId}/settings/monitoringschedules', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetMonitoringSchedulesApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_monitoring_settings_manufacturer_v2(self, contract_id, **kwargs):  # noqa: E501
        """get_monitoring_settings_manufacturer_v2  # noqa: E501

        Get the current monitoring settings for a given contract  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_monitoring_settings_manufacturer_v2(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_monitoring_settings_manufacturer_v2_with_http_info(contract_id, **kwargs)  # noqa: E501

    def get_monitoring_settings_manufacturer_v2_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """get_monitoring_settings_manufacturer_v2  # noqa: E501

        Get the current monitoring settings for a given contract  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_monitoring_settings_manufacturer_v2_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_monitoring_settings_manufacturer_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_monitoring_settings_manufacturer_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/m/contracts/{contractId}/settings/monitoring', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_monitoring_settings_manufacturer_v3(self, contract_id, **kwargs):  # noqa: E501
        """get_monitoring_settings_manufacturer_v3  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_monitoring_settings_manufacturer_v3(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_monitoring_settings_manufacturer_v3_with_http_info(contract_id, **kwargs)  # noqa: E501

    def get_monitoring_settings_manufacturer_v3_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """get_monitoring_settings_manufacturer_v3  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_monitoring_settings_manufacturer_v3_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_monitoring_settings_manufacturer_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_monitoring_settings_manufacturer_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/manufacturer/contracts/{contractId}/settings/monitoring', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_monitoring_settings_vendor_v2(self, contract_id, **kwargs):  # noqa: E501
        """get_monitoring_settings_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_monitoring_settings_vendor_v2(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_monitoring_settings_vendor_v2_with_http_info(contract_id, **kwargs)  # noqa: E501

    def get_monitoring_settings_vendor_v2_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """get_monitoring_settings_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_monitoring_settings_vendor_v2_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_monitoring_settings_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_monitoring_settings_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/settings/monitoring', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_monitoring_settings_vendor_v3(self, contract_id, **kwargs):  # noqa: E501
        """get_monitoring_settings_vendor_v3  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_monitoring_settings_vendor_v3(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_monitoring_settings_vendor_v3_with_http_info(contract_id, **kwargs)  # noqa: E501

    def get_monitoring_settings_vendor_v3_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """get_monitoring_settings_vendor_v3  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_monitoring_settings_vendor_v3_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_monitoring_settings_vendor_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_monitoring_settings_vendor_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/vendor/contracts/{contractId}/settings/monitoring', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_offer_filters_vendor_v2(self, contract_id, list_type, **kwargs):  # noqa: E501
        """Get all the vendor filters for the given contract.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_offer_filters_vendor_v2(contract_id, list_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str list_type: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_offer_filters_vendor_v2_with_http_info(contract_id, list_type, **kwargs)  # noqa: E501

    def get_offer_filters_vendor_v2_with_http_info(self, contract_id, list_type, **kwargs):  # noqa: E501
        """Get all the vendor filters for the given contract.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_offer_filters_vendor_v2_with_http_info(contract_id, list_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str list_type: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'list_type'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_offer_filters_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_offer_filters_vendor_v2`")  # noqa: E501
        # verify the required parameter 'list_type' is set
        if self.api_client.client_side_validation and ('list_type' not in local_var_params or  # noqa: E501
                                                        local_var_params['list_type'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `list_type` when calling `get_offer_filters_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'list_type' in local_var_params:
            path_params['listType'] = local_var_params['list_type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/offerfilters/{listType}/vendors', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_offer_retention_settings_manufacturer_v3(self, contract_id, contract_type, **kwargs):  # noqa: E501
        """get_offer_retention_settings_manufacturer_v3  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_offer_retention_settings_manufacturer_v3(contract_id, contract_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str contract_type: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_offer_retention_settings_manufacturer_v3_with_http_info(contract_id, contract_type, **kwargs)  # noqa: E501

    def get_offer_retention_settings_manufacturer_v3_with_http_info(self, contract_id, contract_type, **kwargs):  # noqa: E501
        """get_offer_retention_settings_manufacturer_v3  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_offer_retention_settings_manufacturer_v3_with_http_info(contract_id, contract_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str contract_type: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'contract_type'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_offer_retention_settings_manufacturer_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_offer_retention_settings_manufacturer_v3`")  # noqa: E501
        # verify the required parameter 'contract_type' is set
        if self.api_client.client_side_validation and ('contract_type' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_type'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_type` when calling `get_offer_retention_settings_manufacturer_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []
        if 'contract_type' in local_var_params and local_var_params['contract_type'] is not None:  # noqa: E501
            query_params.append(('contractType', local_var_params['contract_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/manufacturer/contracts/{contractId}/settings/offerretention', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_offer_retention_settings_vendor_v3(self, contract_id, contract_type, **kwargs):  # noqa: E501
        """get_offer_retention_settings_vendor_v3  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_offer_retention_settings_vendor_v3(contract_id, contract_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str contract_type: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_offer_retention_settings_vendor_v3_with_http_info(contract_id, contract_type, **kwargs)  # noqa: E501

    def get_offer_retention_settings_vendor_v3_with_http_info(self, contract_id, contract_type, **kwargs):  # noqa: E501
        """get_offer_retention_settings_vendor_v3  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_offer_retention_settings_vendor_v3_with_http_info(contract_id, contract_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str contract_type: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'contract_type'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_offer_retention_settings_vendor_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_offer_retention_settings_vendor_v3`")  # noqa: E501
        # verify the required parameter 'contract_type' is set
        if self.api_client.client_side_validation and ('contract_type' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_type'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_type` when calling `get_offer_retention_settings_vendor_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []
        if 'contract_type' in local_var_params and local_var_params['contract_type'] is not None:  # noqa: E501
            query_params.append(('contractType', local_var_params['contract_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/vendor/contracts/{contractId}/settings/offerretention', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_offer_statistics_manufacturer_v3(self, contract_id, include_delivery_costs, **kwargs):  # noqa: E501
        """Get offer statistics per product of a contract. Only the latest offers per product and domain the are taken into account.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_offer_statistics_manufacturer_v3(contract_id, include_delivery_costs, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param bool include_delivery_costs: (required)
        :param datetime start_date: Timestamp of start of time range, formatted as ISO Date (i.e. 2018-04-06T13:46:13Z) in UTC. If this value is omitted and {endDate} is given, {startDate} is set to {endDate} - 48 hours. If both values are omitted, the range is 'NOW - 48 hours to NOW'.
        :param datetime end_date: Timestamp of end of time range, formatted as ISO Date (i.e. 2018-04-06T13:46:13Z) in UTC. If this value is omitted and {startDate} is given, {endDate} is set to {startDate} + 48 hours. If both values are omitted, the range is 'NOW - 48 hours to NOW'.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: GetOfferStatisticsV3ApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_offer_statistics_manufacturer_v3_with_http_info(contract_id, include_delivery_costs, **kwargs)  # noqa: E501

    def get_offer_statistics_manufacturer_v3_with_http_info(self, contract_id, include_delivery_costs, **kwargs):  # noqa: E501
        """Get offer statistics per product of a contract. Only the latest offers per product and domain the are taken into account.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_offer_statistics_manufacturer_v3_with_http_info(contract_id, include_delivery_costs, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param bool include_delivery_costs: (required)
        :param datetime start_date: Timestamp of start of time range, formatted as ISO Date (i.e. 2018-04-06T13:46:13Z) in UTC. If this value is omitted and {endDate} is given, {startDate} is set to {endDate} - 48 hours. If both values are omitted, the range is 'NOW - 48 hours to NOW'.
        :param datetime end_date: Timestamp of end of time range, formatted as ISO Date (i.e. 2018-04-06T13:46:13Z) in UTC. If this value is omitted and {startDate} is given, {endDate} is set to {startDate} + 48 hours. If both values are omitted, the range is 'NOW - 48 hours to NOW'.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(GetOfferStatisticsV3ApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'include_delivery_costs',
            'start_date',
            'end_date'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_offer_statistics_manufacturer_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_offer_statistics_manufacturer_v3`")  # noqa: E501
        # verify the required parameter 'include_delivery_costs' is set
        if self.api_client.client_side_validation and ('include_delivery_costs' not in local_var_params or  # noqa: E501
                                                        local_var_params['include_delivery_costs'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `include_delivery_costs` when calling `get_offer_statistics_manufacturer_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []
        if 'start_date' in local_var_params and local_var_params['start_date'] is not None:  # noqa: E501
            query_params.append(('startDate', local_var_params['start_date']))  # noqa: E501
        if 'end_date' in local_var_params and local_var_params['end_date'] is not None:  # noqa: E501
            query_params.append(('endDate', local_var_params['end_date']))  # noqa: E501
        if 'include_delivery_costs' in local_var_params and local_var_params['include_delivery_costs'] is not None:  # noqa: E501
            query_params.append(('includeDeliveryCosts', local_var_params['include_delivery_costs']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/manufacturer/contracts/{contractId}/offers/stats', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetOfferStatisticsV3ApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_orders_count_by_portal_by_contract(self, contract_id, **kwargs):  # noqa: E501
        """get_orders_count_by_portal_by_contract  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_orders_count_by_portal_by_contract(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_orders_count_by_portal_by_contract_with_http_info(contract_id, **kwargs)  # noqa: E501

    def get_orders_count_by_portal_by_contract_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """get_orders_count_by_portal_by_contract  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_orders_count_by_portal_by_contract_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_orders_count_by_portal_by_contract" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_orders_count_by_portal_by_contract`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/1/{contractId}/products/orderscountbyportal', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_orders_vendor_v3(self, contract_id, start, limit, **kwargs):  # noqa: E501
        """get_orders_vendor_v3  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_orders_vendor_v3(contract_id, start, limit, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param int start: (required)
        :param int limit: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_orders_vendor_v3_with_http_info(contract_id, start, limit, **kwargs)  # noqa: E501

    def get_orders_vendor_v3_with_http_info(self, contract_id, start, limit, **kwargs):  # noqa: E501
        """get_orders_vendor_v3  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_orders_vendor_v3_with_http_info(contract_id, start, limit, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param int start: (required)
        :param int limit: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'start',
            'limit'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_orders_vendor_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_orders_vendor_v3`")  # noqa: E501
        # verify the required parameter 'start' is set
        if self.api_client.client_side_validation and ('start' not in local_var_params or  # noqa: E501
                                                        local_var_params['start'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `start` when calling `get_orders_vendor_v3`")  # noqa: E501
        # verify the required parameter 'limit' is set
        if self.api_client.client_side_validation and ('limit' not in local_var_params or  # noqa: E501
                                                        local_var_params['limit'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `limit` when calling `get_orders_vendor_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []
        if 'start' in local_var_params and local_var_params['start'] is not None:  # noqa: E501
            query_params.append(('start', local_var_params['start']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/vendor/contracts/{contractId}/orders', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_price_cutters_manufacturer_v2(self, contract_id, session, limit, include_delivery_costs, **kwargs):  # noqa: E501
        """get_price_cutters_manufacturer_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_price_cutters_manufacturer_v2(contract_id, session, limit, include_delivery_costs, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param datetime session: (required)
        :param int limit: (required)
        :param bool include_delivery_costs: (required)
        :param object body: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_price_cutters_manufacturer_v2_with_http_info(contract_id, session, limit, include_delivery_costs, **kwargs)  # noqa: E501

    def get_price_cutters_manufacturer_v2_with_http_info(self, contract_id, session, limit, include_delivery_costs, **kwargs):  # noqa: E501
        """get_price_cutters_manufacturer_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_price_cutters_manufacturer_v2_with_http_info(contract_id, session, limit, include_delivery_costs, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param datetime session: (required)
        :param int limit: (required)
        :param bool include_delivery_costs: (required)
        :param object body: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'session',
            'limit',
            'include_delivery_costs',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_price_cutters_manufacturer_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_price_cutters_manufacturer_v2`")  # noqa: E501
        # verify the required parameter 'session' is set
        if self.api_client.client_side_validation and ('session' not in local_var_params or  # noqa: E501
                                                        local_var_params['session'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `session` when calling `get_price_cutters_manufacturer_v2`")  # noqa: E501
        # verify the required parameter 'limit' is set
        if self.api_client.client_side_validation and ('limit' not in local_var_params or  # noqa: E501
                                                        local_var_params['limit'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `limit` when calling `get_price_cutters_manufacturer_v2`")  # noqa: E501
        # verify the required parameter 'include_delivery_costs' is set
        if self.api_client.client_side_validation and ('include_delivery_costs' not in local_var_params or  # noqa: E501
                                                        local_var_params['include_delivery_costs'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `include_delivery_costs` when calling `get_price_cutters_manufacturer_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []
        if 'session' in local_var_params and local_var_params['session'] is not None:  # noqa: E501
            query_params.append(('session', local_var_params['session']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'include_delivery_costs' in local_var_params and local_var_params['include_delivery_costs'] is not None:  # noqa: E501
            query_params.append(('includeDeliveryCosts', local_var_params['include_delivery_costs']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/m/contracts/{contractId}/result/pricecutters', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_price_cutters_vendor_v2(self, contract_id, session, limit, include_delivery_costs, **kwargs):  # noqa: E501
        """get_price_cutters_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_price_cutters_vendor_v2(contract_id, session, limit, include_delivery_costs, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param datetime session: (required)
        :param int limit: (required)
        :param bool include_delivery_costs: (required)
        :param object body: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_price_cutters_vendor_v2_with_http_info(contract_id, session, limit, include_delivery_costs, **kwargs)  # noqa: E501

    def get_price_cutters_vendor_v2_with_http_info(self, contract_id, session, limit, include_delivery_costs, **kwargs):  # noqa: E501
        """get_price_cutters_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_price_cutters_vendor_v2_with_http_info(contract_id, session, limit, include_delivery_costs, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param datetime session: (required)
        :param int limit: (required)
        :param bool include_delivery_costs: (required)
        :param object body: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'session',
            'limit',
            'include_delivery_costs',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_price_cutters_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_price_cutters_vendor_v2`")  # noqa: E501
        # verify the required parameter 'session' is set
        if self.api_client.client_side_validation and ('session' not in local_var_params or  # noqa: E501
                                                        local_var_params['session'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `session` when calling `get_price_cutters_vendor_v2`")  # noqa: E501
        # verify the required parameter 'limit' is set
        if self.api_client.client_side_validation and ('limit' not in local_var_params or  # noqa: E501
                                                        local_var_params['limit'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `limit` when calling `get_price_cutters_vendor_v2`")  # noqa: E501
        # verify the required parameter 'include_delivery_costs' is set
        if self.api_client.client_side_validation and ('include_delivery_costs' not in local_var_params or  # noqa: E501
                                                        local_var_params['include_delivery_costs'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `include_delivery_costs` when calling `get_price_cutters_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []
        if 'session' in local_var_params and local_var_params['session'] is not None:  # noqa: E501
            query_params.append(('session', local_var_params['session']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'include_delivery_costs' in local_var_params and local_var_params['include_delivery_costs'] is not None:  # noqa: E501
            query_params.append(('includeDeliveryCosts', local_var_params['include_delivery_costs']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/result/pricecutters', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_price_recommendation_stats_vendor_v2(self, contract_id, start_time, end_time, max_positions, **kwargs):  # noqa: E501
        """get_price_recommendation_stats_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_price_recommendation_stats_vendor_v2(contract_id, start_time, end_time, max_positions, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param datetime start_time: (required)
        :param datetime end_time: (required)
        :param int max_positions: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_price_recommendation_stats_vendor_v2_with_http_info(contract_id, start_time, end_time, max_positions, **kwargs)  # noqa: E501

    def get_price_recommendation_stats_vendor_v2_with_http_info(self, contract_id, start_time, end_time, max_positions, **kwargs):  # noqa: E501
        """get_price_recommendation_stats_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_price_recommendation_stats_vendor_v2_with_http_info(contract_id, start_time, end_time, max_positions, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param datetime start_time: (required)
        :param datetime end_time: (required)
        :param int max_positions: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'start_time',
            'end_time',
            'max_positions'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_price_recommendation_stats_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_price_recommendation_stats_vendor_v2`")  # noqa: E501
        # verify the required parameter 'start_time' is set
        if self.api_client.client_side_validation and ('start_time' not in local_var_params or  # noqa: E501
                                                        local_var_params['start_time'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `start_time` when calling `get_price_recommendation_stats_vendor_v2`")  # noqa: E501
        # verify the required parameter 'end_time' is set
        if self.api_client.client_side_validation and ('end_time' not in local_var_params or  # noqa: E501
                                                        local_var_params['end_time'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `end_time` when calling `get_price_recommendation_stats_vendor_v2`")  # noqa: E501
        # verify the required parameter 'max_positions' is set
        if self.api_client.client_side_validation and ('max_positions' not in local_var_params or  # noqa: E501
                                                        local_var_params['max_positions'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `max_positions` when calling `get_price_recommendation_stats_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []
        if 'start_time' in local_var_params and local_var_params['start_time'] is not None:  # noqa: E501
            query_params.append(('startTime', local_var_params['start_time']))  # noqa: E501
        if 'end_time' in local_var_params and local_var_params['end_time'] is not None:  # noqa: E501
            query_params.append(('endTime', local_var_params['end_time']))  # noqa: E501
        if 'max_positions' in local_var_params and local_var_params['max_positions'] is not None:  # noqa: E501
            query_params.append(('maxPositions', local_var_params['max_positions']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/result/pricerecommendationstats', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_product_filters_by_id_vendor_v2(self, contract_id, **kwargs):  # noqa: E501
        """get_product_filters_by_id_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_product_filters_by_id_vendor_v2(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_product_filters_by_id_vendor_v2_with_http_info(contract_id, **kwargs)  # noqa: E501

    def get_product_filters_by_id_vendor_v2_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """get_product_filters_by_id_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_product_filters_by_id_vendor_v2_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_product_filters_by_id_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_product_filters_by_id_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/offerfilters/:listType/products/query', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_product_filters_by_range_vendor_v2(self, contract_id, list_type, start, limit, **kwargs):  # noqa: E501
        """Get all the filters product-wise for the given contract.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_product_filters_by_range_vendor_v2(contract_id, list_type, start, limit, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str list_type: (required)
        :param int start: (required)
        :param int limit: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_product_filters_by_range_vendor_v2_with_http_info(contract_id, list_type, start, limit, **kwargs)  # noqa: E501

    def get_product_filters_by_range_vendor_v2_with_http_info(self, contract_id, list_type, start, limit, **kwargs):  # noqa: E501
        """Get all the filters product-wise for the given contract.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_product_filters_by_range_vendor_v2_with_http_info(contract_id, list_type, start, limit, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str list_type: (required)
        :param int start: (required)
        :param int limit: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'list_type',
            'start',
            'limit'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_product_filters_by_range_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_product_filters_by_range_vendor_v2`")  # noqa: E501
        # verify the required parameter 'list_type' is set
        if self.api_client.client_side_validation and ('list_type' not in local_var_params or  # noqa: E501
                                                        local_var_params['list_type'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `list_type` when calling `get_product_filters_by_range_vendor_v2`")  # noqa: E501
        # verify the required parameter 'start' is set
        if self.api_client.client_side_validation and ('start' not in local_var_params or  # noqa: E501
                                                        local_var_params['start'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `start` when calling `get_product_filters_by_range_vendor_v2`")  # noqa: E501
        # verify the required parameter 'limit' is set
        if self.api_client.client_side_validation and ('limit' not in local_var_params or  # noqa: E501
                                                        local_var_params['limit'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `limit` when calling `get_product_filters_by_range_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'list_type' in local_var_params:
            path_params['listType'] = local_var_params['list_type']  # noqa: E501

        query_params = []
        if 'start' in local_var_params and local_var_params['start'] is not None:  # noqa: E501
            query_params.append(('start', local_var_params['start']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/offerfilters/{listType}/products', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_product_filters_vendor_v2(self, contract_id, list_type, product_id, **kwargs):  # noqa: E501
        """Get all the filters of a given product for the given contract.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_product_filters_vendor_v2(contract_id, list_type, product_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str list_type: (required)
        :param str product_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: OfferFilterApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_product_filters_vendor_v2_with_http_info(contract_id, list_type, product_id, **kwargs)  # noqa: E501

    def get_product_filters_vendor_v2_with_http_info(self, contract_id, list_type, product_id, **kwargs):  # noqa: E501
        """Get all the filters of a given product for the given contract.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_product_filters_vendor_v2_with_http_info(contract_id, list_type, product_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str list_type: (required)
        :param str product_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(OfferFilterApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'list_type',
            'product_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_product_filters_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_product_filters_vendor_v2`")  # noqa: E501
        # verify the required parameter 'list_type' is set
        if self.api_client.client_side_validation and ('list_type' not in local_var_params or  # noqa: E501
                                                        local_var_params['list_type'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `list_type` when calling `get_product_filters_vendor_v2`")  # noqa: E501
        # verify the required parameter 'product_id' is set
        if self.api_client.client_side_validation and ('product_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['product_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `product_id` when calling `get_product_filters_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'list_type' in local_var_params:
            path_params['listType'] = local_var_params['list_type']  # noqa: E501
        if 'product_id' in local_var_params:
            path_params['productId'] = local_var_params['product_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/offerfilters/{listType}/products/{productId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='OfferFilterApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_product_metrics_by_contract(self, contract_id, start, end, **kwargs):  # noqa: E501
        """get_product_metrics_by_contract  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_product_metrics_by_contract(contract_id, start, end, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param datetime start: (required)
        :param datetime end: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_product_metrics_by_contract_with_http_info(contract_id, start, end, **kwargs)  # noqa: E501

    def get_product_metrics_by_contract_with_http_info(self, contract_id, start, end, **kwargs):  # noqa: E501
        """get_product_metrics_by_contract  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_product_metrics_by_contract_with_http_info(contract_id, start, end, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param datetime start: (required)
        :param datetime end: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'start',
            'end'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_product_metrics_by_contract" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_product_metrics_by_contract`")  # noqa: E501
        # verify the required parameter 'start' is set
        if self.api_client.client_side_validation and ('start' not in local_var_params or  # noqa: E501
                                                        local_var_params['start'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `start` when calling `get_product_metrics_by_contract`")  # noqa: E501
        # verify the required parameter 'end' is set
        if self.api_client.client_side_validation and ('end' not in local_var_params or  # noqa: E501
                                                        local_var_params['end'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `end` when calling `get_product_metrics_by_contract`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []
        if 'start' in local_var_params and local_var_params['start'] is not None:  # noqa: E501
            query_params.append(('start', local_var_params['start']))  # noqa: E501
        if 'end' in local_var_params and local_var_params['end'] is not None:  # noqa: E501
            query_params.append(('end', local_var_params['end']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/1/{contractId}/products/articlescountbyportal', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_product_monitoring_status_stats_vendor_v3(self, contract_id, **kwargs):  # noqa: E501
        """get_product_monitoring_status_stats_vendor_v3  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_product_monitoring_status_stats_vendor_v3(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: GetProductMonitoringStatusStatsVendorV3ApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_product_monitoring_status_stats_vendor_v3_with_http_info(contract_id, **kwargs)  # noqa: E501

    def get_product_monitoring_status_stats_vendor_v3_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """get_product_monitoring_status_stats_vendor_v3  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_product_monitoring_status_stats_vendor_v3_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(GetProductMonitoringStatusStatsVendorV3ApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_product_monitoring_status_stats_vendor_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_product_monitoring_status_stats_vendor_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/vendor/contracts/{contractId}/products/monitoringstatus/stats', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetProductMonitoringStatusStatsVendorV3ApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_product_price_violations_manufacturer_v2(self, contract_id, start, end, include_delivery_costs, reference_price_delta, **kwargs):  # noqa: E501
        """get_product_price_violations_manufacturer_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_product_price_violations_manufacturer_v2(contract_id, start, end, include_delivery_costs, reference_price_delta, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param datetime start: (required)
        :param datetime end: (required)
        :param bool include_delivery_costs: (required)
        :param float reference_price_delta: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_product_price_violations_manufacturer_v2_with_http_info(contract_id, start, end, include_delivery_costs, reference_price_delta, **kwargs)  # noqa: E501

    def get_product_price_violations_manufacturer_v2_with_http_info(self, contract_id, start, end, include_delivery_costs, reference_price_delta, **kwargs):  # noqa: E501
        """get_product_price_violations_manufacturer_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_product_price_violations_manufacturer_v2_with_http_info(contract_id, start, end, include_delivery_costs, reference_price_delta, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param datetime start: (required)
        :param datetime end: (required)
        :param bool include_delivery_costs: (required)
        :param float reference_price_delta: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'start',
            'end',
            'include_delivery_costs',
            'reference_price_delta'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_product_price_violations_manufacturer_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_product_price_violations_manufacturer_v2`")  # noqa: E501
        # verify the required parameter 'start' is set
        if self.api_client.client_side_validation and ('start' not in local_var_params or  # noqa: E501
                                                        local_var_params['start'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `start` when calling `get_product_price_violations_manufacturer_v2`")  # noqa: E501
        # verify the required parameter 'end' is set
        if self.api_client.client_side_validation and ('end' not in local_var_params or  # noqa: E501
                                                        local_var_params['end'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `end` when calling `get_product_price_violations_manufacturer_v2`")  # noqa: E501
        # verify the required parameter 'include_delivery_costs' is set
        if self.api_client.client_side_validation and ('include_delivery_costs' not in local_var_params or  # noqa: E501
                                                        local_var_params['include_delivery_costs'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `include_delivery_costs` when calling `get_product_price_violations_manufacturer_v2`")  # noqa: E501
        # verify the required parameter 'reference_price_delta' is set
        if self.api_client.client_side_validation and ('reference_price_delta' not in local_var_params or  # noqa: E501
                                                        local_var_params['reference_price_delta'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `reference_price_delta` when calling `get_product_price_violations_manufacturer_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []
        if 'start' in local_var_params and local_var_params['start'] is not None:  # noqa: E501
            query_params.append(('start', local_var_params['start']))  # noqa: E501
        if 'end' in local_var_params and local_var_params['end'] is not None:  # noqa: E501
            query_params.append(('end', local_var_params['end']))  # noqa: E501
        if 'include_delivery_costs' in local_var_params and local_var_params['include_delivery_costs'] is not None:  # noqa: E501
            query_params.append(('includeDeliveryCosts', local_var_params['include_delivery_costs']))  # noqa: E501
        if 'reference_price_delta' in local_var_params and local_var_params['reference_price_delta'] is not None:  # noqa: E501
            query_params.append(('referencePriceDelta', local_var_params['reference_price_delta']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/m/contracts/{contractId}/result/priceviolations', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_product_price_violations_vendor_v2(self, contract_id, start, end, include_delivery_costs, reference_price_delta, **kwargs):  # noqa: E501
        """get_product_price_violations_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_product_price_violations_vendor_v2(contract_id, start, end, include_delivery_costs, reference_price_delta, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param datetime start: (required)
        :param datetime end: (required)
        :param bool include_delivery_costs: (required)
        :param float reference_price_delta: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_product_price_violations_vendor_v2_with_http_info(contract_id, start, end, include_delivery_costs, reference_price_delta, **kwargs)  # noqa: E501

    def get_product_price_violations_vendor_v2_with_http_info(self, contract_id, start, end, include_delivery_costs, reference_price_delta, **kwargs):  # noqa: E501
        """get_product_price_violations_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_product_price_violations_vendor_v2_with_http_info(contract_id, start, end, include_delivery_costs, reference_price_delta, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param datetime start: (required)
        :param datetime end: (required)
        :param bool include_delivery_costs: (required)
        :param float reference_price_delta: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'start',
            'end',
            'include_delivery_costs',
            'reference_price_delta'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_product_price_violations_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_product_price_violations_vendor_v2`")  # noqa: E501
        # verify the required parameter 'start' is set
        if self.api_client.client_side_validation and ('start' not in local_var_params or  # noqa: E501
                                                        local_var_params['start'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `start` when calling `get_product_price_violations_vendor_v2`")  # noqa: E501
        # verify the required parameter 'end' is set
        if self.api_client.client_side_validation and ('end' not in local_var_params or  # noqa: E501
                                                        local_var_params['end'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `end` when calling `get_product_price_violations_vendor_v2`")  # noqa: E501
        # verify the required parameter 'include_delivery_costs' is set
        if self.api_client.client_side_validation and ('include_delivery_costs' not in local_var_params or  # noqa: E501
                                                        local_var_params['include_delivery_costs'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `include_delivery_costs` when calling `get_product_price_violations_vendor_v2`")  # noqa: E501
        # verify the required parameter 'reference_price_delta' is set
        if self.api_client.client_side_validation and ('reference_price_delta' not in local_var_params or  # noqa: E501
                                                        local_var_params['reference_price_delta'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `reference_price_delta` when calling `get_product_price_violations_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []
        if 'start' in local_var_params and local_var_params['start'] is not None:  # noqa: E501
            query_params.append(('start', local_var_params['start']))  # noqa: E501
        if 'end' in local_var_params and local_var_params['end'] is not None:  # noqa: E501
            query_params.append(('end', local_var_params['end']))  # noqa: E501
        if 'include_delivery_costs' in local_var_params and local_var_params['include_delivery_costs'] is not None:  # noqa: E501
            query_params.append(('includeDeliveryCosts', local_var_params['include_delivery_costs']))  # noqa: E501
        if 'reference_price_delta' in local_var_params and local_var_params['reference_price_delta'] is not None:  # noqa: E501
            query_params.append(('referencePriceDelta', local_var_params['reference_price_delta']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/result/priceviolations', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_repricing_strategy_vendor_v2(self, contract_id, **kwargs):  # noqa: E501
        """get_repricing_strategy_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_repricing_strategy_vendor_v2(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_repricing_strategy_vendor_v2_with_http_info(contract_id, **kwargs)  # noqa: E501

    def get_repricing_strategy_vendor_v2_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """get_repricing_strategy_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_repricing_strategy_vendor_v2_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_repricing_strategy_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_repricing_strategy_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/settings/repricingstrategy', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_settings(self, contract_id, **kwargs):  # noqa: E501
        """get_settings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_settings(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ComPatagonaPricemonitorShareApiGetContractSettingsResponseV1
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_settings_with_http_info(contract_id, **kwargs)  # noqa: E501

    def get_settings_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """get_settings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_settings_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ComPatagonaPricemonitorShareApiGetContractSettingsResponseV1, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_settings" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_settings`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/1/{contractId}/settings', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ComPatagonaPricemonitorShareApiGetContractSettingsResponseV1',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_tag_values_manufacturer_v2(self, contract_id, key, **kwargs):  # noqa: E501
        """get_tag_values_manufacturer_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_tag_values_manufacturer_v2(contract_id, key, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str key: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_tag_values_manufacturer_v2_with_http_info(contract_id, key, **kwargs)  # noqa: E501

    def get_tag_values_manufacturer_v2_with_http_info(self, contract_id, key, **kwargs):  # noqa: E501
        """get_tag_values_manufacturer_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_tag_values_manufacturer_v2_with_http_info(contract_id, key, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str key: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'key'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_tag_values_manufacturer_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_tag_values_manufacturer_v2`")  # noqa: E501
        # verify the required parameter 'key' is set
        if self.api_client.client_side_validation and ('key' not in local_var_params or  # noqa: E501
                                                        local_var_params['key'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `key` when calling `get_tag_values_manufacturer_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'key' in local_var_params:
            path_params['key'] = local_var_params['key']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/m/contracts/{contractId}/products/tags/{key}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_tag_values_vendor_v2(self, contract_id, key, **kwargs):  # noqa: E501
        """get_tag_values_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_tag_values_vendor_v2(contract_id, key, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str key: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_tag_values_vendor_v2_with_http_info(contract_id, key, **kwargs)  # noqa: E501

    def get_tag_values_vendor_v2_with_http_info(self, contract_id, key, **kwargs):  # noqa: E501
        """get_tag_values_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_tag_values_vendor_v2_with_http_info(contract_id, key, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str key: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'key'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_tag_values_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_tag_values_vendor_v2`")  # noqa: E501
        # verify the required parameter 'key' is set
        if self.api_client.client_side_validation and ('key' not in local_var_params or  # noqa: E501
                                                        local_var_params['key'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `key` when calling `get_tag_values_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'key' in local_var_params:
            path_params['key'] = local_var_params['key']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/products/tags/{key}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_tags_manufacturer_v2(self, contract_id, **kwargs):  # noqa: E501
        """get_tags_manufacturer_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_tags_manufacturer_v2(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_tags_manufacturer_v2_with_http_info(contract_id, **kwargs)  # noqa: E501

    def get_tags_manufacturer_v2_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """get_tags_manufacturer_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_tags_manufacturer_v2_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_tags_manufacturer_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_tags_manufacturer_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/m/contracts/{contractId}/products/tags', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_tags_vendor_v2(self, contract_id, **kwargs):  # noqa: E501
        """get_tags_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_tags_vendor_v2(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_tags_vendor_v2_with_http_info(contract_id, **kwargs)  # noqa: E501

    def get_tags_vendor_v2_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """get_tags_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_tags_vendor_v2_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_tags_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_tags_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/products/tags', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_task(self, contract_id, task_id, **kwargs):  # noqa: E501
        """get_task  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_task(contract_id, task_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str task_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_task_with_http_info(contract_id, task_id, **kwargs)  # noqa: E501

    def get_task_with_http_info(self, contract_id, task_id, **kwargs):  # noqa: E501
        """get_task  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_task_with_http_info(contract_id, task_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str task_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'task_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_task" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_task`")  # noqa: E501
        # verify the required parameter 'task_id' is set
        if self.api_client.client_side_validation and ('task_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['task_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `task_id` when calling `get_task`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'task_id' in local_var_params:
            path_params['taskId'] = local_var_params['task_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/1/{contractId}/tasks/{taskId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_task_data_manufacturer_v2(self, contract_id, task_id, **kwargs):  # noqa: E501
        """get_task_data_manufacturer_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_task_data_manufacturer_v2(contract_id, task_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str task_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_task_data_manufacturer_v2_with_http_info(contract_id, task_id, **kwargs)  # noqa: E501

    def get_task_data_manufacturer_v2_with_http_info(self, contract_id, task_id, **kwargs):  # noqa: E501
        """get_task_data_manufacturer_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_task_data_manufacturer_v2_with_http_info(contract_id, task_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str task_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'task_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_task_data_manufacturer_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_task_data_manufacturer_v2`")  # noqa: E501
        # verify the required parameter 'task_id' is set
        if self.api_client.client_side_validation and ('task_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['task_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `task_id` when calling `get_task_data_manufacturer_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'task_id' in local_var_params:
            path_params['taskId'] = local_var_params['task_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/m/contracts/{contractId}/tasks/{taskId}/data', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_task_data_vendor_v2(self, contract_id, task_id, **kwargs):  # noqa: E501
        """get_task_data_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_task_data_vendor_v2(contract_id, task_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str task_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_task_data_vendor_v2_with_http_info(contract_id, task_id, **kwargs)  # noqa: E501

    def get_task_data_vendor_v2_with_http_info(self, contract_id, task_id, **kwargs):  # noqa: E501
        """get_task_data_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_task_data_vendor_v2_with_http_info(contract_id, task_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str task_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'task_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_task_data_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_task_data_vendor_v2`")  # noqa: E501
        # verify the required parameter 'task_id' is set
        if self.api_client.client_side_validation and ('task_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['task_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `task_id` when calling `get_task_data_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'task_id' in local_var_params:
            path_params['taskId'] = local_var_params['task_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/tasks/{taskId}/data', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_task_manufacturer_v2(self, contract_id, task_id, **kwargs):  # noqa: E501
        """get_task_manufacturer_v2  # noqa: E501

        Get the task designated by the taskId parameter  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_task_manufacturer_v2(contract_id, task_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str task_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: GenericTask
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_task_manufacturer_v2_with_http_info(contract_id, task_id, **kwargs)  # noqa: E501

    def get_task_manufacturer_v2_with_http_info(self, contract_id, task_id, **kwargs):  # noqa: E501
        """get_task_manufacturer_v2  # noqa: E501

        Get the task designated by the taskId parameter  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_task_manufacturer_v2_with_http_info(contract_id, task_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str task_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(GenericTask, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'task_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_task_manufacturer_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_task_manufacturer_v2`")  # noqa: E501
        # verify the required parameter 'task_id' is set
        if self.api_client.client_side_validation and ('task_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['task_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `task_id` when calling `get_task_manufacturer_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'task_id' in local_var_params:
            path_params['taskId'] = local_var_params['task_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/m/contracts/{contractId}/tasks/{taskId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GenericTask',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_task_state(self, contract_id, task_id, **kwargs):  # noqa: E501
        """get_task_state  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_task_state(contract_id, task_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str task_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_task_state_with_http_info(contract_id, task_id, **kwargs)  # noqa: E501

    def get_task_state_with_http_info(self, contract_id, task_id, **kwargs):  # noqa: E501
        """get_task_state  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_task_state_with_http_info(contract_id, task_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str task_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'task_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_task_state" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_task_state`")  # noqa: E501
        # verify the required parameter 'task_id' is set
        if self.api_client.client_side_validation and ('task_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['task_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `task_id` when calling `get_task_state`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'task_id' in local_var_params:
            path_params['taskId'] = local_var_params['task_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/1/{contractId}/tasks/{taskId}/state', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_tasks(self, contract_id, tasks, attributes, limit, **kwargs):  # noqa: E501
        """get_tasks  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_tasks(contract_id, tasks, attributes, limit, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str tasks: (required)
        :param str attributes: (required)
        :param int limit: (required)
        :param str task_type:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_tasks_with_http_info(contract_id, tasks, attributes, limit, **kwargs)  # noqa: E501

    def get_tasks_with_http_info(self, contract_id, tasks, attributes, limit, **kwargs):  # noqa: E501
        """get_tasks  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_tasks_with_http_info(contract_id, tasks, attributes, limit, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str tasks: (required)
        :param str attributes: (required)
        :param int limit: (required)
        :param str task_type:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'tasks',
            'attributes',
            'limit',
            'task_type'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_tasks" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_tasks`")  # noqa: E501
        # verify the required parameter 'tasks' is set
        if self.api_client.client_side_validation and ('tasks' not in local_var_params or  # noqa: E501
                                                        local_var_params['tasks'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `tasks` when calling `get_tasks`")  # noqa: E501
        # verify the required parameter 'attributes' is set
        if self.api_client.client_side_validation and ('attributes' not in local_var_params or  # noqa: E501
                                                        local_var_params['attributes'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `attributes` when calling `get_tasks`")  # noqa: E501
        # verify the required parameter 'limit' is set
        if self.api_client.client_side_validation and ('limit' not in local_var_params or  # noqa: E501
                                                        local_var_params['limit'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `limit` when calling `get_tasks`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []
        if 'tasks' in local_var_params and local_var_params['tasks'] is not None:  # noqa: E501
            query_params.append(('tasks', local_var_params['tasks']))  # noqa: E501
        if 'attributes' in local_var_params and local_var_params['attributes'] is not None:  # noqa: E501
            query_params.append(('attributes', local_var_params['attributes']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'task_type' in local_var_params and local_var_params['task_type'] is not None:  # noqa: E501
            query_params.append(('taskType', local_var_params['task_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/1/{contractId}/tasks', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_tasks_manufacturer_v2(self, contract_id, task_type_filter, task_state, limit, include_failures, **kwargs):  # noqa: E501
        """get_tasks_manufacturer_v2  # noqa: E501

        Returns a list of task objects for the given contract  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_tasks_manufacturer_v2(contract_id, task_type_filter, task_state, limit, include_failures, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param list[str] task_type_filter: A list of task types to filter for (required)
        :param list[str] task_state: A list of task states to filter for (required)
        :param int limit: The maximum number of tasks returned (required)
        :param bool include_failures: Include failed tasks (required)
        :param str task_ids_filter: Comma separated list of task IDs to filter for
        :param datetime min_creation_date: Ignore all tasks created earlier than this date (ISO 8601)
        :param datetime max_creation_date: Ignore all tasks created later than this date (ISO 8601)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: list[GenericTask]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_tasks_manufacturer_v2_with_http_info(contract_id, task_type_filter, task_state, limit, include_failures, **kwargs)  # noqa: E501

    def get_tasks_manufacturer_v2_with_http_info(self, contract_id, task_type_filter, task_state, limit, include_failures, **kwargs):  # noqa: E501
        """get_tasks_manufacturer_v2  # noqa: E501

        Returns a list of task objects for the given contract  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_tasks_manufacturer_v2_with_http_info(contract_id, task_type_filter, task_state, limit, include_failures, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param list[str] task_type_filter: A list of task types to filter for (required)
        :param list[str] task_state: A list of task states to filter for (required)
        :param int limit: The maximum number of tasks returned (required)
        :param bool include_failures: Include failed tasks (required)
        :param str task_ids_filter: Comma separated list of task IDs to filter for
        :param datetime min_creation_date: Ignore all tasks created earlier than this date (ISO 8601)
        :param datetime max_creation_date: Ignore all tasks created later than this date (ISO 8601)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(list[GenericTask], status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'task_type_filter',
            'task_state',
            'limit',
            'include_failures',
            'task_ids_filter',
            'min_creation_date',
            'max_creation_date'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_tasks_manufacturer_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_tasks_manufacturer_v2`")  # noqa: E501
        # verify the required parameter 'task_type_filter' is set
        if self.api_client.client_side_validation and ('task_type_filter' not in local_var_params or  # noqa: E501
                                                        local_var_params['task_type_filter'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `task_type_filter` when calling `get_tasks_manufacturer_v2`")  # noqa: E501
        # verify the required parameter 'task_state' is set
        if self.api_client.client_side_validation and ('task_state' not in local_var_params or  # noqa: E501
                                                        local_var_params['task_state'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `task_state` when calling `get_tasks_manufacturer_v2`")  # noqa: E501
        # verify the required parameter 'limit' is set
        if self.api_client.client_side_validation and ('limit' not in local_var_params or  # noqa: E501
                                                        local_var_params['limit'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `limit` when calling `get_tasks_manufacturer_v2`")  # noqa: E501
        # verify the required parameter 'include_failures' is set
        if self.api_client.client_side_validation and ('include_failures' not in local_var_params or  # noqa: E501
                                                        local_var_params['include_failures'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `include_failures` when calling `get_tasks_manufacturer_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []
        if 'task_ids_filter' in local_var_params and local_var_params['task_ids_filter'] is not None:  # noqa: E501
            query_params.append(('taskIdsFilter', local_var_params['task_ids_filter']))  # noqa: E501
        if 'task_type_filter' in local_var_params and local_var_params['task_type_filter'] is not None:  # noqa: E501
            query_params.append(('taskTypeFilter', local_var_params['task_type_filter']))  # noqa: E501
            collection_formats['taskTypeFilter'] = 'multi'  # noqa: E501
        if 'task_state' in local_var_params and local_var_params['task_state'] is not None:  # noqa: E501
            query_params.append(('taskState', local_var_params['task_state']))  # noqa: E501
            collection_formats['taskState'] = 'multi'  # noqa: E501
        if 'min_creation_date' in local_var_params and local_var_params['min_creation_date'] is not None:  # noqa: E501
            query_params.append(('minCreationDate', local_var_params['min_creation_date']))  # noqa: E501
        if 'max_creation_date' in local_var_params and local_var_params['max_creation_date'] is not None:  # noqa: E501
            query_params.append(('maxCreationDate', local_var_params['max_creation_date']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'include_failures' in local_var_params and local_var_params['include_failures'] is not None:  # noqa: E501
            query_params.append(('includeFailures', local_var_params['include_failures']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/m/contracts/{contractId}/tasks', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[GenericTask]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_tasks_stats(self, since_seconds, **kwargs):  # noqa: E501
        """get_tasks_stats  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_tasks_stats(since_seconds, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int since_seconds: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_tasks_stats_with_http_info(since_seconds, **kwargs)  # noqa: E501

    def get_tasks_stats_with_http_info(self, since_seconds, **kwargs):  # noqa: E501
        """get_tasks_stats  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_tasks_stats_with_http_info(since_seconds, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int since_seconds: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'since_seconds'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_tasks_stats" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'since_seconds' is set
        if self.api_client.client_side_validation and ('since_seconds' not in local_var_params or  # noqa: E501
                                                        local_var_params['since_seconds'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `since_seconds` when calling `get_tasks_stats`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'since_seconds' in local_var_params and local_var_params['since_seconds'] is not None:  # noqa: E501
            query_params.append(('sinceSeconds', local_var_params['since_seconds']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/controlpanel/api/tasks/stats', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_time_stamps(self, contract_id, **kwargs):  # noqa: E501
        """get_time_stamps  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_time_stamps(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int contract_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_time_stamps_with_http_info(contract_id, **kwargs)  # noqa: E501

    def get_time_stamps_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """get_time_stamps  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_time_stamps_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int contract_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_time_stamps" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_time_stamps`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/1/{contractId}/products/analysis/timestamps', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_user(self, email, **kwargs):  # noqa: E501
        """get_user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_user(email, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str email: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_user_with_http_info(email, **kwargs)  # noqa: E501

    def get_user_with_http_info(self, email, **kwargs):  # noqa: E501
        """get_user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_user_with_http_info(email, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str email: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'email'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_user" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'email' is set
        if self.api_client.client_side_validation and ('email' not in local_var_params or  # noqa: E501
                                                        local_var_params['email'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `email` when calling `get_user`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'email' in local_var_params:
            path_params['email'] = local_var_params['email']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/controlpanel/api/users/{email}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_users(self, company_id, **kwargs):  # noqa: E501
        """get_users  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_users(company_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int company_id: ID of a company (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_users_with_http_info(company_id, **kwargs)  # noqa: E501

    def get_users_with_http_info(self, company_id, **kwargs):  # noqa: E501
        """get_users  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_users_with_http_info(company_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int company_id: ID of a company (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'company_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_users" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'company_id' is set
        if self.api_client.client_side_validation and ('company_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['company_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `company_id` when calling `get_users`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'company_id' in local_var_params:
            path_params['companyId'] = local_var_params['company_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/controlpanel/api/companies/{companyId}/users', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_vendor_settings_v2_vendor_v2(self, contract_id, **kwargs):  # noqa: E501
        """get_vendor_settings_v2_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_vendor_settings_v2_vendor_v2(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_vendor_settings_v2_vendor_v2_with_http_info(contract_id, **kwargs)  # noqa: E501

    def get_vendor_settings_v2_vendor_v2_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """get_vendor_settings_v2_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_vendor_settings_v2_vendor_v2_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_vendor_settings_v2_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_vendor_settings_v2_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/settings/repricing', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_vendor_shop_mapping_manufacturer_v3(self, contract_id, vendor_id, **kwargs):  # noqa: E501
        """Get vendor along with their associated shop for given vendor id and contract.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_vendor_shop_mapping_manufacturer_v3(contract_id, vendor_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param int vendor_id: ID of vendor shop mapping (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: VendorShopMappingV3ApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_vendor_shop_mapping_manufacturer_v3_with_http_info(contract_id, vendor_id, **kwargs)  # noqa: E501

    def get_vendor_shop_mapping_manufacturer_v3_with_http_info(self, contract_id, vendor_id, **kwargs):  # noqa: E501
        """Get vendor along with their associated shop for given vendor id and contract.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_vendor_shop_mapping_manufacturer_v3_with_http_info(contract_id, vendor_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param int vendor_id: ID of vendor shop mapping (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(VendorShopMappingV3ApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'vendor_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_vendor_shop_mapping_manufacturer_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_vendor_shop_mapping_manufacturer_v3`")  # noqa: E501
        # verify the required parameter 'vendor_id' is set
        if self.api_client.client_side_validation and ('vendor_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['vendor_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `vendor_id` when calling `get_vendor_shop_mapping_manufacturer_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'vendor_id' in local_var_params:
            path_params['vendorId'] = local_var_params['vendor_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/manufacturer/contracts/{contractId}/vendors/{vendorId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='VendorShopMappingV3ApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_vendor_shop_mappings_manufacturer_v3(self, contract_id, **kwargs):  # noqa: E501
        """Get all the vendors along with their associated shops for a specified contract.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_vendor_shop_mappings_manufacturer_v3(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: GetVendorShopMappingsApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_vendor_shop_mappings_manufacturer_v3_with_http_info(contract_id, **kwargs)  # noqa: E501

    def get_vendor_shop_mappings_manufacturer_v3_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Get all the vendors along with their associated shops for a specified contract.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_vendor_shop_mappings_manufacturer_v3_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(GetVendorShopMappingsApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_vendor_shop_mappings_manufacturer_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_vendor_shop_mappings_manufacturer_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/manufacturer/contracts/{contractId}/vendors', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetVendorShopMappingsApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_vendor_v3(self, contract_id, **kwargs):  # noqa: E501
        """get_vendor_v3  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_vendor_v3(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_vendor_v3_with_http_info(contract_id, **kwargs)  # noqa: E501

    def get_vendor_v3_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """get_vendor_v3  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_vendor_v3_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_vendor_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_vendor_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/vendor/contracts/{contractId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_vendor_vendor_v2(self, contract_id, **kwargs):  # noqa: E501
        """get_vendor_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_vendor_vendor_v2(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_vendor_vendor_v2_with_http_info(contract_id, **kwargs)  # noqa: E501

    def get_vendor_vendor_v2_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """get_vendor_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_vendor_vendor_v2_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_vendor_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_vendor_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_vendors_by_domain_manufacturer_v2(self, contract_id, domain, start, include_delivery_costs, session, **kwargs):  # noqa: E501
        """get_vendors_by_domain_manufacturer_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_vendors_by_domain_manufacturer_v2(contract_id, domain, start, include_delivery_costs, session, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str domain: (required)
        :param int start: (required)
        :param bool include_delivery_costs: (required)
        :param datetime session: (required)
        :param ComPatagonaPricemonitorShareApiTagFilteredVendorsRequest com_patagona_pricemonitor_share_api_tag_filtered_vendors_request: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ComPatagonaPricemonitorShareApiPostVendorsByDomainResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_vendors_by_domain_manufacturer_v2_with_http_info(contract_id, domain, start, include_delivery_costs, session, **kwargs)  # noqa: E501

    def get_vendors_by_domain_manufacturer_v2_with_http_info(self, contract_id, domain, start, include_delivery_costs, session, **kwargs):  # noqa: E501
        """get_vendors_by_domain_manufacturer_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_vendors_by_domain_manufacturer_v2_with_http_info(contract_id, domain, start, include_delivery_costs, session, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str domain: (required)
        :param int start: (required)
        :param bool include_delivery_costs: (required)
        :param datetime session: (required)
        :param ComPatagonaPricemonitorShareApiTagFilteredVendorsRequest com_patagona_pricemonitor_share_api_tag_filtered_vendors_request: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ComPatagonaPricemonitorShareApiPostVendorsByDomainResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'domain',
            'start',
            'include_delivery_costs',
            'session',
            'com_patagona_pricemonitor_share_api_tag_filtered_vendors_request'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_vendors_by_domain_manufacturer_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `get_vendors_by_domain_manufacturer_v2`")  # noqa: E501
        # verify the required parameter 'domain' is set
        if self.api_client.client_side_validation and ('domain' not in local_var_params or  # noqa: E501
                                                        local_var_params['domain'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `domain` when calling `get_vendors_by_domain_manufacturer_v2`")  # noqa: E501
        # verify the required parameter 'start' is set
        if self.api_client.client_side_validation and ('start' not in local_var_params or  # noqa: E501
                                                        local_var_params['start'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `start` when calling `get_vendors_by_domain_manufacturer_v2`")  # noqa: E501
        # verify the required parameter 'include_delivery_costs' is set
        if self.api_client.client_side_validation and ('include_delivery_costs' not in local_var_params or  # noqa: E501
                                                        local_var_params['include_delivery_costs'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `include_delivery_costs` when calling `get_vendors_by_domain_manufacturer_v2`")  # noqa: E501
        # verify the required parameter 'session' is set
        if self.api_client.client_side_validation and ('session' not in local_var_params or  # noqa: E501
                                                        local_var_params['session'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `session` when calling `get_vendors_by_domain_manufacturer_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []
        if 'domain' in local_var_params and local_var_params['domain'] is not None:  # noqa: E501
            query_params.append(('domain', local_var_params['domain']))  # noqa: E501
        if 'start' in local_var_params and local_var_params['start'] is not None:  # noqa: E501
            query_params.append(('start', local_var_params['start']))  # noqa: E501
        if 'include_delivery_costs' in local_var_params and local_var_params['include_delivery_costs'] is not None:  # noqa: E501
            query_params.append(('includeDeliveryCosts', local_var_params['include_delivery_costs']))  # noqa: E501
        if 'session' in local_var_params and local_var_params['session'] is not None:  # noqa: E501
            query_params.append(('session', local_var_params['session']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'com_patagona_pricemonitor_share_api_tag_filtered_vendors_request' in local_var_params:
            body_params = local_var_params['com_patagona_pricemonitor_share_api_tag_filtered_vendors_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/m/contracts/{contractId}/result/vendors/list', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ComPatagonaPricemonitorShareApiPostVendorsByDomainResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_vendors(self, name_filter, **kwargs):  # noqa: E501
        """list_vendors  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_vendors(name_filter, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str name_filter: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.list_vendors_with_http_info(name_filter, **kwargs)  # noqa: E501

    def list_vendors_with_http_info(self, name_filter, **kwargs):  # noqa: E501
        """list_vendors  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_vendors_with_http_info(name_filter, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str name_filter: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'name_filter'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_vendors" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'name_filter' is set
        if self.api_client.client_side_validation and ('name_filter' not in local_var_params or  # noqa: E501
                                                        local_var_params['name_filter'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `name_filter` when calling `list_vendors`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'name_filter' in local_var_params and local_var_params['name_filter'] is not None:  # noqa: E501
            query_params.append(('nameFilter', local_var_params['name_filter']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/controlpanel/vendors', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def login_by_auth_token(self, token, **kwargs):  # noqa: E501
        """login_by_auth_token  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.login_by_auth_token(token, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str token: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.login_by_auth_token_with_http_info(token, **kwargs)  # noqa: E501

    def login_by_auth_token_with_http_info(self, token, **kwargs):  # noqa: E501
        """login_by_auth_token  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.login_by_auth_token_with_http_info(token, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str token: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'token'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method login_by_auth_token" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'token' is set
        if self.api_client.client_side_validation and ('token' not in local_var_params or  # noqa: E501
                                                        local_var_params['token'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `token` when calling `login_by_auth_token`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'token' in local_var_params:
            path_params['token'] = local_var_params['token']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/login/token/{token}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def monitoring_pipeline_post_request_manufacturer_v3(self, contract_id, path, **kwargs):  # noqa: E501
        """monitoring_pipeline_post_request_manufacturer_v3  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.monitoring_pipeline_post_request_manufacturer_v3(contract_id, path, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str path: The monitoring-pipeline path to be called (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.monitoring_pipeline_post_request_manufacturer_v3_with_http_info(contract_id, path, **kwargs)  # noqa: E501

    def monitoring_pipeline_post_request_manufacturer_v3_with_http_info(self, contract_id, path, **kwargs):  # noqa: E501
        """monitoring_pipeline_post_request_manufacturer_v3  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.monitoring_pipeline_post_request_manufacturer_v3_with_http_info(contract_id, path, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str path: The monitoring-pipeline path to be called (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'path'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method monitoring_pipeline_post_request_manufacturer_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `monitoring_pipeline_post_request_manufacturer_v3`")  # noqa: E501
        # verify the required parameter 'path' is set
        if self.api_client.client_side_validation and ('path' not in local_var_params or  # noqa: E501
                                                        local_var_params['path'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `path` when calling `monitoring_pipeline_post_request_manufacturer_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'path' in local_var_params:
            path_params['path'] = local_var_params['path']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/manufacturer/contracts/{contractId}/monitoringpipeline/{path}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def monitoring_pipeline_post_request_vendor_v3(self, contract_id, path, **kwargs):  # noqa: E501
        """monitoring_pipeline_post_request_vendor_v3  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.monitoring_pipeline_post_request_vendor_v3(contract_id, path, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str path: The monitoring-pipeline path to be called (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.monitoring_pipeline_post_request_vendor_v3_with_http_info(contract_id, path, **kwargs)  # noqa: E501

    def monitoring_pipeline_post_request_vendor_v3_with_http_info(self, contract_id, path, **kwargs):  # noqa: E501
        """monitoring_pipeline_post_request_vendor_v3  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.monitoring_pipeline_post_request_vendor_v3_with_http_info(contract_id, path, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str path: The monitoring-pipeline path to be called (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'path'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method monitoring_pipeline_post_request_vendor_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `monitoring_pipeline_post_request_vendor_v3`")  # noqa: E501
        # verify the required parameter 'path' is set
        if self.api_client.client_side_validation and ('path' not in local_var_params or  # noqa: E501
                                                        local_var_params['path'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `path` when calling `monitoring_pipeline_post_request_vendor_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'path' in local_var_params:
            path_params['path'] = local_var_params['path']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/vendor/contracts/{contractId}/monitoringpipeline/{path}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def monitoring_pipeline_upsert_search_attempts_manufacturer_v3(self, contract_id, **kwargs):  # noqa: E501
        """monitoring_pipeline_upsert_search_attempts_manufacturer_v3  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.monitoring_pipeline_upsert_search_attempts_manufacturer_v3(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.monitoring_pipeline_upsert_search_attempts_manufacturer_v3_with_http_info(contract_id, **kwargs)  # noqa: E501

    def monitoring_pipeline_upsert_search_attempts_manufacturer_v3_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """monitoring_pipeline_upsert_search_attempts_manufacturer_v3  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.monitoring_pipeline_upsert_search_attempts_manufacturer_v3_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method monitoring_pipeline_upsert_search_attempts_manufacturer_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `monitoring_pipeline_upsert_search_attempts_manufacturer_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/manufacturer/contracts/{contractId}/monitoringpipeline/v1/searchattempts', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def monitoring_pipeline_upsert_search_attempts_vendor_v3(self, contract_id, **kwargs):  # noqa: E501
        """monitoring_pipeline_upsert_search_attempts_vendor_v3  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.monitoring_pipeline_upsert_search_attempts_vendor_v3(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.monitoring_pipeline_upsert_search_attempts_vendor_v3_with_http_info(contract_id, **kwargs)  # noqa: E501

    def monitoring_pipeline_upsert_search_attempts_vendor_v3_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """monitoring_pipeline_upsert_search_attempts_vendor_v3  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.monitoring_pipeline_upsert_search_attempts_vendor_v3_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method monitoring_pipeline_upsert_search_attempts_vendor_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `monitoring_pipeline_upsert_search_attempts_vendor_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/vendor/contracts/{contractId}/monitoringpipeline/v1/searchattempts', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_product_manufacturer_v3(self, contract_id, product_id, **kwargs):  # noqa: E501
        """patch_product_manufacturer_v3  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_product_manufacturer_v3(contract_id, product_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str product_id: (required)
        :param object body: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.patch_product_manufacturer_v3_with_http_info(contract_id, product_id, **kwargs)  # noqa: E501

    def patch_product_manufacturer_v3_with_http_info(self, contract_id, product_id, **kwargs):  # noqa: E501
        """patch_product_manufacturer_v3  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_product_manufacturer_v3_with_http_info(contract_id, product_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str product_id: (required)
        :param object body: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'product_id',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_product_manufacturer_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `patch_product_manufacturer_v3`")  # noqa: E501
        # verify the required parameter 'product_id' is set
        if self.api_client.client_side_validation and ('product_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['product_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `product_id` when calling `patch_product_manufacturer_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'product_id' in local_var_params:
            path_params['productId'] = local_var_params['product_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/manufacturer/contracts/{contractId}/products/{productId}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def patch_product_vendor_v3(self, contract_id, product_id, **kwargs):  # noqa: E501
        """patch_product_vendor_v3  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_product_vendor_v3(contract_id, product_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str product_id: (required)
        :param object body: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.patch_product_vendor_v3_with_http_info(contract_id, product_id, **kwargs)  # noqa: E501

    def patch_product_vendor_v3_with_http_info(self, contract_id, product_id, **kwargs):  # noqa: E501
        """patch_product_vendor_v3  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.patch_product_vendor_v3_with_http_info(contract_id, product_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str product_id: (required)
        :param object body: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'product_id',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_product_vendor_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `patch_product_vendor_v3`")  # noqa: E501
        # verify the required parameter 'product_id' is set
        if self.api_client.client_side_validation and ('product_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['product_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `product_id` when calling `patch_product_vendor_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'product_id' in local_var_params:
            path_params['productId'] = local_var_params['product_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/vendor/contracts/{contractId}/products/{productId}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def position_distribution(self, contract_id, vendor, day, **kwargs):  # noqa: E501
        """position_distribution  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.position_distribution(contract_id, vendor, day, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str vendor: (required)
        :param datetime day: (required)
        :param object body: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.position_distribution_with_http_info(contract_id, vendor, day, **kwargs)  # noqa: E501

    def position_distribution_with_http_info(self, contract_id, vendor, day, **kwargs):  # noqa: E501
        """position_distribution  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.position_distribution_with_http_info(contract_id, vendor, day, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str vendor: (required)
        :param datetime day: (required)
        :param object body: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'vendor',
            'day',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method position_distribution" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `position_distribution`")  # noqa: E501
        # verify the required parameter 'vendor' is set
        if self.api_client.client_side_validation and ('vendor' not in local_var_params or  # noqa: E501
                                                        local_var_params['vendor'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `vendor` when calling `position_distribution`")  # noqa: E501
        # verify the required parameter 'day' is set
        if self.api_client.client_side_validation and ('day' not in local_var_params or  # noqa: E501
                                                        local_var_params['day'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `day` when calling `position_distribution`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'vendor' in local_var_params:
            path_params['vendor'] = local_var_params['vendor']  # noqa: E501

        query_params = []
        if 'day' in local_var_params and local_var_params['day'] is not None:  # noqa: E501
            query_params.append(('day', local_var_params['day']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/1/{contractId}/vendors/{vendor}/positions', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_activate_marketplace_vendor_v3(self, company_id, **kwargs):  # noqa: E501
        """Activate marketplace of a customer in our system. By activation, it means that our system can write prices back into the customer's Amazon shop.   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_activate_marketplace_vendor_v3(company_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int company_id: ID of a company (required)
        :param ComPatagonaPricemonitorShareApiPostActivateMarketplaceRequestV3 com_patagona_pricemonitor_share_api_post_activate_marketplace_request_v3: Marketplace of a customer to be activated.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: PostActivateMarketplaceResponseV3ApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.post_activate_marketplace_vendor_v3_with_http_info(company_id, **kwargs)  # noqa: E501

    def post_activate_marketplace_vendor_v3_with_http_info(self, company_id, **kwargs):  # noqa: E501
        """Activate marketplace of a customer in our system. By activation, it means that our system can write prices back into the customer's Amazon shop.   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_activate_marketplace_vendor_v3_with_http_info(company_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int company_id: ID of a company (required)
        :param ComPatagonaPricemonitorShareApiPostActivateMarketplaceRequestV3 com_patagona_pricemonitor_share_api_post_activate_marketplace_request_v3: Marketplace of a customer to be activated.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(PostActivateMarketplaceResponseV3ApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'company_id',
            'com_patagona_pricemonitor_share_api_post_activate_marketplace_request_v3'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_activate_marketplace_vendor_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'company_id' is set
        if self.api_client.client_side_validation and ('company_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['company_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `company_id` when calling `post_activate_marketplace_vendor_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'company_id' in local_var_params:
            path_params['companyId'] = local_var_params['company_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'com_patagona_pricemonitor_share_api_post_activate_marketplace_request_v3' in local_var_params:
            body_params = local_var_params['com_patagona_pricemonitor_share_api_post_activate_marketplace_request_v3']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/companies/{companyId}/amazon/marketplace', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PostActivateMarketplaceResponseV3ApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_authorize_seller_vendor_v3(self, company_id, **kwargs):  # noqa: E501
        """Set up an OAuth authorization for a customer's Amazon Seller Central account. It establishes a connection between our system and the customer's Amazon shop using the Amazon SP-API. Once connected, our system can write prices back to the customer's Amazon shop, allowing them to benefit from our price recommendations.   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_authorize_seller_vendor_v3(company_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int company_id: ID of a company (required)
        :param ComPatagonaPricemonitorShareApiPostAuthorizeSellerRequestV3 com_patagona_pricemonitor_share_api_post_authorize_seller_request_v3: Customer's Amazon seller central account to be authorized.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: PostAuthorizeSellerResponseV3ApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.post_authorize_seller_vendor_v3_with_http_info(company_id, **kwargs)  # noqa: E501

    def post_authorize_seller_vendor_v3_with_http_info(self, company_id, **kwargs):  # noqa: E501
        """Set up an OAuth authorization for a customer's Amazon Seller Central account. It establishes a connection between our system and the customer's Amazon shop using the Amazon SP-API. Once connected, our system can write prices back to the customer's Amazon shop, allowing them to benefit from our price recommendations.   # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_authorize_seller_vendor_v3_with_http_info(company_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int company_id: ID of a company (required)
        :param ComPatagonaPricemonitorShareApiPostAuthorizeSellerRequestV3 com_patagona_pricemonitor_share_api_post_authorize_seller_request_v3: Customer's Amazon seller central account to be authorized.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(PostAuthorizeSellerResponseV3ApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'company_id',
            'com_patagona_pricemonitor_share_api_post_authorize_seller_request_v3'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_authorize_seller_vendor_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'company_id' is set
        if self.api_client.client_side_validation and ('company_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['company_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `company_id` when calling `post_authorize_seller_vendor_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'company_id' in local_var_params:
            path_params['companyId'] = local_var_params['company_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'com_patagona_pricemonitor_share_api_post_authorize_seller_request_v3' in local_var_params:
            body_params = local_var_params['com_patagona_pricemonitor_share_api_post_authorize_seller_request_v3']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/companies/{companyId}/amazon/authorization', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PostAuthorizeSellerResponseV3ApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_ebay_authorization_vendor_v2(self, contract_id, **kwargs):  # noqa: E501
        """post_ebay_authorization_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_ebay_authorization_vendor_v2(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.post_ebay_authorization_vendor_v2_with_http_info(contract_id, **kwargs)  # noqa: E501

    def post_ebay_authorization_vendor_v2_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """post_ebay_authorization_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_ebay_authorization_vendor_v2_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_ebay_authorization_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `post_ebay_authorization_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/settings/ebay/authorizations', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_embed_sso_url_manufacturer(self, contract_id, **kwargs):  # noqa: E501
        """Retrieve an embed SSO url for Looker.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_embed_sso_url_manufacturer(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param ComPatagonaPricemonitorShareApiPostEmbedSSOUrlRequestV3 com_patagona_pricemonitor_share_api_post_embed_sso_url_request_v3: Payload for retrieving a signed embed SSO url using Looker API.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: EmbedSSOUrlResponseV3ApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.post_embed_sso_url_manufacturer_with_http_info(contract_id, **kwargs)  # noqa: E501

    def post_embed_sso_url_manufacturer_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Retrieve an embed SSO url for Looker.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_embed_sso_url_manufacturer_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param ComPatagonaPricemonitorShareApiPostEmbedSSOUrlRequestV3 com_patagona_pricemonitor_share_api_post_embed_sso_url_request_v3: Payload for retrieving a signed embed SSO url using Looker API.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(EmbedSSOUrlResponseV3ApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'com_patagona_pricemonitor_share_api_post_embed_sso_url_request_v3'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_embed_sso_url_manufacturer" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `post_embed_sso_url_manufacturer`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'com_patagona_pricemonitor_share_api_post_embed_sso_url_request_v3' in local_var_params:
            body_params = local_var_params['com_patagona_pricemonitor_share_api_post_embed_sso_url_request_v3']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/manufacturer/contracts/{contractId}/looker/sso/embed/url', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EmbedSSOUrlResponseV3ApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_embed_sso_url_vendor(self, contract_id, **kwargs):  # noqa: E501
        """Retrieve an embed SSO url for Looker.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_embed_sso_url_vendor(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param ComPatagonaPricemonitorShareApiPostEmbedSSOUrlRequestV3 com_patagona_pricemonitor_share_api_post_embed_sso_url_request_v3: Payload for retrieving a signed embed SSO url using Looker API.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: EmbedSSOUrlResponseV3ApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.post_embed_sso_url_vendor_with_http_info(contract_id, **kwargs)  # noqa: E501

    def post_embed_sso_url_vendor_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Retrieve an embed SSO url for Looker.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_embed_sso_url_vendor_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param ComPatagonaPricemonitorShareApiPostEmbedSSOUrlRequestV3 com_patagona_pricemonitor_share_api_post_embed_sso_url_request_v3: Payload for retrieving a signed embed SSO url using Looker API.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(EmbedSSOUrlResponseV3ApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'com_patagona_pricemonitor_share_api_post_embed_sso_url_request_v3'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_embed_sso_url_vendor" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `post_embed_sso_url_vendor`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'com_patagona_pricemonitor_share_api_post_embed_sso_url_request_v3' in local_var_params:
            body_params = local_var_params['com_patagona_pricemonitor_share_api_post_embed_sso_url_request_v3']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/vendor/contracts/{contractId}/looker/sso/embed/url', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EmbedSSOUrlResponseV3ApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_feed_vendor_v2(self, contract_id, **kwargs):  # noqa: E501
        """post_feed_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_feed_vendor_v2(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.post_feed_vendor_v2_with_http_info(contract_id, **kwargs)  # noqa: E501

    def post_feed_vendor_v2_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """post_feed_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_feed_vendor_v2_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_feed_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `post_feed_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/feeds', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_mappings_vendor_v2(self, contract_id, **kwargs):  # noqa: E501
        """post_mappings_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_mappings_vendor_v2(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.post_mappings_vendor_v2_with_http_info(contract_id, **kwargs)  # noqa: E501

    def post_mappings_vendor_v2_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """post_mappings_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_mappings_vendor_v2_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_mappings_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `post_mappings_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/productidentifiermapping', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_monitoring_schedule_manufacturer_v3(self, contract_id, **kwargs):  # noqa: E501
        """Add a monitoring schedule for a given contract.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_monitoring_schedule_manufacturer_v3(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param ComPatagonaPricemonitorShareApiPostMonitoringScheduleRequestV3 com_patagona_pricemonitor_share_api_post_monitoring_schedule_request_v3: Request body for creating monitoring schedule.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: PutMonitoringSchedulesApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.post_monitoring_schedule_manufacturer_v3_with_http_info(contract_id, **kwargs)  # noqa: E501

    def post_monitoring_schedule_manufacturer_v3_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Add a monitoring schedule for a given contract.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_monitoring_schedule_manufacturer_v3_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param ComPatagonaPricemonitorShareApiPostMonitoringScheduleRequestV3 com_patagona_pricemonitor_share_api_post_monitoring_schedule_request_v3: Request body for creating monitoring schedule.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(PutMonitoringSchedulesApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'com_patagona_pricemonitor_share_api_post_monitoring_schedule_request_v3'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_monitoring_schedule_manufacturer_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `post_monitoring_schedule_manufacturer_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'com_patagona_pricemonitor_share_api_post_monitoring_schedule_request_v3' in local_var_params:
            body_params = local_var_params['com_patagona_pricemonitor_share_api_post_monitoring_schedule_request_v3']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/manufacturer/contracts/{contractId}/settings/monitoringschedules', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PutMonitoringSchedulesApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_monitoring_schedule_vendor_v3(self, contract_id, **kwargs):  # noqa: E501
        """Add a monitoring schedule for a given contract.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_monitoring_schedule_vendor_v3(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param ComPatagonaPricemonitorShareApiPostMonitoringScheduleRequestV3 com_patagona_pricemonitor_share_api_post_monitoring_schedule_request_v3: Request body for creating monitoring schedule.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: PutMonitoringSchedulesApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.post_monitoring_schedule_vendor_v3_with_http_info(contract_id, **kwargs)  # noqa: E501

    def post_monitoring_schedule_vendor_v3_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Add a monitoring schedule for a given contract.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_monitoring_schedule_vendor_v3_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param ComPatagonaPricemonitorShareApiPostMonitoringScheduleRequestV3 com_patagona_pricemonitor_share_api_post_monitoring_schedule_request_v3: Request body for creating monitoring schedule.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(PutMonitoringSchedulesApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'com_patagona_pricemonitor_share_api_post_monitoring_schedule_request_v3'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_monitoring_schedule_vendor_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `post_monitoring_schedule_vendor_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'com_patagona_pricemonitor_share_api_post_monitoring_schedule_request_v3' in local_var_params:
            body_params = local_var_params['com_patagona_pricemonitor_share_api_post_monitoring_schedule_request_v3']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/vendor/contracts/{contractId}/settings/monitoringschedules', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PutMonitoringSchedulesApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_offers_in_a_bulk_vendor_v2(self, contract_id, **kwargs):  # noqa: E501
        """post_offers_in_a_bulk_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_offers_in_a_bulk_vendor_v2(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.post_offers_in_a_bulk_vendor_v2_with_http_info(contract_id, **kwargs)  # noqa: E501

    def post_offers_in_a_bulk_vendor_v2_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """post_offers_in_a_bulk_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_offers_in_a_bulk_vendor_v2_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_offers_in_a_bulk_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `post_offers_in_a_bulk_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/offers', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_offers_vendor_v2(self, contract_id, product_id, **kwargs):  # noqa: E501
        """post_offers_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_offers_vendor_v2(contract_id, product_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str product_id: (required)
        :param object body: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.post_offers_vendor_v2_with_http_info(contract_id, product_id, **kwargs)  # noqa: E501

    def post_offers_vendor_v2_with_http_info(self, contract_id, product_id, **kwargs):  # noqa: E501
        """post_offers_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_offers_vendor_v2_with_http_info(contract_id, product_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str product_id: (required)
        :param object body: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'product_id',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_offers_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `post_offers_vendor_v2`")  # noqa: E501
        # verify the required parameter 'product_id' is set
        if self.api_client.client_side_validation and ('product_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['product_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `product_id` when calling `post_offers_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'product_id' in local_var_params:
            path_params['productId'] = local_var_params['product_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/offers/{productId}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_vendor_shop_mapping_manufacturer_v3(self, contract_id, **kwargs):  # noqa: E501
        """Add a new vendor for a given contract and associate shops with the given vendor.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_vendor_shop_mapping_manufacturer_v3(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param ComPatagonaPricemonitorShareApiPostVendorShopMappingRequestV3 com_patagona_pricemonitor_share_api_post_vendor_shop_mapping_request_v3: Request body for creating a new vendor and associate shops with it. Please note that atleast one shop is required for a successful creation.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: VendorShopMappingV3ApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.post_vendor_shop_mapping_manufacturer_v3_with_http_info(contract_id, **kwargs)  # noqa: E501

    def post_vendor_shop_mapping_manufacturer_v3_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """Add a new vendor for a given contract and associate shops with the given vendor.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_vendor_shop_mapping_manufacturer_v3_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param ComPatagonaPricemonitorShareApiPostVendorShopMappingRequestV3 com_patagona_pricemonitor_share_api_post_vendor_shop_mapping_request_v3: Request body for creating a new vendor and associate shops with it. Please note that atleast one shop is required for a successful creation.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(VendorShopMappingV3ApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'com_patagona_pricemonitor_share_api_post_vendor_shop_mapping_request_v3'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_vendor_shop_mapping_manufacturer_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `post_vendor_shop_mapping_manufacturer_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'com_patagona_pricemonitor_share_api_post_vendor_shop_mapping_request_v3' in local_var_params:
            body_params = local_var_params['com_patagona_pricemonitor_share_api_post_vendor_shop_mapping_request_v3']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/manufacturer/contracts/{contractId}/vendors', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='VendorShopMappingV3ApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def prices_by_day_by_product_id_manufacturer_v2(self, contract_id, product_id, **kwargs):  # noqa: E501
        """prices_by_day_by_product_id_manufacturer_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.prices_by_day_by_product_id_manufacturer_v2(contract_id, product_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str product_id: The product ID to filter for (required)
        :param ComPatagonaPricemonitorShareApiPricesByDayByProductIdRequestV2 com_patagona_pricemonitor_share_api_prices_by_day_by_product_id_request_v2: Query all known prices for a given day & product ID. Can be filtered by using the selectors.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: list[ComPatagonaPricemonitorShareApiPricesByDayByProductIdResponseV2]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.prices_by_day_by_product_id_manufacturer_v2_with_http_info(contract_id, product_id, **kwargs)  # noqa: E501

    def prices_by_day_by_product_id_manufacturer_v2_with_http_info(self, contract_id, product_id, **kwargs):  # noqa: E501
        """prices_by_day_by_product_id_manufacturer_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.prices_by_day_by_product_id_manufacturer_v2_with_http_info(contract_id, product_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str product_id: The product ID to filter for (required)
        :param ComPatagonaPricemonitorShareApiPricesByDayByProductIdRequestV2 com_patagona_pricemonitor_share_api_prices_by_day_by_product_id_request_v2: Query all known prices for a given day & product ID. Can be filtered by using the selectors.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(list[ComPatagonaPricemonitorShareApiPricesByDayByProductIdResponseV2], status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'product_id',
            'com_patagona_pricemonitor_share_api_prices_by_day_by_product_id_request_v2'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method prices_by_day_by_product_id_manufacturer_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `prices_by_day_by_product_id_manufacturer_v2`")  # noqa: E501
        # verify the required parameter 'product_id' is set
        if self.api_client.client_side_validation and ('product_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['product_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `product_id` when calling `prices_by_day_by_product_id_manufacturer_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'product_id' in local_var_params:
            path_params['productId'] = local_var_params['product_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'com_patagona_pricemonitor_share_api_prices_by_day_by_product_id_request_v2' in local_var_params:
            body_params = local_var_params['com_patagona_pricemonitor_share_api_prices_by_day_by_product_id_request_v2']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/m/contracts/{contractId}/result/pricesbyday/productid/{productId}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ComPatagonaPricemonitorShareApiPricesByDayByProductIdResponseV2]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def publish_preprocessing_task_vendor_v3(self, retrospective_in_minutes, contract_id, **kwargs):  # noqa: E501
        """Publish a preprocessing task for vendor.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.publish_preprocessing_task_vendor_v3(retrospective_in_minutes, contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int retrospective_in_minutes: The timespan, in minutes, for considering offers in preprocessing. Allowed value is between 1 and 10080 (required)
        :param str contract_id: ID of the contract (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: EmptyApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.publish_preprocessing_task_vendor_v3_with_http_info(retrospective_in_minutes, contract_id, **kwargs)  # noqa: E501

    def publish_preprocessing_task_vendor_v3_with_http_info(self, retrospective_in_minutes, contract_id, **kwargs):  # noqa: E501
        """Publish a preprocessing task for vendor.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.publish_preprocessing_task_vendor_v3_with_http_info(retrospective_in_minutes, contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int retrospective_in_minutes: The timespan, in minutes, for considering offers in preprocessing. Allowed value is between 1 and 10080 (required)
        :param str contract_id: ID of the contract (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(EmptyApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'retrospective_in_minutes',
            'contract_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method publish_preprocessing_task_vendor_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'retrospective_in_minutes' is set
        if self.api_client.client_side_validation and ('retrospective_in_minutes' not in local_var_params or  # noqa: E501
                                                        local_var_params['retrospective_in_minutes'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `retrospective_in_minutes` when calling `publish_preprocessing_task_vendor_v3`")  # noqa: E501
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `publish_preprocessing_task_vendor_v3`")  # noqa: E501

        if self.api_client.client_side_validation and 'retrospective_in_minutes' in local_var_params and local_var_params['retrospective_in_minutes'] > 10080:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `retrospective_in_minutes` when calling `publish_preprocessing_task_vendor_v3`, must be a value less than or equal to `10080`")  # noqa: E501
        if self.api_client.client_side_validation and 'retrospective_in_minutes' in local_var_params and local_var_params['retrospective_in_minutes'] < 1:  # noqa: E501
            raise ApiValueError("Invalid value for parameter `retrospective_in_minutes` when calling `publish_preprocessing_task_vendor_v3`, must be a value greater than or equal to `1`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []
        if 'retrospective_in_minutes' in local_var_params and local_var_params['retrospective_in_minutes'] is not None:  # noqa: E501
            query_params.append(('retrospectiveInMinutes', local_var_params['retrospective_in_minutes']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/vendor/contracts/{contractId}/tasks/preprocessing', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EmptyApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_callbacks_vendor_v2(self, contract_id, **kwargs):  # noqa: E501
        """put_callbacks_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_callbacks_vendor_v2(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.put_callbacks_vendor_v2_with_http_info(contract_id, **kwargs)  # noqa: E501

    def put_callbacks_vendor_v2_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """put_callbacks_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_callbacks_vendor_v2_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_callbacks_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `put_callbacks_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/settings/callbacks', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_complex_offer_filters_vendor_v2(self, contract_id, list_type, **kwargs):  # noqa: E501
        """Add the complex filters for the given contract.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_complex_offer_filters_vendor_v2(contract_id, list_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str list_type: (required)
        :param list[AndOfferFilter] and_offer_filter: List of the filter that needs to be considered to ignore the individual offers.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: OfferFilterApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.put_complex_offer_filters_vendor_v2_with_http_info(contract_id, list_type, **kwargs)  # noqa: E501

    def put_complex_offer_filters_vendor_v2_with_http_info(self, contract_id, list_type, **kwargs):  # noqa: E501
        """Add the complex filters for the given contract.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_complex_offer_filters_vendor_v2_with_http_info(contract_id, list_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str list_type: (required)
        :param list[AndOfferFilter] and_offer_filter: List of the filter that needs to be considered to ignore the individual offers.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(OfferFilterApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'list_type',
            'and_offer_filter'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_complex_offer_filters_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `put_complex_offer_filters_vendor_v2`")  # noqa: E501
        # verify the required parameter 'list_type' is set
        if self.api_client.client_side_validation and ('list_type' not in local_var_params or  # noqa: E501
                                                        local_var_params['list_type'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `list_type` when calling `put_complex_offer_filters_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'list_type' in local_var_params:
            path_params['listType'] = local_var_params['list_type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'and_offer_filter' in local_var_params:
            body_params = local_var_params['and_offer_filter']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/offerfilters/{listType}/complex', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='OfferFilterApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_currency_vendor_v2(self, contract_id, **kwargs):  # noqa: E501
        """put_currency_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_currency_vendor_v2(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.put_currency_vendor_v2_with_http_info(contract_id, **kwargs)  # noqa: E501

    def put_currency_vendor_v2_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """put_currency_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_currency_vendor_v2_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_currency_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `put_currency_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/settings/currency', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_customer_contract_settings_manufacturer_v3(self, contract_id, **kwargs):  # noqa: E501
        """put_customer_contract_settings_manufacturer_v3  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_customer_contract_settings_manufacturer_v3(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param ComPatagonaPricemonitorShareApiCustomerContractSettings com_patagona_pricemonitor_share_api_customer_contract_settings: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: PutCustomerContractSettingsApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.put_customer_contract_settings_manufacturer_v3_with_http_info(contract_id, **kwargs)  # noqa: E501

    def put_customer_contract_settings_manufacturer_v3_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """put_customer_contract_settings_manufacturer_v3  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_customer_contract_settings_manufacturer_v3_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param ComPatagonaPricemonitorShareApiCustomerContractSettings com_patagona_pricemonitor_share_api_customer_contract_settings: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(PutCustomerContractSettingsApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'com_patagona_pricemonitor_share_api_customer_contract_settings'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_customer_contract_settings_manufacturer_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `put_customer_contract_settings_manufacturer_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'com_patagona_pricemonitor_share_api_customer_contract_settings' in local_var_params:
            body_params = local_var_params['com_patagona_pricemonitor_share_api_customer_contract_settings']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/manufacturer/contracts/{contractId}/settings/customer', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PutCustomerContractSettingsApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_customer_contract_settings_vendor_v3(self, contract_id, **kwargs):  # noqa: E501
        """put_customer_contract_settings_vendor_v3  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_customer_contract_settings_vendor_v3(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param ComPatagonaPricemonitorShareApiCustomerContractSettings com_patagona_pricemonitor_share_api_customer_contract_settings: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: PutCustomerContractSettingsApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.put_customer_contract_settings_vendor_v3_with_http_info(contract_id, **kwargs)  # noqa: E501

    def put_customer_contract_settings_vendor_v3_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """put_customer_contract_settings_vendor_v3  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_customer_contract_settings_vendor_v3_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param ComPatagonaPricemonitorShareApiCustomerContractSettings com_patagona_pricemonitor_share_api_customer_contract_settings: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(PutCustomerContractSettingsApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'com_patagona_pricemonitor_share_api_customer_contract_settings'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_customer_contract_settings_vendor_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `put_customer_contract_settings_vendor_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'com_patagona_pricemonitor_share_api_customer_contract_settings' in local_var_params:
            body_params = local_var_params['com_patagona_pricemonitor_share_api_customer_contract_settings']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/vendor/contracts/{contractId}/settings/customer', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PutCustomerContractSettingsApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_dynamic_monitoring_settings(self, contract_id, **kwargs):  # noqa: E501
        """put_dynamic_monitoring_settings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_dynamic_monitoring_settings(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.put_dynamic_monitoring_settings_with_http_info(contract_id, **kwargs)  # noqa: E501

    def put_dynamic_monitoring_settings_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """put_dynamic_monitoring_settings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_dynamic_monitoring_settings_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_dynamic_monitoring_settings" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `put_dynamic_monitoring_settings`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/1/{contractId}/settings/dynamicmonitoring', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_feed_vendor_v2(self, contract_id, feed_id, **kwargs):  # noqa: E501
        """put_feed_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_feed_vendor_v2(contract_id, feed_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str feed_id: (required)
        :param object body: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.put_feed_vendor_v2_with_http_info(contract_id, feed_id, **kwargs)  # noqa: E501

    def put_feed_vendor_v2_with_http_info(self, contract_id, feed_id, **kwargs):  # noqa: E501
        """put_feed_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_feed_vendor_v2_with_http_info(contract_id, feed_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str feed_id: (required)
        :param object body: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'feed_id',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_feed_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `put_feed_vendor_v2`")  # noqa: E501
        # verify the required parameter 'feed_id' is set
        if self.api_client.client_side_validation and ('feed_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['feed_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `feed_id` when calling `put_feed_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'feed_id' in local_var_params:
            path_params['feedId'] = local_var_params['feed_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/feeds/{feedId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_image_tag_manufacturer_v2(self, contract_id, **kwargs):  # noqa: E501
        """put_image_tag_manufacturer_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_image_tag_manufacturer_v2(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.put_image_tag_manufacturer_v2_with_http_info(contract_id, **kwargs)  # noqa: E501

    def put_image_tag_manufacturer_v2_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """put_image_tag_manufacturer_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_image_tag_manufacturer_v2_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_image_tag_manufacturer_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `put_image_tag_manufacturer_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/m/contracts/{contractId}/settings/imagetag', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_image_tag_vendor_v2(self, contract_id, **kwargs):  # noqa: E501
        """put_image_tag_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_image_tag_vendor_v2(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.put_image_tag_vendor_v2_with_http_info(contract_id, **kwargs)  # noqa: E501

    def put_image_tag_vendor_v2_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """put_image_tag_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_image_tag_vendor_v2_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_image_tag_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `put_image_tag_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/settings/imagetag', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_import_settings_vendor_v2(self, contract_id, **kwargs):  # noqa: E501
        """put_import_settings_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_import_settings_vendor_v2(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.put_import_settings_vendor_v2_with_http_info(contract_id, **kwargs)  # noqa: E501

    def put_import_settings_vendor_v2_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """put_import_settings_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_import_settings_vendor_v2_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_import_settings_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `put_import_settings_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/settings/import', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_monitoring_schedule_manufacturer_v3(self, contract_id, schedule_id, **kwargs):  # noqa: E501
        """Update a monitoring schedule for a given contract.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_monitoring_schedule_manufacturer_v3(contract_id, schedule_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param int schedule_id: ID of a monitoring schedule (required)
        :param ComPatagonaPricemonitorShareApiPostMonitoringScheduleRequestV3 com_patagona_pricemonitor_share_api_post_monitoring_schedule_request_v3: Request body for updating monitoring schedule.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: PutMonitoringSchedulesApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.put_monitoring_schedule_manufacturer_v3_with_http_info(contract_id, schedule_id, **kwargs)  # noqa: E501

    def put_monitoring_schedule_manufacturer_v3_with_http_info(self, contract_id, schedule_id, **kwargs):  # noqa: E501
        """Update a monitoring schedule for a given contract.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_monitoring_schedule_manufacturer_v3_with_http_info(contract_id, schedule_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param int schedule_id: ID of a monitoring schedule (required)
        :param ComPatagonaPricemonitorShareApiPostMonitoringScheduleRequestV3 com_patagona_pricemonitor_share_api_post_monitoring_schedule_request_v3: Request body for updating monitoring schedule.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(PutMonitoringSchedulesApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'schedule_id',
            'com_patagona_pricemonitor_share_api_post_monitoring_schedule_request_v3'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_monitoring_schedule_manufacturer_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `put_monitoring_schedule_manufacturer_v3`")  # noqa: E501
        # verify the required parameter 'schedule_id' is set
        if self.api_client.client_side_validation and ('schedule_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['schedule_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `schedule_id` when calling `put_monitoring_schedule_manufacturer_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'schedule_id' in local_var_params:
            path_params['scheduleId'] = local_var_params['schedule_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'com_patagona_pricemonitor_share_api_post_monitoring_schedule_request_v3' in local_var_params:
            body_params = local_var_params['com_patagona_pricemonitor_share_api_post_monitoring_schedule_request_v3']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/manufacturer/contracts/{contractId}/settings/monitoringschedules/{scheduleId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PutMonitoringSchedulesApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_monitoring_schedule_vendor_v3(self, contract_id, schedule_id, **kwargs):  # noqa: E501
        """Update a monitoring schedule for a given contract.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_monitoring_schedule_vendor_v3(contract_id, schedule_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param int schedule_id: ID of a monitoring schedule (required)
        :param ComPatagonaPricemonitorShareApiPostMonitoringScheduleRequestV3 com_patagona_pricemonitor_share_api_post_monitoring_schedule_request_v3: Request body for updating monitoring schedule.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: PutMonitoringSchedulesApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.put_monitoring_schedule_vendor_v3_with_http_info(contract_id, schedule_id, **kwargs)  # noqa: E501

    def put_monitoring_schedule_vendor_v3_with_http_info(self, contract_id, schedule_id, **kwargs):  # noqa: E501
        """Update a monitoring schedule for a given contract.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_monitoring_schedule_vendor_v3_with_http_info(contract_id, schedule_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param int schedule_id: ID of a monitoring schedule (required)
        :param ComPatagonaPricemonitorShareApiPostMonitoringScheduleRequestV3 com_patagona_pricemonitor_share_api_post_monitoring_schedule_request_v3: Request body for updating monitoring schedule.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(PutMonitoringSchedulesApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'schedule_id',
            'com_patagona_pricemonitor_share_api_post_monitoring_schedule_request_v3'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_monitoring_schedule_vendor_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `put_monitoring_schedule_vendor_v3`")  # noqa: E501
        # verify the required parameter 'schedule_id' is set
        if self.api_client.client_side_validation and ('schedule_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['schedule_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `schedule_id` when calling `put_monitoring_schedule_vendor_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'schedule_id' in local_var_params:
            path_params['scheduleId'] = local_var_params['schedule_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'com_patagona_pricemonitor_share_api_post_monitoring_schedule_request_v3' in local_var_params:
            body_params = local_var_params['com_patagona_pricemonitor_share_api_post_monitoring_schedule_request_v3']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/vendor/contracts/{contractId}/settings/monitoringschedules/{scheduleId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PutMonitoringSchedulesApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_monitoring_settings_manufacturer_v2(self, contract_id, **kwargs):  # noqa: E501
        """put_monitoring_settings_manufacturer_v2  # noqa: E501

        Update the monitoring settings for a given contract  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_monitoring_settings_manufacturer_v2(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: The monitoring settings object to be written to the database
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.put_monitoring_settings_manufacturer_v2_with_http_info(contract_id, **kwargs)  # noqa: E501

    def put_monitoring_settings_manufacturer_v2_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """put_monitoring_settings_manufacturer_v2  # noqa: E501

        Update the monitoring settings for a given contract  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_monitoring_settings_manufacturer_v2_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: The monitoring settings object to be written to the database
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_monitoring_settings_manufacturer_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `put_monitoring_settings_manufacturer_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/m/contracts/{contractId}/settings/monitoring', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_monitoring_settings_manufacturer_v3(self, contract_id, **kwargs):  # noqa: E501
        """put_monitoring_settings_manufacturer_v3  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_monitoring_settings_manufacturer_v3(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.put_monitoring_settings_manufacturer_v3_with_http_info(contract_id, **kwargs)  # noqa: E501

    def put_monitoring_settings_manufacturer_v3_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """put_monitoring_settings_manufacturer_v3  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_monitoring_settings_manufacturer_v3_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_monitoring_settings_manufacturer_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `put_monitoring_settings_manufacturer_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/manufacturer/contracts/{contractId}/settings/monitoring', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_monitoring_settings_vendor_v2(self, contract_id, **kwargs):  # noqa: E501
        """put_monitoring_settings_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_monitoring_settings_vendor_v2(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.put_monitoring_settings_vendor_v2_with_http_info(contract_id, **kwargs)  # noqa: E501

    def put_monitoring_settings_vendor_v2_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """put_monitoring_settings_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_monitoring_settings_vendor_v2_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_monitoring_settings_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `put_monitoring_settings_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/settings/monitoring', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_monitoring_settings_vendor_v3(self, contract_id, **kwargs):  # noqa: E501
        """put_monitoring_settings_vendor_v3  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_monitoring_settings_vendor_v3(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.put_monitoring_settings_vendor_v3_with_http_info(contract_id, **kwargs)  # noqa: E501

    def put_monitoring_settings_vendor_v3_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """put_monitoring_settings_vendor_v3  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_monitoring_settings_vendor_v3_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_monitoring_settings_vendor_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `put_monitoring_settings_vendor_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/vendor/contracts/{contractId}/settings/monitoring', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_offer_filters_vendor_v2(self, contract_id, list_type, **kwargs):  # noqa: E501
        """Store the vendor filters for the given contract.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_offer_filters_vendor_v2(contract_id, list_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str list_type: (required)
        :param object body: List of the filters that needs to be considered to ignore the individual offers.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.put_offer_filters_vendor_v2_with_http_info(contract_id, list_type, **kwargs)  # noqa: E501

    def put_offer_filters_vendor_v2_with_http_info(self, contract_id, list_type, **kwargs):  # noqa: E501
        """Store the vendor filters for the given contract.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_offer_filters_vendor_v2_with_http_info(contract_id, list_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str list_type: (required)
        :param object body: List of the filters that needs to be considered to ignore the individual offers.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'list_type',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_offer_filters_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `put_offer_filters_vendor_v2`")  # noqa: E501
        # verify the required parameter 'list_type' is set
        if self.api_client.client_side_validation and ('list_type' not in local_var_params or  # noqa: E501
                                                        local_var_params['list_type'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `list_type` when calling `put_offer_filters_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'list_type' in local_var_params:
            path_params['listType'] = local_var_params['list_type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/offerfilters/{listType}/vendors', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_offer_retention_settings_manufacturer_v3(self, contract_id, contract_type, **kwargs):  # noqa: E501
        """put_offer_retention_settings_manufacturer_v3  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_offer_retention_settings_manufacturer_v3(contract_id, contract_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str contract_type: (required)
        :param object body: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.put_offer_retention_settings_manufacturer_v3_with_http_info(contract_id, contract_type, **kwargs)  # noqa: E501

    def put_offer_retention_settings_manufacturer_v3_with_http_info(self, contract_id, contract_type, **kwargs):  # noqa: E501
        """put_offer_retention_settings_manufacturer_v3  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_offer_retention_settings_manufacturer_v3_with_http_info(contract_id, contract_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str contract_type: (required)
        :param object body: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'contract_type',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_offer_retention_settings_manufacturer_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `put_offer_retention_settings_manufacturer_v3`")  # noqa: E501
        # verify the required parameter 'contract_type' is set
        if self.api_client.client_side_validation and ('contract_type' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_type'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_type` when calling `put_offer_retention_settings_manufacturer_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []
        if 'contract_type' in local_var_params and local_var_params['contract_type'] is not None:  # noqa: E501
            query_params.append(('contractType', local_var_params['contract_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/manufacturer/contracts/{contractId}/settings/offerretention', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_offer_retention_settings_vendor_v3(self, contract_id, contract_type, **kwargs):  # noqa: E501
        """put_offer_retention_settings_vendor_v3  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_offer_retention_settings_vendor_v3(contract_id, contract_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str contract_type: (required)
        :param object body: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.put_offer_retention_settings_vendor_v3_with_http_info(contract_id, contract_type, **kwargs)  # noqa: E501

    def put_offer_retention_settings_vendor_v3_with_http_info(self, contract_id, contract_type, **kwargs):  # noqa: E501
        """put_offer_retention_settings_vendor_v3  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_offer_retention_settings_vendor_v3_with_http_info(contract_id, contract_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str contract_type: (required)
        :param object body: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'contract_type',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_offer_retention_settings_vendor_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `put_offer_retention_settings_vendor_v3`")  # noqa: E501
        # verify the required parameter 'contract_type' is set
        if self.api_client.client_side_validation and ('contract_type' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_type'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_type` when calling `put_offer_retention_settings_vendor_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []
        if 'contract_type' in local_var_params and local_var_params['contract_type'] is not None:  # noqa: E501
            query_params.append(('contractType', local_var_params['contract_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/vendor/contracts/{contractId}/settings/offerretention', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_product_filters_vendor_v2(self, contract_id, list_type, product_id, **kwargs):  # noqa: E501
        """Store the filters of a given product for the given contract.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_product_filters_vendor_v2(contract_id, list_type, product_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str list_type: (required)
        :param str product_id: (required)
        :param list[AndOfferFilter] and_offer_filter: List of the filter that needs to be considered to ignore the individual offers.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: OfferFilterApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.put_product_filters_vendor_v2_with_http_info(contract_id, list_type, product_id, **kwargs)  # noqa: E501

    def put_product_filters_vendor_v2_with_http_info(self, contract_id, list_type, product_id, **kwargs):  # noqa: E501
        """Store the filters of a given product for the given contract.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_product_filters_vendor_v2_with_http_info(contract_id, list_type, product_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str list_type: (required)
        :param str product_id: (required)
        :param list[AndOfferFilter] and_offer_filter: List of the filter that needs to be considered to ignore the individual offers.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(OfferFilterApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'list_type',
            'product_id',
            'and_offer_filter'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_product_filters_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `put_product_filters_vendor_v2`")  # noqa: E501
        # verify the required parameter 'list_type' is set
        if self.api_client.client_side_validation and ('list_type' not in local_var_params or  # noqa: E501
                                                        local_var_params['list_type'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `list_type` when calling `put_product_filters_vendor_v2`")  # noqa: E501
        # verify the required parameter 'product_id' is set
        if self.api_client.client_side_validation and ('product_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['product_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `product_id` when calling `put_product_filters_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'list_type' in local_var_params:
            path_params['listType'] = local_var_params['list_type']  # noqa: E501
        if 'product_id' in local_var_params:
            path_params['productId'] = local_var_params['product_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'and_offer_filter' in local_var_params:
            body_params = local_var_params['and_offer_filter']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/offerfilters/{listType}/products/{productId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='OfferFilterApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_products_csv_manufacturer_v2(self, contract_id, **kwargs):  # noqa: E501
        """put_products_csv_manufacturer_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_products_csv_manufacturer_v2(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.put_products_csv_manufacturer_v2_with_http_info(contract_id, **kwargs)  # noqa: E501

    def put_products_csv_manufacturer_v2_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """put_products_csv_manufacturer_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_products_csv_manufacturer_v2_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_products_csv_manufacturer_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `put_products_csv_manufacturer_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/m/contracts/{contractId}/products/csv', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_products_vendor_v2(self, contract_id, **kwargs):  # noqa: E501
        """put_products_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_products_vendor_v2(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.put_products_vendor_v2_with_http_info(contract_id, **kwargs)  # noqa: E501

    def put_products_vendor_v2_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """put_products_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_products_vendor_v2_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_products_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `put_products_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/products', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_repricing_strategy_vendor_v2(self, contract_id, **kwargs):  # noqa: E501
        """put_repricing_strategy_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_repricing_strategy_vendor_v2(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.put_repricing_strategy_vendor_v2_with_http_info(contract_id, **kwargs)  # noqa: E501

    def put_repricing_strategy_vendor_v2_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """put_repricing_strategy_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_repricing_strategy_vendor_v2_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_repricing_strategy_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `put_repricing_strategy_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/settings/repricingstrategy', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_settings(self, contract_id, **kwargs):  # noqa: E501
        """put_settings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_settings(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param ComPatagonaPricemonitorShareApiPutAdminContractSettingsBody com_patagona_pricemonitor_share_api_put_admin_contract_settings_body: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ComPatagonaPricemonitorShareApiPutAdminContractSettingsBody
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.put_settings_with_http_info(contract_id, **kwargs)  # noqa: E501

    def put_settings_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """put_settings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_settings_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param ComPatagonaPricemonitorShareApiPutAdminContractSettingsBody com_patagona_pricemonitor_share_api_put_admin_contract_settings_body: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ComPatagonaPricemonitorShareApiPutAdminContractSettingsBody, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'com_patagona_pricemonitor_share_api_put_admin_contract_settings_body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_settings" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `put_settings`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'com_patagona_pricemonitor_share_api_put_admin_contract_settings_body' in local_var_params:
            body_params = local_var_params['com_patagona_pricemonitor_share_api_put_admin_contract_settings_body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/1/{contractId}/settings', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ComPatagonaPricemonitorShareApiPutAdminContractSettingsBody',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_vendor_settings_vendor_v2(self, contract_id, **kwargs):  # noqa: E501
        """put_vendor_settings_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_vendor_settings_vendor_v2(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.put_vendor_settings_vendor_v2_with_http_info(contract_id, **kwargs)  # noqa: E501

    def put_vendor_settings_vendor_v2_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """put_vendor_settings_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_vendor_settings_vendor_v2_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_vendor_settings_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `put_vendor_settings_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/settings/repricing', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_vendor_shop_mapping_manufacturer_v3(self, contract_id, vendor_id, **kwargs):  # noqa: E501
        """Update an existing vendor for a given contract and associate shops with the given vendor.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_vendor_shop_mapping_manufacturer_v3(contract_id, vendor_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param int vendor_id: ID of vendor shop mapping (required)
        :param ComPatagonaPricemonitorShareApiPostVendorShopMappingRequestV3 com_patagona_pricemonitor_share_api_post_vendor_shop_mapping_request_v3: Request body for updating an existing vendor and associate shops with it. Please note that atleast one shop is required for a successful creation.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: VendorShopMappingV3ApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.put_vendor_shop_mapping_manufacturer_v3_with_http_info(contract_id, vendor_id, **kwargs)  # noqa: E501

    def put_vendor_shop_mapping_manufacturer_v3_with_http_info(self, contract_id, vendor_id, **kwargs):  # noqa: E501
        """Update an existing vendor for a given contract and associate shops with the given vendor.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_vendor_shop_mapping_manufacturer_v3_with_http_info(contract_id, vendor_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param int vendor_id: ID of vendor shop mapping (required)
        :param ComPatagonaPricemonitorShareApiPostVendorShopMappingRequestV3 com_patagona_pricemonitor_share_api_post_vendor_shop_mapping_request_v3: Request body for updating an existing vendor and associate shops with it. Please note that atleast one shop is required for a successful creation.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(VendorShopMappingV3ApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'vendor_id',
            'com_patagona_pricemonitor_share_api_post_vendor_shop_mapping_request_v3'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_vendor_shop_mapping_manufacturer_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `put_vendor_shop_mapping_manufacturer_v3`")  # noqa: E501
        # verify the required parameter 'vendor_id' is set
        if self.api_client.client_side_validation and ('vendor_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['vendor_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `vendor_id` when calling `put_vendor_shop_mapping_manufacturer_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'vendor_id' in local_var_params:
            path_params['vendorId'] = local_var_params['vendor_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'com_patagona_pricemonitor_share_api_post_vendor_shop_mapping_request_v3' in local_var_params:
            body_params = local_var_params['com_patagona_pricemonitor_share_api_post_vendor_shop_mapping_request_v3']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/manufacturer/contracts/{contractId}/vendors/{vendorId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='VendorShopMappingV3ApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def query_offers_manufacturer_v3(self, contract_id, **kwargs):  # noqa: E501
        """query_offers_manufacturer_v3  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.query_offers_manufacturer_v3(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.query_offers_manufacturer_v3_with_http_info(contract_id, **kwargs)  # noqa: E501

    def query_offers_manufacturer_v3_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """query_offers_manufacturer_v3  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.query_offers_manufacturer_v3_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method query_offers_manufacturer_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `query_offers_manufacturer_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/manufacturer/contracts/{contractId}/offers/query', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def query_price_recommendations_vendor_v2(self, contract_id, **kwargs):  # noqa: E501
        """query_price_recommendations_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.query_price_recommendations_vendor_v2(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param PriceRecommendationApiQueryV2 price_recommendation_api_query_v2: The request body specifies which price recommendations will be searched for.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: QueryPriceRecommendationsV2ApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.query_price_recommendations_vendor_v2_with_http_info(contract_id, **kwargs)  # noqa: E501

    def query_price_recommendations_vendor_v2_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """query_price_recommendations_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.query_price_recommendations_vendor_v2_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param PriceRecommendationApiQueryV2 price_recommendation_api_query_v2: The request body specifies which price recommendations will be searched for.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(QueryPriceRecommendationsV2ApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'price_recommendation_api_query_v2'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method query_price_recommendations_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `query_price_recommendations_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'price_recommendation_api_query_v2' in local_var_params:
            body_params = local_var_params['price_recommendation_api_query_v2']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/result/pricerecommendations/query', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='QueryPriceRecommendationsV2ApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def query_products_by_filter_manufacturer_v3(self, contract_id, **kwargs):  # noqa: E501
        """query_products_by_filter_manufacturer_v3  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.query_products_by_filter_manufacturer_v3(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param QueryProductsRequestV3 query_products_request_v3: The body contains the products query.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: QueryProductsByFilterManufacturerV3ApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.query_products_by_filter_manufacturer_v3_with_http_info(contract_id, **kwargs)  # noqa: E501

    def query_products_by_filter_manufacturer_v3_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """query_products_by_filter_manufacturer_v3  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.query_products_by_filter_manufacturer_v3_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param QueryProductsRequestV3 query_products_request_v3: The body contains the products query.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(QueryProductsByFilterManufacturerV3ApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'query_products_request_v3'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method query_products_by_filter_manufacturer_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `query_products_by_filter_manufacturer_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'query_products_request_v3' in local_var_params:
            body_params = local_var_params['query_products_request_v3']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/manufacturer/contracts/{contractId}/products/query', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='QueryProductsByFilterManufacturerV3ApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def query_products_by_filter_vendor_v3(self, contract_id, **kwargs):  # noqa: E501
        """query_products_by_filter_vendor_v3  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.query_products_by_filter_vendor_v3(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param QueryProductsRequestV3 query_products_request_v3: The body contains the products query.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: QueryProductsByFilterVendorV3ApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.query_products_by_filter_vendor_v3_with_http_info(contract_id, **kwargs)  # noqa: E501

    def query_products_by_filter_vendor_v3_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """query_products_by_filter_vendor_v3  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.query_products_by_filter_vendor_v3_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param QueryProductsRequestV3 query_products_request_v3: The body contains the products query.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(QueryProductsByFilterVendorV3ApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'query_products_request_v3'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method query_products_by_filter_vendor_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `query_products_by_filter_vendor_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'query_products_request_v3' in local_var_params:
            body_params = local_var_params['query_products_request_v3']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/vendor/contracts/{contractId}/products/query', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='QueryProductsByFilterVendorV3ApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def raw_offers(self, contract_id, start, limit, **kwargs):  # noqa: E501
        """raw_offers  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.raw_offers(contract_id, start, limit, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param int start: (required)
        :param int limit: (required)
        :param datetime since:
        :param datetime until:
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.raw_offers_with_http_info(contract_id, start, limit, **kwargs)  # noqa: E501

    def raw_offers_with_http_info(self, contract_id, start, limit, **kwargs):  # noqa: E501
        """raw_offers  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.raw_offers_with_http_info(contract_id, start, limit, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param int start: (required)
        :param int limit: (required)
        :param datetime since:
        :param datetime until:
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'start',
            'limit',
            'since',
            'until'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method raw_offers" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `raw_offers`")  # noqa: E501
        # verify the required parameter 'start' is set
        if self.api_client.client_side_validation and ('start' not in local_var_params or  # noqa: E501
                                                        local_var_params['start'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `start` when calling `raw_offers`")  # noqa: E501
        # verify the required parameter 'limit' is set
        if self.api_client.client_side_validation and ('limit' not in local_var_params or  # noqa: E501
                                                        local_var_params['limit'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `limit` when calling `raw_offers`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []
        if 'start' in local_var_params and local_var_params['start'] is not None:  # noqa: E501
            query_params.append(('start', local_var_params['start']))  # noqa: E501
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501
        if 'since' in local_var_params and local_var_params['since'] is not None:  # noqa: E501
            query_params.append(('since', local_var_params['since']))  # noqa: E501
        if 'until' in local_var_params and local_var_params['until'] is not None:  # noqa: E501
            query_params.append(('until', local_var_params['until']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/1/{contractId}/products/offers', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remove_user(self, company_id, user_id, **kwargs):  # noqa: E501
        """remove_user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_user(company_id, user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int company_id: ID of a company (required)
        :param int user_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.remove_user_with_http_info(company_id, user_id, **kwargs)  # noqa: E501

    def remove_user_with_http_info(self, company_id, user_id, **kwargs):  # noqa: E501
        """remove_user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_user_with_http_info(company_id, user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int company_id: ID of a company (required)
        :param int user_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'company_id',
            'user_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remove_user" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'company_id' is set
        if self.api_client.client_side_validation and ('company_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['company_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `company_id` when calling `remove_user`")  # noqa: E501
        # verify the required parameter 'user_id' is set
        if self.api_client.client_side_validation and ('user_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['user_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `user_id` when calling `remove_user`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'company_id' in local_var_params:
            path_params['companyId'] = local_var_params['company_id']  # noqa: E501
        if 'user_id' in local_var_params:
            path_params['userId'] = local_var_params['user_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/controlpanel/api/companies/{companyId}/users/{userId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def request_new_password(self, **kwargs):  # noqa: E501
        """Request a new password  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.request_new_password(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param ComPatagonaPricemonitorShareApiPostNewPasswordRequest com_patagona_pricemonitor_share_api_post_new_password_request: Request a new password.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.request_new_password_with_http_info(**kwargs)  # noqa: E501

    def request_new_password_with_http_info(self, **kwargs):  # noqa: E501
        """Request a new password  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.request_new_password_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param ComPatagonaPricemonitorShareApiPostNewPasswordRequest com_patagona_pricemonitor_share_api_post_new_password_request: Request a new password.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(str, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'com_patagona_pricemonitor_share_api_post_new_password_request'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method request_new_password" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'com_patagona_pricemonitor_share_api_post_new_password_request' in local_var_params:
            body_params = local_var_params['com_patagona_pricemonitor_share_api_post_new_password_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain', 'application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/account/password/reset', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def reset_password(self, **kwargs):  # noqa: E501
        """Reset the password  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.reset_password(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param ComPatagonaPricemonitorShareApiPutResetPasswordRequest com_patagona_pricemonitor_share_api_put_reset_password_request: Reset a password
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.reset_password_with_http_info(**kwargs)  # noqa: E501

    def reset_password_with_http_info(self, **kwargs):  # noqa: E501
        """Reset the password  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.reset_password_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param ComPatagonaPricemonitorShareApiPutResetPasswordRequest com_patagona_pricemonitor_share_api_put_reset_password_request: Reset a password
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(str, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'com_patagona_pricemonitor_share_api_put_reset_password_request'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method reset_password" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'com_patagona_pricemonitor_share_api_put_reset_password_request' in local_var_params:
            body_params = local_var_params['com_patagona_pricemonitor_share_api_put_reset_password_request']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/account/password/reset', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def save_include_delivery_costs(self, contract_id, **kwargs):  # noqa: E501
        """save_include_delivery_costs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.save_include_delivery_costs(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.save_include_delivery_costs_with_http_info(contract_id, **kwargs)  # noqa: E501

    def save_include_delivery_costs_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """save_include_delivery_costs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.save_include_delivery_costs_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method save_include_delivery_costs" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `save_include_delivery_costs`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/1/{contractId}/settings/include_delivery_costs', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def scheduler_delete_request_manufacturer_v3(self, contract_id, path, **kwargs):  # noqa: E501
        """scheduler_delete_request_manufacturer_v3  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.scheduler_delete_request_manufacturer_v3(contract_id, path, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str path: The scheduler path to be called (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.scheduler_delete_request_manufacturer_v3_with_http_info(contract_id, path, **kwargs)  # noqa: E501

    def scheduler_delete_request_manufacturer_v3_with_http_info(self, contract_id, path, **kwargs):  # noqa: E501
        """scheduler_delete_request_manufacturer_v3  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.scheduler_delete_request_manufacturer_v3_with_http_info(contract_id, path, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str path: The scheduler path to be called (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'path'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method scheduler_delete_request_manufacturer_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `scheduler_delete_request_manufacturer_v3`")  # noqa: E501
        # verify the required parameter 'path' is set
        if self.api_client.client_side_validation and ('path' not in local_var_params or  # noqa: E501
                                                        local_var_params['path'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `path` when calling `scheduler_delete_request_manufacturer_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'path' in local_var_params:
            path_params['path'] = local_var_params['path']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/manufacturer/contracts/{contractId}/scheduler/{path}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def scheduler_delete_request_vendor_v3(self, contract_id, path, **kwargs):  # noqa: E501
        """scheduler_delete_request_vendor_v3  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.scheduler_delete_request_vendor_v3(contract_id, path, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str path: The scheduler path to be called (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.scheduler_delete_request_vendor_v3_with_http_info(contract_id, path, **kwargs)  # noqa: E501

    def scheduler_delete_request_vendor_v3_with_http_info(self, contract_id, path, **kwargs):  # noqa: E501
        """scheduler_delete_request_vendor_v3  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.scheduler_delete_request_vendor_v3_with_http_info(contract_id, path, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str path: The scheduler path to be called (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'path'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method scheduler_delete_request_vendor_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `scheduler_delete_request_vendor_v3`")  # noqa: E501
        # verify the required parameter 'path' is set
        if self.api_client.client_side_validation and ('path' not in local_var_params or  # noqa: E501
                                                        local_var_params['path'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `path` when calling `scheduler_delete_request_vendor_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'path' in local_var_params:
            path_params['path'] = local_var_params['path']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/vendor/contracts/{contractId}/scheduler/{path}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def scheduler_get_request_manufacturer_v3(self, contract_id, path, **kwargs):  # noqa: E501
        """scheduler_get_request_manufacturer_v3  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.scheduler_get_request_manufacturer_v3(contract_id, path, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str path: The scheduler path to be called (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.scheduler_get_request_manufacturer_v3_with_http_info(contract_id, path, **kwargs)  # noqa: E501

    def scheduler_get_request_manufacturer_v3_with_http_info(self, contract_id, path, **kwargs):  # noqa: E501
        """scheduler_get_request_manufacturer_v3  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.scheduler_get_request_manufacturer_v3_with_http_info(contract_id, path, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str path: The scheduler path to be called (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'path'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method scheduler_get_request_manufacturer_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `scheduler_get_request_manufacturer_v3`")  # noqa: E501
        # verify the required parameter 'path' is set
        if self.api_client.client_side_validation and ('path' not in local_var_params or  # noqa: E501
                                                        local_var_params['path'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `path` when calling `scheduler_get_request_manufacturer_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'path' in local_var_params:
            path_params['path'] = local_var_params['path']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/manufacturer/contracts/{contractId}/scheduler/{path}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def scheduler_get_request_vendor_v3(self, contract_id, path, **kwargs):  # noqa: E501
        """scheduler_get_request_vendor_v3  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.scheduler_get_request_vendor_v3(contract_id, path, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str path: The scheduler path to be called (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.scheduler_get_request_vendor_v3_with_http_info(contract_id, path, **kwargs)  # noqa: E501

    def scheduler_get_request_vendor_v3_with_http_info(self, contract_id, path, **kwargs):  # noqa: E501
        """scheduler_get_request_vendor_v3  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.scheduler_get_request_vendor_v3_with_http_info(contract_id, path, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str path: The scheduler path to be called (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'path'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method scheduler_get_request_vendor_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `scheduler_get_request_vendor_v3`")  # noqa: E501
        # verify the required parameter 'path' is set
        if self.api_client.client_side_validation and ('path' not in local_var_params or  # noqa: E501
                                                        local_var_params['path'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `path` when calling `scheduler_get_request_vendor_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'path' in local_var_params:
            path_params['path'] = local_var_params['path']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/vendor/contracts/{contractId}/scheduler/{path}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def scheduler_post_request_manufacturer_v3(self, contract_id, path, **kwargs):  # noqa: E501
        """scheduler_post_request_manufacturer_v3  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.scheduler_post_request_manufacturer_v3(contract_id, path, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str path: The scheduler path to be called (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.scheduler_post_request_manufacturer_v3_with_http_info(contract_id, path, **kwargs)  # noqa: E501

    def scheduler_post_request_manufacturer_v3_with_http_info(self, contract_id, path, **kwargs):  # noqa: E501
        """scheduler_post_request_manufacturer_v3  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.scheduler_post_request_manufacturer_v3_with_http_info(contract_id, path, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str path: The scheduler path to be called (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'path'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method scheduler_post_request_manufacturer_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `scheduler_post_request_manufacturer_v3`")  # noqa: E501
        # verify the required parameter 'path' is set
        if self.api_client.client_side_validation and ('path' not in local_var_params or  # noqa: E501
                                                        local_var_params['path'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `path` when calling `scheduler_post_request_manufacturer_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'path' in local_var_params:
            path_params['path'] = local_var_params['path']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/manufacturer/contracts/{contractId}/scheduler/{path}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def scheduler_post_request_vendor_v3(self, contract_id, path, **kwargs):  # noqa: E501
        """scheduler_post_request_vendor_v3  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.scheduler_post_request_vendor_v3(contract_id, path, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str path: The scheduler path to be called (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.scheduler_post_request_vendor_v3_with_http_info(contract_id, path, **kwargs)  # noqa: E501

    def scheduler_post_request_vendor_v3_with_http_info(self, contract_id, path, **kwargs):  # noqa: E501
        """scheduler_post_request_vendor_v3  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.scheduler_post_request_vendor_v3_with_http_info(contract_id, path, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str path: The scheduler path to be called (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'path'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method scheduler_post_request_vendor_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `scheduler_post_request_vendor_v3`")  # noqa: E501
        # verify the required parameter 'path' is set
        if self.api_client.client_side_validation and ('path' not in local_var_params or  # noqa: E501
                                                        local_var_params['path'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `path` when calling `scheduler_post_request_vendor_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'path' in local_var_params:
            path_params['path'] = local_var_params['path']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/vendor/contracts/{contractId}/scheduler/{path}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def scheduler_put_request_manufacturer_v3(self, contract_id, path, **kwargs):  # noqa: E501
        """scheduler_put_request_manufacturer_v3  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.scheduler_put_request_manufacturer_v3(contract_id, path, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str path: The scheduler path to be called (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.scheduler_put_request_manufacturer_v3_with_http_info(contract_id, path, **kwargs)  # noqa: E501

    def scheduler_put_request_manufacturer_v3_with_http_info(self, contract_id, path, **kwargs):  # noqa: E501
        """scheduler_put_request_manufacturer_v3  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.scheduler_put_request_manufacturer_v3_with_http_info(contract_id, path, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str path: The scheduler path to be called (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'path'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method scheduler_put_request_manufacturer_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `scheduler_put_request_manufacturer_v3`")  # noqa: E501
        # verify the required parameter 'path' is set
        if self.api_client.client_side_validation and ('path' not in local_var_params or  # noqa: E501
                                                        local_var_params['path'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `path` when calling `scheduler_put_request_manufacturer_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'path' in local_var_params:
            path_params['path'] = local_var_params['path']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/manufacturer/contracts/{contractId}/scheduler/{path}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def scheduler_put_request_vendor_v3(self, contract_id, path, **kwargs):  # noqa: E501
        """scheduler_put_request_vendor_v3  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.scheduler_put_request_vendor_v3(contract_id, path, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str path: The scheduler path to be called (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.scheduler_put_request_vendor_v3_with_http_info(contract_id, path, **kwargs)  # noqa: E501

    def scheduler_put_request_vendor_v3_with_http_info(self, contract_id, path, **kwargs):  # noqa: E501
        """scheduler_put_request_vendor_v3  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.scheduler_put_request_vendor_v3_with_http_info(contract_id, path, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str path: The scheduler path to be called (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'path'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method scheduler_put_request_vendor_v3" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `scheduler_put_request_vendor_v3`")  # noqa: E501
        # verify the required parameter 'path' is set
        if self.api_client.client_side_validation and ('path' not in local_var_params or  # noqa: E501
                                                        local_var_params['path'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `path` when calling `scheduler_put_request_vendor_v3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'path' in local_var_params:
            path_params['path'] = local_var_params['path']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/vendor/contracts/{contractId}/scheduler/{path}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def segment_offers_manufacturer_v2(self, contract_id, **kwargs):  # noqa: E501
        """segment_offers_manufacturer_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.segment_offers_manufacturer_v2(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.segment_offers_manufacturer_v2_with_http_info(contract_id, **kwargs)  # noqa: E501

    def segment_offers_manufacturer_v2_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """segment_offers_manufacturer_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.segment_offers_manufacturer_v2_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method segment_offers_manufacturer_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `segment_offers_manufacturer_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/m/contracts/{contractId}/result/offersegmentation', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def segment_offers_vendor_v2(self, contract_id, **kwargs):  # noqa: E501
        """segment_offers_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.segment_offers_vendor_v2(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.segment_offers_vendor_v2_with_http_info(contract_id, **kwargs)  # noqa: E501

    def segment_offers_vendor_v2_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """segment_offers_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.segment_offers_vendor_v2_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method segment_offers_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `segment_offers_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/result/offersegmentation', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def shop_integration_get_request(self, contract_id, path, **kwargs):  # noqa: E501
        """shop_integration_get_request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.shop_integration_get_request(contract_id, path, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str path: The shop-integration path to be called (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.shop_integration_get_request_with_http_info(contract_id, path, **kwargs)  # noqa: E501

    def shop_integration_get_request_with_http_info(self, contract_id, path, **kwargs):  # noqa: E501
        """shop_integration_get_request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.shop_integration_get_request_with_http_info(contract_id, path, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str path: The shop-integration path to be called (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'path'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method shop_integration_get_request" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `shop_integration_get_request`")  # noqa: E501
        # verify the required parameter 'path' is set
        if self.api_client.client_side_validation and ('path' not in local_var_params or  # noqa: E501
                                                        local_var_params['path'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `path` when calling `shop_integration_get_request`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'path' in local_var_params:
            path_params['path'] = local_var_params['path']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/shop-integration/{path}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def shop_integration_post_request(self, contract_id, path, **kwargs):  # noqa: E501
        """shop_integration_post_request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.shop_integration_post_request(contract_id, path, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str path: The shop-integration path to be called (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.shop_integration_post_request_with_http_info(contract_id, path, **kwargs)  # noqa: E501

    def shop_integration_post_request_with_http_info(self, contract_id, path, **kwargs):  # noqa: E501
        """shop_integration_post_request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.shop_integration_post_request_with_http_info(contract_id, path, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str path: The shop-integration path to be called (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'path'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method shop_integration_post_request" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `shop_integration_post_request`")  # noqa: E501
        # verify the required parameter 'path' is set
        if self.api_client.client_side_validation and ('path' not in local_var_params or  # noqa: E501
                                                        local_var_params['path'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `path` when calling `shop_integration_post_request`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'path' in local_var_params:
            path_params['path'] = local_var_params['path']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/shop-integration/{path}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def shop_integration_post_request_vendor_v2(self, contract_id, path, **kwargs):  # noqa: E501
        """shop_integration_post_request_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.shop_integration_post_request_vendor_v2(contract_id, path, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str path: (required)
        :param object body: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.shop_integration_post_request_vendor_v2_with_http_info(contract_id, path, **kwargs)  # noqa: E501

    def shop_integration_post_request_vendor_v2_with_http_info(self, contract_id, path, **kwargs):  # noqa: E501
        """shop_integration_post_request_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.shop_integration_post_request_vendor_v2_with_http_info(contract_id, path, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str path: (required)
        :param object body: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'path',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method shop_integration_post_request_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `shop_integration_post_request_vendor_v2`")  # noqa: E501
        # verify the required parameter 'path' is set
        if self.api_client.client_side_validation and ('path' not in local_var_params or  # noqa: E501
                                                        local_var_params['path'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `path` when calling `shop_integration_post_request_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []
        if 'path' in local_var_params and local_var_params['path'] is not None:  # noqa: E501
            query_params.append(('path', local_var_params['path']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/products/import', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def stats_manufacturer_v2(self, contract_id, session, **kwargs):  # noqa: E501
        """stats_manufacturer_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.stats_manufacturer_v2(contract_id, session, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param datetime session: A ISO 8601 timestamp which marks the end of a 48h time range in which the data is collected (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ComPatagonaPricemonitorShareApiContractStats
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.stats_manufacturer_v2_with_http_info(contract_id, session, **kwargs)  # noqa: E501

    def stats_manufacturer_v2_with_http_info(self, contract_id, session, **kwargs):  # noqa: E501
        """stats_manufacturer_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.stats_manufacturer_v2_with_http_info(contract_id, session, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param datetime session: A ISO 8601 timestamp which marks the end of a 48h time range in which the data is collected (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ComPatagonaPricemonitorShareApiContractStats, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'session'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stats_manufacturer_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `stats_manufacturer_v2`")  # noqa: E501
        # verify the required parameter 'session' is set
        if self.api_client.client_side_validation and ('session' not in local_var_params or  # noqa: E501
                                                        local_var_params['session'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `session` when calling `stats_manufacturer_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []
        if 'session' in local_var_params and local_var_params['session'] is not None:  # noqa: E501
            query_params.append(('session', local_var_params['session']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/m/contracts/{contractId}/result/contract/stats', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ComPatagonaPricemonitorShareApiContractStats',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def timestamps_manufacturer_v2(self, contract_id, limit, **kwargs):  # noqa: E501
        """timestamps_manufacturer_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.timestamps_manufacturer_v2(contract_id, limit, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param int limit: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.timestamps_manufacturer_v2_with_http_info(contract_id, limit, **kwargs)  # noqa: E501

    def timestamps_manufacturer_v2_with_http_info(self, contract_id, limit, **kwargs):  # noqa: E501
        """timestamps_manufacturer_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.timestamps_manufacturer_v2_with_http_info(contract_id, limit, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param int limit: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'limit'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method timestamps_manufacturer_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `timestamps_manufacturer_v2`")  # noqa: E501
        # verify the required parameter 'limit' is set
        if self.api_client.client_side_validation and ('limit' not in local_var_params or  # noqa: E501
                                                        local_var_params['limit'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `limit` when calling `timestamps_manufacturer_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []
        if 'limit' in local_var_params and local_var_params['limit'] is not None:  # noqa: E501
            query_params.append(('limit', local_var_params['limit']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/m/contracts/{contractId}/result/timestamps', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_alert_settings(self, contract_id, alert_id, **kwargs):  # noqa: E501
        """update_alert_settings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_alert_settings(contract_id, alert_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str alert_id: (required)
        :param object body: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_alert_settings_with_http_info(contract_id, alert_id, **kwargs)  # noqa: E501

    def update_alert_settings_with_http_info(self, contract_id, alert_id, **kwargs):  # noqa: E501
        """update_alert_settings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_alert_settings_with_http_info(contract_id, alert_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str alert_id: (required)
        :param object body: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'alert_id',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_alert_settings" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `update_alert_settings`")  # noqa: E501
        # verify the required parameter 'alert_id' is set
        if self.api_client.client_side_validation and ('alert_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['alert_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `alert_id` when calling `update_alert_settings`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'alert_id' in local_var_params:
            path_params['alertId'] = local_var_params['alert_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/1/{contractId}/settings/alerts/{alertId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_auth_token(self, email, token, **kwargs):  # noqa: E501
        """update_auth_token  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_auth_token(email, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str email: (required)
        :param str token: (required)
        :param object body: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_auth_token_with_http_info(email, token, **kwargs)  # noqa: E501

    def update_auth_token_with_http_info(self, email, token, **kwargs):  # noqa: E501
        """update_auth_token  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_auth_token_with_http_info(email, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str email: (required)
        :param str token: (required)
        :param object body: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'email',
            'token',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_auth_token" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'email' is set
        if self.api_client.client_side_validation and ('email' not in local_var_params or  # noqa: E501
                                                        local_var_params['email'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `email` when calling `update_auth_token`")  # noqa: E501
        # verify the required parameter 'token' is set
        if self.api_client.client_side_validation and ('token' not in local_var_params or  # noqa: E501
                                                        local_var_params['token'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `token` when calling `update_auth_token`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'email' in local_var_params:
            path_params['email'] = local_var_params['email']  # noqa: E501
        if 'token' in local_var_params:
            path_params['token'] = local_var_params['token']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/controlpanel/users/{email}/authtokens/{token}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_task_manufacturer_v2(self, contract_id, task_id, **kwargs):  # noqa: E501
        """update_task_manufacturer_v2  # noqa: E501

        Update an existing task  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_task_manufacturer_v2(contract_id, task_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str task_id: (required)
        :param UpdateTaskRequestV2 update_task_request_v2: The new task object to be written to the database
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: GenericTask
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_task_manufacturer_v2_with_http_info(contract_id, task_id, **kwargs)  # noqa: E501

    def update_task_manufacturer_v2_with_http_info(self, contract_id, task_id, **kwargs):  # noqa: E501
        """update_task_manufacturer_v2  # noqa: E501

        Update an existing task  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_task_manufacturer_v2_with_http_info(contract_id, task_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str task_id: (required)
        :param UpdateTaskRequestV2 update_task_request_v2: The new task object to be written to the database
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(GenericTask, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'task_id',
            'update_task_request_v2'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_task_manufacturer_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `update_task_manufacturer_v2`")  # noqa: E501
        # verify the required parameter 'task_id' is set
        if self.api_client.client_side_validation and ('task_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['task_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `task_id` when calling `update_task_manufacturer_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'task_id' in local_var_params:
            path_params['taskId'] = local_var_params['task_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'update_task_request_v2' in local_var_params:
            body_params = local_var_params['update_task_request_v2']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/m/contracts/{contractId}/tasks/{taskId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GenericTask',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_task_vendor_v2(self, contract_id, task_id, **kwargs):  # noqa: E501
        """update_task_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_task_vendor_v2(contract_id, task_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str task_id: (required)
        :param object body: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_task_vendor_v2_with_http_info(contract_id, task_id, **kwargs)  # noqa: E501

    def update_task_vendor_v2_with_http_info(self, contract_id, task_id, **kwargs):  # noqa: E501
        """update_task_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_task_vendor_v2_with_http_info(contract_id, task_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param str task_id: (required)
        :param object body: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'task_id',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_task_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `update_task_vendor_v2`")  # noqa: E501
        # verify the required parameter 'task_id' is set
        if self.api_client.client_side_validation and ('task_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['task_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `task_id` when calling `update_task_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501
        if 'task_id' in local_var_params:
            path_params['taskId'] = local_var_params['task_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/tasks/{taskId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_user_role(self, user_id, role_name, **kwargs):  # noqa: E501
        """update_user_role  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_user_role(user_id, role_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int user_id: (required)
        :param str role_name: (required)
        :param object body: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_user_role_with_http_info(user_id, role_name, **kwargs)  # noqa: E501

    def update_user_role_with_http_info(self, user_id, role_name, **kwargs):  # noqa: E501
        """update_user_role  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_user_role_with_http_info(user_id, role_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int user_id: (required)
        :param str role_name: (required)
        :param object body: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'user_id',
            'role_name',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_user_role" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'user_id' is set
        if self.api_client.client_side_validation and ('user_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['user_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `user_id` when calling `update_user_role`")  # noqa: E501
        # verify the required parameter 'role_name' is set
        if self.api_client.client_side_validation and ('role_name' not in local_var_params or  # noqa: E501
                                                        local_var_params['role_name'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `role_name` when calling `update_user_role`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in local_var_params:
            path_params['userId'] = local_var_params['user_id']  # noqa: E501
        if 'role_name' in local_var_params:
            path_params['roleName'] = local_var_params['role_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/users/{userId}/role/{roleName}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def validate_offers_manufacturer_v2(self, contract_id, **kwargs):  # noqa: E501
        """validate_offers_manufacturer_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.validate_offers_manufacturer_v2(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.validate_offers_manufacturer_v2_with_http_info(contract_id, **kwargs)  # noqa: E501

    def validate_offers_manufacturer_v2_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """validate_offers_manufacturer_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.validate_offers_manufacturer_v2_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method validate_offers_manufacturer_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `validate_offers_manufacturer_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/m/contracts/{contractId}/result/validation', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def validate_offers_vendor_v2(self, contract_id, **kwargs):  # noqa: E501
        """validate_offers_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.validate_offers_vendor_v2(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.validate_offers_vendor_v2_with_http_info(contract_id, **kwargs)  # noqa: E501

    def validate_offers_vendor_v2_with_http_info(self, contract_id, **kwargs):  # noqa: E501
        """validate_offers_vendor_v2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.validate_offers_vendor_v2_with_http_info(contract_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str contract_id: ID of the contract (required)
        :param object body: This is a generated entry and needs to be described.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'contract_id',
            'body'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method validate_offers_vendor_v2" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'contract_id' is set
        if self.api_client.client_side_validation and ('contract_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['contract_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `contract_id` when calling `validate_offers_vendor_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contract_id' in local_var_params:
            path_params['contractId'] = local_var_params['contract_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/2/v/contracts/{contractId}/result/validation', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def vendor_data(self, vendor, min_price, max_price, **kwargs):  # noqa: E501
        """vendor_data  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.vendor_data(vendor, min_price, max_price, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str vendor: (required)
        :param float min_price: (required)
        :param float max_price: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.vendor_data_with_http_info(vendor, min_price, max_price, **kwargs)  # noqa: E501

    def vendor_data_with_http_info(self, vendor, min_price, max_price, **kwargs):  # noqa: E501
        """vendor_data  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.vendor_data_with_http_info(vendor, min_price, max_price, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str vendor: (required)
        :param float min_price: (required)
        :param float max_price: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
            'vendor',
            'min_price',
            'max_price'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method vendor_data" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'vendor' is set
        if self.api_client.client_side_validation and ('vendor' not in local_var_params or  # noqa: E501
                                                        local_var_params['vendor'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `vendor` when calling `vendor_data`")  # noqa: E501
        # verify the required parameter 'min_price' is set
        if self.api_client.client_side_validation and ('min_price' not in local_var_params or  # noqa: E501
                                                        local_var_params['min_price'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `min_price` when calling `vendor_data`")  # noqa: E501
        # verify the required parameter 'max_price' is set
        if self.api_client.client_side_validation and ('max_price' not in local_var_params or  # noqa: E501
                                                        local_var_params['max_price'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `max_price` when calling `vendor_data`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'vendor' in local_var_params:
            path_params['vendor'] = local_var_params['vendor']  # noqa: E501

        query_params = []
        if 'min_price' in local_var_params and local_var_params['min_price'] is not None:  # noqa: E501
            query_params.append(('minPrice', local_var_params['min_price']))  # noqa: E501
        if 'max_price' in local_var_params and local_var_params['max_price'] is not None:  # noqa: E501
            query_params.append(('maxPrice', local_var_params['max_price']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['BasicAuth', 'BearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/controlpanel/vendorexport/{vendor}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def version(self, **kwargs):  # noqa: E501
        """Get the current application version  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.version(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: VersionApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.version_with_http_info(**kwargs)  # noqa: E501

    def version_with_http_info(self, **kwargs):  # noqa: E501
        """Get the current application version  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.version_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(VersionApiResponse, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = [
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method version" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/version', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='VersionApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)
