# coding: utf-8

"""
    Omnia 2.0 API The Omnia 2.0 API is RESTful and provides access to the backend of Omnia 2.0 and Pricemonitor. It is used to manage products, offers, contracts and more.

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)  # noqa: E501

    The version of the OpenAPI document: 0.0.7043
    Generated by: https://openapi-generator.tech
"""


import pprint
import re  # noqa: F401

import six

from pricemonitor_api_client.configuration import Configuration


class Execution(object):
    """NOTE: This class is auto generated by OpenAPI Generator.
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    """
    Attributes:
      openapi_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    openapi_types = {
        'job_name': 'str',
        'started_at': 'datetime',
        'finished_at': 'datetime',
        'success': 'bool',
        'output': 'str',
        'node_name': 'str'
    }

    attribute_map = {
        'job_name': 'job_name',
        'started_at': 'started_at',
        'finished_at': 'finished_at',
        'success': 'success',
        'output': 'output',
        'node_name': 'node_name'
    }

    def __init__(self, job_name=None, started_at=None, finished_at=None, success=None, output=None, node_name=None, local_vars_configuration=None):  # noqa: E501
        """Execution - a model defined in OpenAPI"""  # noqa: E501
        if local_vars_configuration is None:
            local_vars_configuration = Configuration()
        self.local_vars_configuration = local_vars_configuration

        self._job_name = None
        self._started_at = None
        self._finished_at = None
        self._success = None
        self._output = None
        self._node_name = None
        self.discriminator = None

        self.job_name = job_name
        self.started_at = started_at
        self.finished_at = finished_at
        if success is not None:
            self.success = success
        self.output = output
        self.node_name = node_name

    @property
    def job_name(self):
        """Gets the job_name of this Execution.  # noqa: E501

        job name  # noqa: E501

        :return: The job_name of this Execution.  # noqa: E501
        :rtype: str
        """
        return self._job_name

    @job_name.setter
    def job_name(self, job_name):
        """Sets the job_name of this Execution.

        job name  # noqa: E501

        :param job_name: The job_name of this Execution.  # noqa: E501
        :type: str
        """
        if self.local_vars_configuration.client_side_validation and job_name is None:  # noqa: E501
            raise ValueError("Invalid value for `job_name`, must not be `None`")  # noqa: E501

        self._job_name = job_name

    @property
    def started_at(self):
        """Gets the started_at of this Execution.  # noqa: E501

        start time of the execution  # noqa: E501

        :return: The started_at of this Execution.  # noqa: E501
        :rtype: datetime
        """
        return self._started_at

    @started_at.setter
    def started_at(self, started_at):
        """Sets the started_at of this Execution.

        start time of the execution  # noqa: E501

        :param started_at: The started_at of this Execution.  # noqa: E501
        :type: datetime
        """
        if self.local_vars_configuration.client_side_validation and started_at is None:  # noqa: E501
            raise ValueError("Invalid value for `started_at`, must not be `None`")  # noqa: E501

        self._started_at = started_at

    @property
    def finished_at(self):
        """Gets the finished_at of this Execution.  # noqa: E501

        when the execution finished running  # noqa: E501

        :return: The finished_at of this Execution.  # noqa: E501
        :rtype: datetime
        """
        return self._finished_at

    @finished_at.setter
    def finished_at(self, finished_at):
        """Sets the finished_at of this Execution.

        when the execution finished running  # noqa: E501

        :param finished_at: The finished_at of this Execution.  # noqa: E501
        :type: datetime
        """
        if self.local_vars_configuration.client_side_validation and finished_at is None:  # noqa: E501
            raise ValueError("Invalid value for `finished_at`, must not be `None`")  # noqa: E501

        self._finished_at = finished_at

    @property
    def success(self):
        """Gets the success of this Execution.  # noqa: E501

        the execution run successfuly  # noqa: E501

        :return: The success of this Execution.  # noqa: E501
        :rtype: bool
        """
        return self._success

    @success.setter
    def success(self, success):
        """Sets the success of this Execution.

        the execution run successfuly  # noqa: E501

        :param success: The success of this Execution.  # noqa: E501
        :type: bool
        """

        self._success = success

    @property
    def output(self):
        """Gets the output of this Execution.  # noqa: E501

        partial output of the command execution  # noqa: E501

        :return: The output of this Execution.  # noqa: E501
        :rtype: str
        """
        return self._output

    @output.setter
    def output(self, output):
        """Sets the output of this Execution.

        partial output of the command execution  # noqa: E501

        :param output: The output of this Execution.  # noqa: E501
        :type: str
        """
        if self.local_vars_configuration.client_side_validation and output is None:  # noqa: E501
            raise ValueError("Invalid value for `output`, must not be `None`")  # noqa: E501

        self._output = output

    @property
    def node_name(self):
        """Gets the node_name of this Execution.  # noqa: E501

        name of the node that executed the command  # noqa: E501

        :return: The node_name of this Execution.  # noqa: E501
        :rtype: str
        """
        return self._node_name

    @node_name.setter
    def node_name(self, node_name):
        """Sets the node_name of this Execution.

        name of the node that executed the command  # noqa: E501

        :param node_name: The node_name of this Execution.  # noqa: E501
        :type: str
        """
        if self.local_vars_configuration.client_side_validation and node_name is None:  # noqa: E501
            raise ValueError("Invalid value for `node_name`, must not be `None`")  # noqa: E501

        self._node_name = node_name

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.openapi_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, Execution):
            return False

        return self.to_dict() == other.to_dict()

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        if not isinstance(other, Execution):
            return True

        return self.to_dict() != other.to_dict()
