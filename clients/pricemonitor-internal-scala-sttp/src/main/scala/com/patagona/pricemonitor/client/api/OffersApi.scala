/**
 * Pricemonitor API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.0.6248
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
package com.patagona.pricemonitor.client.api

import com.patagona.pricemonitor.client.model.AndOfferFilter
import com.patagona.pricemonitor.client.model.ApiError
import com.patagona.pricemonitor.client.model.ContractStats
import com.patagona.pricemonitor.client.model.GetOfferStatisticsV3ApiResponse
import com.patagona.pricemonitor.client.model.GetOffersApiResponse
import com.patagona.pricemonitor.client.model.OfferFilterApiResponse
import java.time.OffsetDateTime
import com.patagona.pricemonitor.client.model.PostVendorsByDomainResponse
import com.patagona.pricemonitor.client.model.PricesByDayByProductIdRequestV2
import com.patagona.pricemonitor.client.model.PricesByDayByProductIdResponseV2
import com.patagona.pricemonitor.client.model.ProductOffersApiQuery
import com.patagona.pricemonitor.client.model.QueryOffersApiResponse
import com.patagona.pricemonitor.client.model.TagFilteredVendorsRequest
import com.patagona.pricemonitor.client.core._
import alias._
import sttp.client._
import sttp.model.Method

object OffersApi {

  def apply(baseUrl: String = "https://api.patagona.de")(implicit serializer: SttpSerializer) = new OffersApi(baseUrl)
}

class OffersApi(baseUrl: String)(implicit serializer: SttpSerializer) {

  import Helpers._
  import serializer._

  /**
   * Returns the newest offers for a given time range.
   * 
   * Expected answers:
   *   code 200 : GetOffersApiResponse (A list of products with their corresponding offers.)
   *   code 400 : ApiError (Returned in case of invalid time range or a limit greater than 10000.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param start Where to start fetching the products
   * @param limit Maximum number of results
   * @param startDate Timestamp of start of time range, formatted as ISO Date (i.e. 2018-04-06T13:46:13Z) in UTC. If this value is omitted, the range is '{endDate} - 48 hours to {endDate}' if {endDate} is given or NOW - 48 hours if both are omitted.
   * @param endDate Timestamp of end of time range, formatted as ISO Date (i.e. 2018-04-06T13:46:13Z) in UTC. If this value is omitted, the range is '{startDate} to {startDate} + 48 hours' if {startDate} is given or NOW - 48 hours if both are omitted.
   */
  def apiV3ManufacturerContractsContractIdOffersGet(contractId: String, start: Option[Int] = None, limit: Option[Int] = None, startDate: Option[OffsetDateTime] = None, endDate: Option[OffsetDateTime] = None)(implicit basicAuth: BasicCredentials, bearerToken: BearerToken): ApiRequestT[GetOffersApiResponse] =
    basicRequest
      .method(Method.GET, uri"$baseUrl/api/v3/manufacturer/contracts/${contractId}/offers?start=$start&limit=$limit&startDate=$startDate&endDate=$endDate")
      .contentType("application/json")
      .auth.basic(basicAuth.user, basicAuth.password)
      .auth.bearer(bearerToken.token)
      .response(asJson[GetOffersApiResponse])

  /**
   * Returns the newest offers for a given time range.
   * 
   * Expected answers:
   *   code 200 : GetOffersApiResponse (A list of products with their corresponding offers.)
   *   code 400 : ApiError (Returned in case of invalid time range or a limit greater than 10000.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param start Where to start fetching the products
   * @param limit Maximum number of results
   * @param startDate Timestamp of start of time range, formatted as ISO Date (i.e. 2018-04-06T13:46:13Z) in UTC. If this value is omitted, the range is '{endDate} - 48 hours to {endDate}' if {endDate} is given or NOW - 48 hours if both are omitted.
   * @param endDate Timestamp of end of time range, formatted as ISO Date (i.e. 2018-04-06T13:46:13Z) in UTC. If this value is omitted, the range is '{startDate} to {startDate} + 48 hours' if {startDate} is given or NOW - 48 hours if both are omitted.
   */
  def apiV3VendorContractsContractIdOffersGet(contractId: String, start: Option[Int] = None, limit: Option[Int] = None, startDate: Option[OffsetDateTime] = None, endDate: Option[OffsetDateTime] = None)(implicit basicAuth: BasicCredentials, bearerToken: BearerToken): ApiRequestT[GetOffersApiResponse] =
    basicRequest
      .method(Method.GET, uri"$baseUrl/api/v3/vendor/contracts/${contractId}/offers?start=$start&limit=$limit&startDate=$startDate&endDate=$endDate")
      .contentType("application/json")
      .auth.basic(basicAuth.user, basicAuth.password)
      .auth.bearer(bearerToken.token)
      .response(asJson[GetOffersApiResponse])

  /**
   * Expected answers:
   *   code 200 : QueryOffersApiResponse (Returns either an Error or a list of ApiOffers matching the given filter.)
   *   code 400 : ApiError (Returned in case of unparsable request JSON or unsupported filter/sorting.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param productOffersApiQuery The request body specifies which offers will be searched for.<br> Warning: It's highly recommended to not use this endpoint since it is error-prone due to complex query structure! Supported are queries with three different types of filters:<br> 1. Filtering for offers of a certain product<br> This can be done by a ComparisonFilter with   * the `left` side being a `StringValueProvider` with the `attributeName` value \"productId\"   * the `right` side being a `StringConstantValueProvider` with the `value` being the actual pricemonitor product ID to filter offers for   * the `comparison` being a `StringEquality`  2. Filtering for valid offers of a certain product<br> This can be done by an AndFilter with   * a) A product filter (see first supported filter)   * b) A NotFilter which contains a ComparisonFilter     * the `left` side being a `NumberValueProvider` with the `attributeName` value \"ignoredBy\"     * the `right` side being a `NumberConstantValueProvider` with the `value` being the numeric contract id to filter offers for     * the `comparison` being a `NumberEquality`  3. Filtering for offers of a certain vendor<br> This can be done by a ComparisonFilter with   * the `left` side being a `StringValueProvider` with the `attributeName` value \"reseller_name\"   * the `right` side being a `StringConstantValueProvider` with the `value` being the actual vendor name to filter offers for   * the `comparison` being a `StringEquality`  Note: This endpoint will only return the newest offers for each product for a given time range.
   */
  def apiV3VendorContractsContractIdOffersQueryPost(contractId: String, productOffersApiQuery: ProductOffersApiQuery)(implicit basicAuth: BasicCredentials, bearerToken: BearerToken): ApiRequestT[QueryOffersApiResponse] =
    basicRequest
      .method(Method.POST, uri"$baseUrl/api/v3/vendor/contracts/${contractId}/offers/query")
      .contentType("application/json")
      .auth.basic(basicAuth.user, basicAuth.password)
      .auth.bearer(bearerToken.token)
      .body(productOffersApiQuery)
      .response(asJson[QueryOffersApiResponse])

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param session 
   * @param includeDeliveryCosts 
   * @param tagFilteredVendorsRequest This is a generated entry and needs to be described.
   */
  def getCheapestVendorsManufacturerV2(contractId: String, session: OffsetDateTime, includeDeliveryCosts: Boolean, tagFilteredVendorsRequest: Option[TagFilteredVendorsRequest] = None)(implicit basicAuth: BasicCredentials, bearerToken: BearerToken): ApiRequestT[Any] =
    basicRequest
      .method(Method.POST, uri"$baseUrl/api/2/m/contracts/${contractId}/result/vendors/cheapest?session=$session&includeDeliveryCosts=$includeDeliveryCosts")
      .contentType("application/json")
      .auth.basic(basicAuth.user, basicAuth.password)
      .auth.bearer(bearerToken.token)
      .body(tagFilteredVendorsRequest)
      .response(asJson[Any])

  /**
   * Expected answers:
   *   code 200 : OfferFilterApiResponse (List of the filters to ignore the individual offers.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param listType 
   */
  def getComplexOfferFiltersVendorV2(contractId: String, listType: String)(implicit basicAuth: BasicCredentials, bearerToken: BearerToken): ApiRequestT[OfferFilterApiResponse] =
    basicRequest
      .method(Method.GET, uri"$baseUrl/api/2/v/contracts/${contractId}/offerfilters/${listType}/complex")
      .contentType("application/json")
      .auth.basic(basicAuth.user, basicAuth.password)
      .auth.bearer(bearerToken.token)
      .response(asJson[OfferFilterApiResponse])

  /**
   * Expected answers:
   *   code 200 : Any (List of the filters to ignore the individual offers. Offers are filtered against vendor name either for all the domain or for a specific domain.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param listType 
   */
  def getOfferFiltersVendorV2(contractId: String, listType: String)(implicit basicAuth: BasicCredentials, bearerToken: BearerToken): ApiRequestT[Any] =
    basicRequest
      .method(Method.GET, uri"$baseUrl/api/2/v/contracts/${contractId}/offerfilters/${listType}/vendors")
      .contentType("application/json")
      .auth.basic(basicAuth.user, basicAuth.password)
      .auth.bearer(bearerToken.token)
      .response(asJson[Any])

  /**
   * Expected answers:
   *   code 200 : GetOfferStatisticsV3ApiResponse (Returns a list of offer statistics per product.)
   *   code 400 : ApiError (Specified time range is invalid (> 48h).)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param includeDeliveryCosts 
   * @param startDate Timestamp of start of time range, formatted as ISO Date (i.e. 2018-04-06T13:46:13Z) in UTC. If this value is omitted, the range is '{endDate} - 48 hours to {endDate}' if {endDate} is given or NOW - 48 hours if both are omitted.
   * @param endDate Timestamp of end of time range, formatted as ISO Date (i.e. 2018-04-06T13:46:13Z) in UTC. If this value is omitted, the range is '{startDate} to {startDate} + 48 hours' if {startDate} is given or NOW - 48 hours if both are omitted.
   */
  def getOfferStatisticsManufacturerV3(contractId: String, includeDeliveryCosts: Boolean, startDate: Option[OffsetDateTime] = None, endDate: Option[OffsetDateTime] = None)(implicit basicAuth: BasicCredentials, bearerToken: BearerToken): ApiRequestT[GetOfferStatisticsV3ApiResponse] =
    basicRequest
      .method(Method.GET, uri"$baseUrl/api/v3/manufacturer/contracts/${contractId}/offers/stats?startDate=$startDate&endDate=$endDate&includeDeliveryCosts=$includeDeliveryCosts")
      .contentType("application/json")
      .auth.basic(basicAuth.user, basicAuth.password)
      .auth.bearer(bearerToken.token)
      .response(asJson[GetOfferStatisticsV3ApiResponse])

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param session 
   * @param limit 
   * @param includeDeliveryCosts 
   * @param body This is a generated entry and needs to be described.
   */
  def getPriceCuttersManufacturerV2(contractId: String, session: OffsetDateTime, limit: Int, includeDeliveryCosts: Boolean, body: Option[Any] = None)(implicit basicAuth: BasicCredentials, bearerToken: BearerToken): ApiRequestT[Any] =
    basicRequest
      .method(Method.POST, uri"$baseUrl/api/2/m/contracts/${contractId}/result/pricecutters?session=$session&limit=$limit&includeDeliveryCosts=$includeDeliveryCosts")
      .contentType("application/json")
      .auth.basic(basicAuth.user, basicAuth.password)
      .auth.bearer(bearerToken.token)
      .body(body)
      .response(asJson[Any])

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param session 
   * @param limit 
   * @param includeDeliveryCosts 
   * @param body This is a generated entry and needs to be described.
   */
  def getPriceCuttersVendorV2(contractId: String, session: OffsetDateTime, limit: Int, includeDeliveryCosts: Boolean, body: Option[Any] = None)(implicit basicAuth: BasicCredentials, bearerToken: BearerToken): ApiRequestT[Any] =
    basicRequest
      .method(Method.POST, uri"$baseUrl/api/2/v/contracts/${contractId}/result/pricecutters?session=$session&limit=$limit&includeDeliveryCosts=$includeDeliveryCosts")
      .contentType("application/json")
      .auth.basic(basicAuth.user, basicAuth.password)
      .auth.bearer(bearerToken.token)
      .body(body)
      .response(asJson[Any])

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param body This is a generated entry and needs to be described.
   */
  def getProductFiltersByIDVendorV2(contractId: String, body: Option[Any] = None)(implicit basicAuth: BasicCredentials, bearerToken: BearerToken): ApiRequestT[Any] =
    basicRequest
      .method(Method.POST, uri"$baseUrl/api/2/v/contracts/${contractId}/offerfilters/:listType/products/query")
      .contentType("application/json")
      .auth.basic(basicAuth.user, basicAuth.password)
      .auth.bearer(bearerToken.token)
      .body(body)
      .response(asJson[Any])

  /**
   * Expected answers:
   *   code 200 : Any (List of the filters per product to ignore the individual offers.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param listType 
   * @param start 
   * @param limit 
   */
  def getProductFiltersByRangeVendorV2(contractId: String, listType: String, start: Int, limit: Int)(implicit basicAuth: BasicCredentials, bearerToken: BearerToken): ApiRequestT[Any] =
    basicRequest
      .method(Method.GET, uri"$baseUrl/api/2/v/contracts/${contractId}/offerfilters/${listType}/products?start=$start&limit=$limit")
      .contentType("application/json")
      .auth.basic(basicAuth.user, basicAuth.password)
      .auth.bearer(bearerToken.token)
      .response(asJson[Any])

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param start 
   * @param end 
   */
  def getProductMetricsByContract(contractId: String, start: OffsetDateTime, end: OffsetDateTime)(implicit basicAuth: BasicCredentials, bearerToken: BearerToken): ApiRequestT[Any] =
    basicRequest
      .method(Method.GET, uri"$baseUrl/api/1/${contractId}/products/articlescountbyportal?start=$start&end=$end")
      .contentType("application/json")
      .auth.basic(basicAuth.user, basicAuth.password)
      .auth.bearer(bearerToken.token)
      .response(asJson[Any])

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param start 
   * @param end 
   * @param includeDeliveryCosts 
   * @param referencePriceDelta 
   */
  def getProductPriceViolationsManufacturerV2(contractId: String, start: OffsetDateTime, end: OffsetDateTime, includeDeliveryCosts: Boolean, referencePriceDelta: Double)(implicit basicAuth: BasicCredentials, bearerToken: BearerToken): ApiRequestT[Any] =
    basicRequest
      .method(Method.GET, uri"$baseUrl/api/2/m/contracts/${contractId}/result/priceviolations?start=$start&end=$end&includeDeliveryCosts=$includeDeliveryCosts&referencePriceDelta=$referencePriceDelta")
      .contentType("application/json")
      .auth.basic(basicAuth.user, basicAuth.password)
      .auth.bearer(bearerToken.token)
      .response(asJson[Any])

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param start 
   * @param end 
   * @param includeDeliveryCosts 
   * @param referencePriceDelta 
   */
  def getProductPriceViolationsVendorV2(contractId: String, start: OffsetDateTime, end: OffsetDateTime, includeDeliveryCosts: Boolean, referencePriceDelta: Double)(implicit basicAuth: BasicCredentials, bearerToken: BearerToken): ApiRequestT[Any] =
    basicRequest
      .method(Method.GET, uri"$baseUrl/api/2/v/contracts/${contractId}/result/priceviolations?start=$start&end=$end&includeDeliveryCosts=$includeDeliveryCosts&referencePriceDelta=$referencePriceDelta")
      .contentType("application/json")
      .auth.basic(basicAuth.user, basicAuth.password)
      .auth.bearer(bearerToken.token)
      .response(asJson[Any])

  /**
   * Expected answers:
   *   code 200 : PostVendorsByDomainResponse (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param domain 
   * @param start 
   * @param includeDeliveryCosts 
   * @param session 
   * @param tagFilteredVendorsRequest This is a generated entry and needs to be described.
   */
  def getVendorsByDomainManufacturerV2(contractId: String, domain: String, start: Int, includeDeliveryCosts: Boolean, session: OffsetDateTime, tagFilteredVendorsRequest: Option[TagFilteredVendorsRequest] = None)(implicit basicAuth: BasicCredentials, bearerToken: BearerToken): ApiRequestT[PostVendorsByDomainResponse] =
    basicRequest
      .method(Method.POST, uri"$baseUrl/api/2/m/contracts/${contractId}/result/vendors/list?domain=$domain&start=$start&includeDeliveryCosts=$includeDeliveryCosts&session=$session")
      .contentType("application/json")
      .auth.basic(basicAuth.user, basicAuth.password)
      .auth.bearer(bearerToken.token)
      .body(tagFilteredVendorsRequest)
      .response(asJson[PostVendorsByDomainResponse])

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param vendor 
   * @param day 
   * @param body This is a generated entry and needs to be described.
   */
  def positionDistribution(contractId: String, vendor: String, day: OffsetDateTime, body: Option[Any] = None)(implicit basicAuth: BasicCredentials, bearerToken: BearerToken): ApiRequestT[Any] =
    basicRequest
      .method(Method.POST, uri"$baseUrl/api/1/${contractId}/vendors/${vendor}/positions?day=$day")
      .contentType("application/json")
      .auth.basic(basicAuth.user, basicAuth.password)
      .auth.bearer(bearerToken.token)
      .body(body)
      .response(asJson[Any])

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param body This is a generated entry and needs to be described.
   */
  def postOffersInABulkVendorV2(contractId: String, body: Option[Any] = None)(implicit basicAuth: BasicCredentials, bearerToken: BearerToken): ApiRequestT[Any] =
    basicRequest
      .method(Method.POST, uri"$baseUrl/api/2/v/contracts/${contractId}/offers")
      .contentType("application/json")
      .auth.basic(basicAuth.user, basicAuth.password)
      .auth.bearer(bearerToken.token)
      .body(body)
      .response(asJson[Any])

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param productId 
   * @param body This is a generated entry and needs to be described.
   */
  def postOffersVendorV2(contractId: String, productId: String, body: Option[Any] = None)(implicit basicAuth: BasicCredentials, bearerToken: BearerToken): ApiRequestT[Any] =
    basicRequest
      .method(Method.POST, uri"$baseUrl/api/2/v/contracts/${contractId}/offers/${productId}")
      .contentType("application/json")
      .auth.basic(basicAuth.user, basicAuth.password)
      .auth.bearer(bearerToken.token)
      .body(body)
      .response(asJson[Any])

  /**
   * Expected answers:
   *   code 200 : Seq[PricesByDayByProductIdResponseV2] (The list of all known prices for the queried day & product ID)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param productId The product ID to filter for
   * @param pricesByDayByProductIdRequestV2 Query all known prices for a given day & product ID. Can be filtered by using the selectors.
   */
  def pricesByDayByProductIdManufacturerV2(contractId: String, productId: String, pricesByDayByProductIdRequestV2: Option[PricesByDayByProductIdRequestV2] = None)(implicit basicAuth: BasicCredentials, bearerToken: BearerToken): ApiRequestT[Seq[PricesByDayByProductIdResponseV2]] =
    basicRequest
      .method(Method.POST, uri"$baseUrl/api/2/m/contracts/${contractId}/result/pricesbyday/productid/${productId}")
      .contentType("application/json")
      .auth.basic(basicAuth.user, basicAuth.password)
      .auth.bearer(bearerToken.token)
      .body(pricesByDayByProductIdRequestV2)
      .response(asJson[Seq[PricesByDayByProductIdResponseV2]])

  /**
   * Expected answers:
   *   code 200 : OfferFilterApiResponse (List of the filters that have been sent as the request body.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param listType 
   * @param andOfferFilter List of the filter that needs to be considered to ignore the individual offers.
   */
  def putComplexOfferFiltersVendorV2(contractId: String, listType: String, andOfferFilter: Seq[AndOfferFilter])(implicit basicAuth: BasicCredentials, bearerToken: BearerToken): ApiRequestT[OfferFilterApiResponse] =
    basicRequest
      .method(Method.PUT, uri"$baseUrl/api/2/v/contracts/${contractId}/offerfilters/${listType}/complex")
      .contentType("application/json")
      .auth.basic(basicAuth.user, basicAuth.password)
      .auth.bearer(bearerToken.token)
      .body(andOfferFilter)
      .response(asJson[OfferFilterApiResponse])

  /**
   * Expected answers:
   *   code 200 : Any (List of the filters that have been sent as the request body.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param listType 
   * @param body List of the filters that needs to be considered to ignore the individual offers.
   */
  def putOfferFiltersVendorV2(contractId: String, listType: String, body: Option[Any] = None)(implicit basicAuth: BasicCredentials, bearerToken: BearerToken): ApiRequestT[Any] =
    basicRequest
      .method(Method.PUT, uri"$baseUrl/api/2/v/contracts/${contractId}/offerfilters/${listType}/vendors")
      .contentType("application/json")
      .auth.basic(basicAuth.user, basicAuth.password)
      .auth.bearer(bearerToken.token)
      .body(body)
      .response(asJson[Any])

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param body This is a generated entry and needs to be described.
   */
  def queryOffersManufacturerV3(contractId: String, body: Option[Any] = None)(implicit basicAuth: BasicCredentials, bearerToken: BearerToken): ApiRequestT[Any] =
    basicRequest
      .method(Method.POST, uri"$baseUrl/api/v3/manufacturer/contracts/${contractId}/offers/query")
      .contentType("application/json")
      .auth.basic(basicAuth.user, basicAuth.password)
      .auth.bearer(bearerToken.token)
      .body(body)
      .response(asJson[Any])

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param start 
   * @param limit 
   * @param since 
   * @param until 
   */
  def rawOffers(contractId: String, start: Int, limit: Int, since: Option[OffsetDateTime] = None, until: Option[OffsetDateTime] = None)(implicit basicAuth: BasicCredentials, bearerToken: BearerToken): ApiRequestT[Any] =
    basicRequest
      .method(Method.GET, uri"$baseUrl/api/1/${contractId}/products/offers?start=$start&limit=$limit&since=$since&until=$until")
      .contentType("application/json")
      .auth.basic(basicAuth.user, basicAuth.password)
      .auth.bearer(bearerToken.token)
      .response(asJson[Any])

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param body This is a generated entry and needs to be described.
   */
  def segmentOffersManufacturerV2(contractId: String, body: Option[Any] = None)(implicit basicAuth: BasicCredentials, bearerToken: BearerToken): ApiRequestT[Any] =
    basicRequest
      .method(Method.POST, uri"$baseUrl/api/2/m/contracts/${contractId}/result/offersegmentation")
      .contentType("application/json")
      .auth.basic(basicAuth.user, basicAuth.password)
      .auth.bearer(bearerToken.token)
      .body(body)
      .response(asJson[Any])

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param body This is a generated entry and needs to be described.
   */
  def segmentOffersVendorV2(contractId: String, body: Option[Any] = None)(implicit basicAuth: BasicCredentials, bearerToken: BearerToken): ApiRequestT[Any] =
    basicRequest
      .method(Method.POST, uri"$baseUrl/api/2/v/contracts/${contractId}/result/offersegmentation")
      .contentType("application/json")
      .auth.basic(basicAuth.user, basicAuth.password)
      .auth.bearer(bearerToken.token)
      .body(body)
      .response(asJson[Any])

  /**
   * Expected answers:
   *   code 200 : ContractStats (Get the contract statistics: product count, vendor count, found offers count (filters applied), active portals count, found offers count (no filters applied))
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param session A ISO 8601 timestamp which marks the end of a 48h time range in which the data is collected
   */
  def statsManufacturerV2(contractId: String, session: OffsetDateTime)(implicit basicAuth: BasicCredentials, bearerToken: BearerToken): ApiRequestT[ContractStats] =
    basicRequest
      .method(Method.GET, uri"$baseUrl/api/2/m/contracts/${contractId}/result/contract/stats?session=$session")
      .contentType("application/json")
      .auth.basic(basicAuth.user, basicAuth.password)
      .auth.bearer(bearerToken.token)
      .response(asJson[ContractStats])

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param limit 
   */
  def timestampsManufacturerV2(contractId: String, limit: Int)(implicit basicAuth: BasicCredentials, bearerToken: BearerToken): ApiRequestT[Any] =
    basicRequest
      .method(Method.GET, uri"$baseUrl/api/2/m/contracts/${contractId}/result/timestamps?limit=$limit")
      .contentType("application/json")
      .auth.basic(basicAuth.user, basicAuth.password)
      .auth.bearer(bearerToken.token)
      .response(asJson[Any])

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param body This is a generated entry and needs to be described.
   */
  def validateOffersManufacturerV2(contractId: String, body: Option[Any] = None)(implicit basicAuth: BasicCredentials, bearerToken: BearerToken): ApiRequestT[Any] =
    basicRequest
      .method(Method.POST, uri"$baseUrl/api/2/m/contracts/${contractId}/result/validation")
      .contentType("application/json")
      .auth.basic(basicAuth.user, basicAuth.password)
      .auth.bearer(bearerToken.token)
      .body(body)
      .response(asJson[Any])

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param body This is a generated entry and needs to be described.
   */
  def validateOffersVendorV2(contractId: String, body: Option[Any] = None)(implicit basicAuth: BasicCredentials, bearerToken: BearerToken): ApiRequestT[Any] =
    basicRequest
      .method(Method.POST, uri"$baseUrl/api/2/v/contracts/${contractId}/result/validation")
      .contentType("application/json")
      .auth.basic(basicAuth.user, basicAuth.password)
      .auth.bearer(bearerToken.token)
      .body(body)
      .response(asJson[Any])

}

