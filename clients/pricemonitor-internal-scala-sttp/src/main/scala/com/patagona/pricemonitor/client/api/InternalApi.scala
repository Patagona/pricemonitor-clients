/**
 * Omnia 2.0 API The Omnia 2.0 API is RESTful and provides access to the backend of Omnia 2.0 and Pricemonitor. It is used to manage products, offers, contracts and more.
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.0.7113
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
package com.patagona.pricemonitor.client.api

import com.patagona.pricemonitor.client.model.ActivateMarketplaceResponseV3ApiResponse
import com.patagona.pricemonitor.client.model.AdminCompanyV2
import com.patagona.pricemonitor.client.model.AndOfferFilter
import com.patagona.pricemonitor.client.model.ApiError
import com.patagona.pricemonitor.client.model.ApiErrorResponse
import com.patagona.pricemonitor.client.model.ApiQuery
import com.patagona.pricemonitor.client.model.Callbacks
import com.patagona.pricemonitor.client.model.ContractStats
import com.patagona.pricemonitor.client.model.CreateTaskBodyV2
import com.patagona.pricemonitor.client.model.CustomerContractSettings
import com.patagona.pricemonitor.client.model.DeleteByNumericIdApiResponse
import com.patagona.pricemonitor.client.model.EmbedSSOUrlResponseV3ApiResponse
import com.patagona.pricemonitor.client.model.EmptyApiResponse
import com.patagona.pricemonitor.client.model.GeneratePasswordResponseV3ApiResponse
import com.patagona.pricemonitor.client.model.GenericTask
import com.patagona.pricemonitor.client.model.GenericTaskWithUrl
import com.patagona.pricemonitor.client.model.GetAuthorizationStatusResponseV3ApiResponse
import com.patagona.pricemonitor.client.model.GetCompanyUsersUser
import com.patagona.pricemonitor.client.model.GetContractSettingsResponseV1
import com.patagona.pricemonitor.client.model.GetCustomerContractSettingsApiResponse
import com.patagona.pricemonitor.client.model.GetManufacturerV3ApiResponse
import com.patagona.pricemonitor.client.model.GetMonitoringSchedulesApiResponse
import com.patagona.pricemonitor.client.model.GetOfferStatisticsV3ApiResponse
import com.patagona.pricemonitor.client.model.GetOffersResponse
import com.patagona.pricemonitor.client.model.GetProductMonitoringStatusStatsVendorV3ApiResponse
import com.patagona.pricemonitor.client.model.GetProductPropertiesV3ApiResponse
import com.patagona.pricemonitor.client.model.GetShopsByDomainResponseV3ApiResponse
import com.patagona.pricemonitor.client.model.GetUserAccessToContractsOfCompanyV3ApiResponse
import com.patagona.pricemonitor.client.model.GetVendorShopMappingsApiResponse
import com.patagona.pricemonitor.client.model.InviteUserToCompanyRequestV3
import com.patagona.pricemonitor.client.model.InviteUserToCompanyResponseV3ApiResponse
import com.patagona.pricemonitor.client.model.LookerUserAttributesV3ApiResponse
import com.patagona.pricemonitor.client.model.NewUser
import com.patagona.pricemonitor.client.model.OfferFilterApiResponse
import java.time.OffsetDateTime
import com.patagona.pricemonitor.client.model.PostAccountRequestV3
import com.patagona.pricemonitor.client.model.PostAccountResponseV3ApiResponse
import com.patagona.pricemonitor.client.model.PostActivateMarketplaceRequestV3
import com.patagona.pricemonitor.client.model.PostAdminAddDomainBodyV3
import com.patagona.pricemonitor.client.model.PostAdminAddDomainV3ApiResponse
import com.patagona.pricemonitor.client.model.PostAuthorizeSellerRequestV3
import com.patagona.pricemonitor.client.model.PostAuthorizeSellerResponseV3ApiResponse
import com.patagona.pricemonitor.client.model.PostEmbedSSOUrlRequestV3
import com.patagona.pricemonitor.client.model.PostMonitoringScheduleRequestV3
import com.patagona.pricemonitor.client.model.PostNewPasswordRequest
import com.patagona.pricemonitor.client.model.PostOfferStatisticsApiResponse
import com.patagona.pricemonitor.client.model.PostOfferStatisticsRequest
import com.patagona.pricemonitor.client.model.PostOfferStatisticsRequestV31
import com.patagona.pricemonitor.client.model.PostScenarioStrategyRequest
import com.patagona.pricemonitor.client.model.PostScenarioStrategyResponseApiResponse
import com.patagona.pricemonitor.client.model.PostVendorShopMappingRequestV3
import com.patagona.pricemonitor.client.model.PostVendorsByDomainResponse
import com.patagona.pricemonitor.client.model.PriceDumpingStatsRequest
import com.patagona.pricemonitor.client.model.PriceRecommendationApiQueryV2
import com.patagona.pricemonitor.client.model.PricesByDayByProductIdRequestV2
import com.patagona.pricemonitor.client.model.PricesByDayByProductIdResponseV2
import com.patagona.pricemonitor.client.model.PutAdminContractSettingsBody
import com.patagona.pricemonitor.client.model.PutAdminDomainRequestV3
import com.patagona.pricemonitor.client.model.PutAdminDomainResponseV3ApiResponse
import com.patagona.pricemonitor.client.model.PutCustomerContractSettingsApiResponse
import com.patagona.pricemonitor.client.model.PutMonitoringSchedulesApiResponse
import com.patagona.pricemonitor.client.model.PutProductPropertiesRequestV3
import com.patagona.pricemonitor.client.model.PutProductsApiResponse
import com.patagona.pricemonitor.client.model.PutResetPasswordRequest
import com.patagona.pricemonitor.client.model.QueryOfferStatisticsV31ApiResponse
import com.patagona.pricemonitor.client.model.QueryOffersOfShopRequestV3
import com.patagona.pricemonitor.client.model.QueryOffersOfShopV3ApiResponse
import com.patagona.pricemonitor.client.model.QueryPriceDumpingStatsApiResponse
import com.patagona.pricemonitor.client.model.QueryPriceRecommendationsV2ApiResponse
import com.patagona.pricemonitor.client.model.QueryProductsByFilterManufacturerV3ApiResponse
import com.patagona.pricemonitor.client.model.QueryProductsByFilterVendorV3ApiResponse
import com.patagona.pricemonitor.client.model.QueryProductsManufacturerV3ApiResponse
import com.patagona.pricemonitor.client.model.QueryProductsRequestV3
import com.patagona.pricemonitor.client.model.ScenarioStrategyMetadataResponseApiResponse
import com.patagona.pricemonitor.client.model.ScenarioStrategyResponse
import com.patagona.pricemonitor.client.model.StringArrayResponse
import com.patagona.pricemonitor.client.model.TagFilteredVendorsRequest
import com.patagona.pricemonitor.client.model.TaskIdAndUrl
import com.patagona.pricemonitor.client.model.UpdateTaskRequestV2
import com.patagona.pricemonitor.client.model.UserAccessToContractsOfCompany
import com.patagona.pricemonitor.client.model.UserInfo
import com.patagona.pricemonitor.client.model.UserSignupRequest
import com.patagona.pricemonitor.client.model.VendorShopMappingV3ApiResponse
import com.patagona.pricemonitor.client.model.VersionApiResponse
import com.patagona.pricemonitor.client.core._
import alias._
import sttp.client._
import sttp.model.Method

object InternalApi {

  def apply(baseUrl: String = "https://api.patagona.de")(implicit serializer: SttpSerializer) = new InternalApi(baseUrl)
}

class InternalApi(baseUrl: String)(implicit serializer: SttpSerializer) {

  import Helpers._
  import serializer._

  /**
   * Add a company.
   * 
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   */
  def addCompany()(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.POST, uri"$baseUrl/controlpanel/api/companies")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param id 
   * @param email 
   * @param body This is a generated entry and needs to be described.
   */
  def addCompanyUser(id: Int, email: String, body: Option[Any] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.PUT, uri"$baseUrl/controlpanel/companies/${id}/users/${email}")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(body)
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : PostScenarioStrategyResponseApiResponse (A new scenario strategy was added)
   *   code 400 : ApiErrorResponse (Strategy must be valid and consistent with the schema version. Required fields need to be filled.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param postScenarioStrategyRequest The scenario strategy to be stored. Including the necessary metadata.
   */
  def addPricingStrategyScenario(contractId: String, postScenarioStrategyRequest: Option[PostScenarioStrategyRequest] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[PostScenarioStrategyResponseApiResponse] =
{
    var r = basicRequest
      .method(Method.POST, uri"$baseUrl/api/v3/vendor/contracts/${contractId}/settings/pricingstrategies/scenarios")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(postScenarioStrategyRequest)
      r.response(asJson[PostScenarioStrategyResponseApiResponse])
}

  /**
   * Expected answers:
   *   code 200 :  (A new user was added)
   *   code 400 :  (A new user was not added)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param newUser The new user to be added
   */
  def addUser(newUser: Option[NewUser] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Unit] =
{
    var r = basicRequest
      .method(Method.POST, uri"$baseUrl/controlpanel/users")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(newUser)
      r.response(asJson[Unit])
}

  /**
   * Expected answers:
   *   code 200 : Any (Authenticate with the API and create a session)
   */
  def authenticate(): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.POST, uri"$baseUrl/login")
      .contentType("application/json")
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : Any (Change the current user's password.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   */
  def changePassword()(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.PUT, uri"$baseUrl/api/account/password")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 :  (No response was specified)
   *   code 204 :  (Confirmation token was found)
   *   code 404 :  (No such confirmation token was found)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param token 
   */
  def checkUserConfirmation(token: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Unit] =
{
    var r = basicRequest
      .method(Method.HEAD, uri"$baseUrl/api/account/confirm/${token}")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Unit])
}

  /**
   * Expected answers:
   *   code 200 :  (No response was specified)
   *   code 204 :  (User was confirmed & logged in)
   *   code 400 : ApiErrorResponse (Unable to confirm the user because of bad request data)
   *   code 500 : ApiErrorResponse (Unable to confirm the user because of an unexpected error)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param token 
   * @param body The password that should be set on the confirmed user
   */
  def confirmUser(token: String, body: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Unit] =
{
    var r = basicRequest
      .method(Method.POST, uri"$baseUrl/api/account/confirm/${token}")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(body)
      r.response(asJson[Unit])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param body This is a generated entry and needs to be described.
   */
  def createAlertSettings(contractId: String, body: Option[Any] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.POST, uri"$baseUrl/api/1/${contractId}/settings/alerts")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(body)
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param email 
   * @param body This is a generated entry and needs to be described.
   */
  def createAuthToken(email: String, body: Option[Any] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.POST, uri"$baseUrl/controlpanel/users/${email}/authtokens")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(body)
      r.response(asJson[Any])
}

  /**
   * Create a new task
   * 
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param createTaskBodyV2 Create a new task
   */
  def createTask(contractId: String, createTaskBodyV2: Option[CreateTaskBodyV2] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.POST, uri"$baseUrl/api/1/${contractId}/tasks")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(createTaskBodyV2)
      r.response(asJson[Any])
}

  /**
   * Creates a new task for a manufacturer contract
   * 
   * Expected answers:
   *   code 200 : GenericTaskWithUrl (The new task was successfully created)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param createTaskBodyV2 This is a generated entry and needs to be described.
   */
  def createTaskManufacturerV2(contractId: String, createTaskBodyV2: Option[CreateTaskBodyV2] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[GenericTaskWithUrl] =
{
    var r = basicRequest
      .method(Method.POST, uri"$baseUrl/api/2/m/contracts/${contractId}/tasks")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(createTaskBodyV2)
      r.response(asJson[GenericTaskWithUrl])
}

  /**
   * Creates a new task for a vendor contract.
   * 
   * Expected answers:
   *   code 200 : Any (Task has been created successfully)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param createTaskBodyV2 Create a new task
   */
  def createTaskVendorV2(contractId: String, createTaskBodyV2: Option[CreateTaskBodyV2] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.POST, uri"$baseUrl/api/2/v/contracts/${contractId}/tasks")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(createTaskBodyV2)
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param alertId 
   */
  def deleteAlertSettings(contractId: String, alertId: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.DELETE, uri"$baseUrl/api/1/${contractId}/settings/alerts/${alertId}")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param email 
   * @param token 
   */
  def deleteAuthToken(email: String, token: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.DELETE, uri"$baseUrl/controlpanel/users/${email}/authtokens/${token}")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   */
  def deleteCallbackSettingsManufacturerV2(contractId: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.DELETE, uri"$baseUrl/api/2/m/contracts/${contractId}/settings/callbacks")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   */
  def deleteCallbackSettingsVendorV2(contractId: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.DELETE, uri"$baseUrl/api/2/v/contracts/${contractId}/settings/callbacks")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   */
  def deleteContractVendorV2(contractId: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.DELETE, uri"$baseUrl/api/2/v/contracts/${contractId}")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   */
  def deleteDynamicMonitoringSettings(contractId: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.DELETE, uri"$baseUrl/api/1/${contractId}/settings/dynamicmonitoring")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * The DELETE request is proxied to the internal export API.
   * 
   * Expected answers:
   *   code 200 : Any (Successful response returned by the Export API.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param path The export path to be called
   */
  def deleteExportRequestVendorV3(contractId: String, path: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.DELETE, uri"$baseUrl/api/v3/vendor/contracts/${contractId}/export/${path}")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param feedId 
   */
  def deleteFeedVendorV2(contractId: String, feedId: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.DELETE, uri"$baseUrl/api/2/v/contracts/${contractId}/feeds/${feedId}")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * The DELETE request is proxied to the internal import-export API.
   * 
   * Expected answers:
   *   code 200 : Any (Successful response returned by the import-export API.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param path The import-export path to be called
   */
  def deleteImportExportRequestVendorV3(contractId: String, path: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.DELETE, uri"$baseUrl/api/v3/vendor/contracts/${contractId}/import-export/${path}")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * The DELETE request is proxied to the internal import API.
   * 
   * Expected answers:
   *   code 200 : Any (Successful response returned by the Import API.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param path The import path to be called
   */
  def deleteImportRequestVendorV3(contractId: String, path: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.DELETE, uri"$baseUrl/api/v3/vendor/contracts/${contractId}/import/${path}")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   */
  def deleteImportSettingsVendorV2(contractId: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.DELETE, uri"$baseUrl/api/2/v/contracts/${contractId}/settings/import")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * Delete a monitoring schedule for a given manufacturer contract.
   * 
   * Expected answers:
   *   code 200 : DeleteByNumericIdApiResponse (Monitoring schedule has been deleted successfully.)
   *   code 404 : ApiErrorResponse (Specified monitoring schedule does not exist.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param scheduleId ID of a monitoring schedule
   */
  def deleteMonitoringScheduleManufacturerV3(contractId: String, scheduleId: Int)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[DeleteByNumericIdApiResponse] =
{
    var r = basicRequest
      .method(Method.DELETE, uri"$baseUrl/api/v3/manufacturer/contracts/${contractId}/settings/monitoringschedules/${scheduleId}")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[DeleteByNumericIdApiResponse])
}

  /**
   * Delete a monitoring schedule for a given vendor contract.
   * 
   * Expected answers:
   *   code 200 : DeleteByNumericIdApiResponse (Monitoring schedule has been deleted successfully.)
   *   code 404 : ApiErrorResponse (Specified monitoring schedule does not exist.)
   *   code 503 : ApiErrorResponse (Monitoring schedule could not be deleted due to an internal server error.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param scheduleId ID of a monitoring schedule
   */
  def deleteMonitoringScheduleVendorV3(contractId: String, scheduleId: Int)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[DeleteByNumericIdApiResponse] =
{
    var r = basicRequest
      .method(Method.DELETE, uri"$baseUrl/api/v3/vendor/contracts/${contractId}/settings/monitoringschedules/${scheduleId}")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[DeleteByNumericIdApiResponse])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param updatedMax 
   */
  def deleteProductsManufacturerV3(contractId: String, updatedMax: Option[OffsetDateTime] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.DELETE, uri"$baseUrl/api/v3/manufacturer/contracts/${contractId}/products?updatedMax=$updatedMax")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : Any (Delete all strategy versions per provided contract)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   */
  def deleteRepricingStrategyVendorV2(contractId: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.DELETE, uri"$baseUrl/api/2/v/contracts/${contractId}/settings/repricingstrategy")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * Remove the specified role from the given user.
   * 
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param userId 
   * @param roleName 
   */
  def deleteUserRole(userId: Long, roleName: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.DELETE, uri"$baseUrl/api/2/users/${userId}/role/${roleName}")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * Delete a vendor and associated shops for a given manufacturer contract.
   * 
   * Expected answers:
   *   code 200 : DeleteByNumericIdApiResponse (A vendor and associated shops have been deleted successfully.)
   *   code 404 : ApiErrorResponse (Specified vendor does not exist.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param vendorId ID of vendor shop mapping
   */
  def deleteVendorShopMappingManufacturerV3(contractId: String, vendorId: Long)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[DeleteByNumericIdApiResponse] =
{
    var r = basicRequest
      .method(Method.DELETE, uri"$baseUrl/api/v3/manufacturer/contracts/${contractId}/vendors/${vendorId}")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[DeleteByNumericIdApiResponse])
}

  /**
   * Trigger a monitoring pipeline task for a manufacturer for a configured monitoring schedule.
   * 
   * Expected answers:
   *   code 200 : EmptyApiResponse (Monitoring task was successfully created and is executing)
   *   code 404 : ApiErrorResponse (Couldn't find any monitoring schedules for given schedule id. No monitoring task was created)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param scheduleId ID of a monitoring schedule
   * @param triggerFollowUpTask 
   */
  def executeMonitoringScheduleManufacturerV3(contractId: String, scheduleId: Int, triggerFollowUpTask: Option[Boolean] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[EmptyApiResponse] =
{
    var r = basicRequest
      .method(Method.POST, uri"$baseUrl/api/v3/manufacturer/contracts/${contractId}/settings/monitoringschedules/${scheduleId}/execute?triggerFollowUpTask=$triggerFollowUpTask")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[EmptyApiResponse])
}

  /**
   * Trigger a monitoring pipeline task for a vendor for a configured monitoring schedule.
   * 
   * Expected answers:
   *   code 200 : EmptyApiResponse (Monitoring task was successfully created and is executing)
   *   code 404 : ApiErrorResponse (Couldn't find any monitoring schedules for given schedule id. No monitoring task was created)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param scheduleId ID of a monitoring schedule
   * @param triggerFollowUpTask 
   */
  def executeMonitoringScheduleVendorV3(contractId: String, scheduleId: Int, triggerFollowUpTask: Option[Boolean] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[EmptyApiResponse] =
{
    var r = basicRequest
      .method(Method.POST, uri"$baseUrl/api/v3/vendor/contracts/${contractId}/settings/monitoringschedules/${scheduleId}/execute?triggerFollowUpTask=$triggerFollowUpTask")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[EmptyApiResponse])
}

  /**
   * Generates a new complex password for the authenticated user account. The primary use case is for an Omnia 2.0 user to call this operation through the Omnia 2.0 UI with a JWT token to obtain a password for their account that can be used for basic authentication to directly call other API endpoints. 
   * 
   * Expected answers:
   *   code 200 : GeneratePasswordResponseV3ApiResponse (The new password information.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   */
  def generateAccountPasswordV3()(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[GeneratePasswordResponseV3ApiResponse] =
{
    var r = basicRequest
      .method(Method.POST, uri"$baseUrl/api/v3/account/password/generate")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[GeneratePasswordResponseV3ApiResponse])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   */
  def getActiveEbayTokenVendorV2(contractId: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/2/v/contracts/${contractId}/settings/ebay/token")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   */
  def getAlertSettings(contractId: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/1/${contractId}/settings/alerts")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : Seq[AdminCompanyV2] (A list of companies was loaded)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param start Start of the pagination
   * @param limit Number of elements per page
   */
  def getAllCompanies(start: Option[Int] = None, limit: Option[Int] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Seq[AdminCompanyV2]] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/controlpanel/api/companies?start=$start&limit=$limit")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Seq[AdminCompanyV2]])
}

  /**
   * Expected answers:
   *   code 200 :  (A list of contracts was loaded)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   */
  def getAllContracts()(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Unit] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/controlpanel/api/contracts")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Unit])
}

  /**
   * Add a new domain.
   * 
   * Expected answers:
   *   code 200 : PostAdminAddDomainV3ApiResponse (A new domain was added)
   *   code 400 : ApiErrorResponse (- Offer sources must be valid and non-empty - Domain must be a valid internet domain and non-empty - Domain name must be unique and non-empty - Please refer to the request schema for what constitutes valid offer sources and a valid domain )
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param postAdminAddDomainBodyV3 The domain to be added and its offer sources
   */
  def getAllDomainsControlPanelV3(postAdminAddDomainBodyV3: Option[PostAdminAddDomainBodyV3] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[PostAdminAddDomainV3ApiResponse] =
{
    var r = basicRequest
      .method(Method.POST, uri"$baseUrl/controlpanel/api/v3/domains")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(postAdminAddDomainBodyV3)
      r.response(asJson[PostAdminAddDomainV3ApiResponse])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param start 
   * @param limit 
   */
  def getAllEbayAuthorizationsVendorV2(contractId: String, start: Int, limit: Int)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/2/v/contracts/${contractId}/settings/ebay/authorizations?start=$start&limit=$limit")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param start 
   * @param limit 
   */
  def getAllEbayTokensVendorV2(contractId: String, start: Int, limit: Int)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/2/v/contracts/${contractId}/settings/ebay/tokens?start=$start&limit=$limit")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 :  (A list of portals was loaded)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   */
  def getAllPortals()(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Unit] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/controlpanel/api/portals")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Unit])
}

  /**
   * Get a list of all scenario strategy metadata for a contract.
   * 
   * Expected answers:
   *   code 200 : Seq[ScenarioStrategyMetadataResponseApiResponse] (List of all scenario strategy metadata)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   */
  def getAllScenariosMetadata(contractId: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Seq[ScenarioStrategyMetadataResponseApiResponse]] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/v3/vendor/contracts/${contractId}/settings/pricingstrategies/scenarios")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Seq[ScenarioStrategyMetadataResponseApiResponse]])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId 
   * @param taskId 
   * @param taskType 
   * @param taskState 
   * @param limit 
   * @param minCreationDate 
   * @param maxCreationDate 
   */
  def getAllTasks(contractId: Seq[String], taskId: Seq[String], taskType: Seq[String], taskState: Seq[String], limit: Int, minCreationDate: Option[OffsetDateTime] = None, maxCreationDate: Option[OffsetDateTime] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/controlpanel/api/tasks?contractId=$contractId&taskId=$taskId&taskType=$taskType&taskState=$taskState&minCreationDate=$minCreationDate&maxCreationDate=$maxCreationDate&limit=$limit")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 :  (A list of users was loaded)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   */
  def getAllUsers()(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Unit] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/controlpanel/api/users")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Unit])
}

  /**
   * Get OAuth authorization status for customer's Amazon seller central account. For setting up OAuth authorization, have a look at the endpoint POST /api/v3/companies/{companyId}/amazon/authorization. 
   * 
   * Expected answers:
   *   code 200 : GetAuthorizationStatusResponseV3ApiResponse (Authorization status of a customer on Amazon.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param companyId ID of a company
   */
  def getAuthorizationStatusVendorV3(companyId: Long)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[GetAuthorizationStatusResponseV3ApiResponse] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/v3/companies/${companyId}/amazon/authorization/status")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[GetAuthorizationStatusResponseV3ApiResponse])
}

  /**
   * Expected answers:
   *   code 200 : Callbacks (-)
   *   code 404 :  (Settings for this contract don't exist yet)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   */
  def getCallbacks(contractId: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Callbacks] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/2/m/contracts/${contractId}/settings/callbacks")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Callbacks])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param session 
   * @param includeDeliveryCosts 
   * @param tagFilteredVendorsRequest This is a generated entry and needs to be described.
   */
  def getCheapestVendorsManufacturerV2(contractId: String, session: OffsetDateTime, includeDeliveryCosts: Boolean, tagFilteredVendorsRequest: Option[TagFilteredVendorsRequest] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.POST, uri"$baseUrl/api/2/m/contracts/${contractId}/result/vendors/cheapest?session=$session&includeDeliveryCosts=$includeDeliveryCosts")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(tagFilteredVendorsRequest)
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param companyId ID of a company
   */
  def getCompany(companyId: Long)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/controlpanel/api/companies/${companyId}")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : OfferFilterApiResponse (List of the filters to ignore the individual offers.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param listType 
   */
  def getComplexOfferFiltersVendorV2(contractId: String, listType: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[OfferFilterApiResponse] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/2/v/contracts/${contractId}/offerfilters/${listType}/complex")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[OfferFilterApiResponse])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param maxCreationDate 
   * @param minExpirationDate 
   */
  def getContractsVendorV2(maxCreationDate: Option[OffsetDateTime] = None, minExpirationDate: Option[OffsetDateTime] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/2/v/contracts?maxCreationDate=$maxCreationDate&minExpirationDate=$minExpirationDate")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   */
  def getCurrencyVendorV2(contractId: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/2/v/contracts/${contractId}/settings/currency")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : GetCustomerContractSettingsApiResponse (Settings for this contract.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   */
  def getCustomerContractSettingsManufaturerV3(contractId: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[GetCustomerContractSettingsApiResponse] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/v3/manufacturer/contracts/${contractId}/settings/customer")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[GetCustomerContractSettingsApiResponse])
}

  /**
   * Expected answers:
   *   code 200 : GetCustomerContractSettingsApiResponse (Settings for this contract.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   */
  def getCustomerContractSettingsVendorV3(contractId: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[GetCustomerContractSettingsApiResponse] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/v3/vendor/contracts/${contractId}/settings/customer")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[GetCustomerContractSettingsApiResponse])
}

  /**
   * Expected answers:
   *   code 200 : StringArrayResponse (A list of configured domains is returned.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   */
  def getDomainsVendorV2(contractId: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[StringArrayResponse] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/2/v/contracts/${contractId}/settings/domains")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[StringArrayResponse])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   */
  def getDynamicMonitoringSettings(contractId: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/1/${contractId}/settings/dynamicmonitoring")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param authIds 
   */
  def getEbayAuthorizationsVendorV2(contractId: String, authIds: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/2/v/contracts/${contractId}/settings/ebay/authorizations/${authIds}")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * The GET request is proxied to the internal Export API.
   * 
   * Expected answers:
   *   code 200 : Any (Successful response returned by the Export API.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param path The export path to be called
   */
  def getExportRequestVendorV3(contractId: String, path: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/v3/vendor/contracts/${contractId}/export/${path}")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param productId 
   */
  def getExtendedTagsManufacturerV3(contractId: String, productId: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/v3/manufacturer/contracts/${contractId}/products/${productId}/extendedtags")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param feedId 
   * @param fileName 
   */
  def getFeedExportDeltaVendorV2(contractId: String, feedId: String, fileName: Option[String] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/2/v/contracts/${contractId}/feeds/${feedId}/export/delta?fileName=$fileName")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param feedId 
   * @param fileName 
   */
  def getFeedExportVendorV2(contractId: String, feedId: String, fileName: Option[String] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/2/v/contracts/${contractId}/feeds/${feedId}/export?fileName=$fileName")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * The GET request is proxied to the internal import-export API.
   * 
   * Expected answers:
   *   code 200 : Any (Successful response returned by the import-export API.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param path The import-export path to be called
   */
  def getImportExportRequestVendorV3(contractId: String, path: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/v3/vendor/contracts/${contractId}/import-export/${path}")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * The GET request is proxied to the internal Import API.
   * 
   * Expected answers:
   *   code 200 : Any (Successful response returned by the Import API.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param path The import path to be called
   */
  def getImportRequestVendorV3(contractId: String, path: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/v3/vendor/contracts/${contractId}/import/${path}")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   */
  def getImportSettingsVendorV2(contractId: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/2/v/contracts/${contractId}/settings/import")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * Retrieves user attributes from Looker. We created the endpoint to allow us to track the impact of the issue described in [Confluence](https://omniaretail.atlassian.net/wiki/spaces/DEV/pages/648151090/Looker+Dashboard+Mismatch+Problem+in+Omnia+2.0) 
   * 
   * Expected answers:
   *   code 200 : LookerUserAttributesV3ApiResponse (Looker user attributes.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   */
  def getLookerUserAttributes()(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[LookerUserAttributesV3ApiResponse] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/v3/user/looker/attributes")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[LookerUserAttributesV3ApiResponse])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   */
  def getManufacturerManufacturerV2(contractId: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/2/m/contracts/${contractId}")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : GetManufacturerV3ApiResponse (Contract Information)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   */
  def getManufacturerV3(contractId: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[GetManufacturerV3ApiResponse] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/v3/manufacturer/contracts/${contractId}")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[GetManufacturerV3ApiResponse])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param inputType 
   * @param identifiers 
   */
  def getMappingsVendorV2(contractId: String, inputType: String, identifiers: Seq[String])(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/2/v/contracts/${contractId}/productidentifiermapping?inputType=$inputType&identifiers=$identifiers")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * Get marketplace activation status of a customer in our system. 
   * 
   * Expected answers:
   *   code 200 : ActivateMarketplaceResponseV3ApiResponse (Marketplace activation status.)
   *   code 400 : ApiErrorResponse (- Specified marketplace already activated. - Invalid marketplace country code is specified. - Given company is not registered with our system. One must register his seller central account with our system. )
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param marketplaceCountryCode Marketplace country code. You can view complete list here. https://developer-docs.amazon.com/sp-api/docs/marketplace-ids. Currently, only Europe as a region is supported.
   * @param companyId ID of a company
   * @param contractId ID of the contract
   */
  def getMarketplaceActivationStatus(marketplaceCountryCode: String, companyId: Long, contractId: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[ActivateMarketplaceResponseV3ApiResponse] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/v3/companies/${companyId}/amazon/marketplace/${marketplaceCountryCode}/contracts/${contractId}")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[ActivateMarketplaceResponseV3ApiResponse])
}

  /**
   * Get all the monitoring schedules for a specified manufacturer contract.
   * 
   * Expected answers:
   *   code 200 : GetMonitoringSchedulesApiResponse (List of monitoring schedules.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   */
  def getMonitoringSchedulesManufacturerV3(contractId: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[GetMonitoringSchedulesApiResponse] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/v3/manufacturer/contracts/${contractId}/settings/monitoringschedules")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[GetMonitoringSchedulesApiResponse])
}

  /**
   * Get all the monitoring schedules for a specified vendor contract.
   * 
   * Expected answers:
   *   code 200 : GetMonitoringSchedulesApiResponse (List of monitoring schedules.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   */
  def getMonitoringSchedulesVendorV3(contractId: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[GetMonitoringSchedulesApiResponse] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/v3/vendor/contracts/${contractId}/settings/monitoringschedules")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[GetMonitoringSchedulesApiResponse])
}

  /**
   * Get the current monitoring settings for a given contract
   * 
   * Expected answers:
   *   code 200 : Any (The current monitoring settings object)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   */
  def getMonitoringSettingsManufacturerV2(contractId: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/2/m/contracts/${contractId}/settings/monitoring")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   */
  def getMonitoringSettingsManufacturerV3(contractId: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/v3/manufacturer/contracts/${contractId}/settings/monitoring")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   */
  def getMonitoringSettingsVendorV2(contractId: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/2/v/contracts/${contractId}/settings/monitoring")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   */
  def getMonitoringSettingsVendorV3(contractId: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/v3/vendor/contracts/${contractId}/settings/monitoring")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * Get all the vendor filters for the given contract.
   * 
   * Expected answers:
   *   code 200 : Any (List of the filters to ignore the individual offers. Offers are filtered against vendor name either for all the domain or for a specific domain.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param listType 
   */
  def getOfferFiltersVendorV2(contractId: String, listType: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/2/v/contracts/${contractId}/offerfilters/${listType}/vendors")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param contractType 
   */
  def getOfferRetentionSettingsManufacturerV3(contractId: String, contractType: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/v3/manufacturer/contracts/${contractId}/settings/offerretention?contractType=$contractType")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param contractType 
   */
  def getOfferRetentionSettingsVendorV3(contractId: String, contractType: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/v3/vendor/contracts/${contractId}/settings/offerretention?contractType=$contractType")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * Get offer statistics per product of a contract. Only the latest offers per product and domain the are taken into account.
   * 
   * Expected answers:
   *   code 200 : GetOfferStatisticsV3ApiResponse (Returns a list of offer statistics per product.)
   *   code 400 : ApiError (Specified time range is invalid (> 48h).)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param includeDeliveryCosts 
   * @param startDate Timestamp of start of time range, formatted as ISO Date (i.e. 2018-04-06T13:46:13Z) in UTC. If this value is omitted and {endDate} is given, {startDate} is set to {endDate} - 48 hours. If both values are omitted, the range is 'NOW - 48 hours to NOW'.
   * @param endDate Timestamp of end of time range, formatted as ISO Date (i.e. 2018-04-06T13:46:13Z) in UTC. If this value is omitted and {startDate} is given, {endDate} is set to {startDate} + 48 hours. If both values are omitted, the range is 'NOW - 48 hours to NOW'.
   */
  def getOfferStatisticsManufacturerV3(contractId: String, includeDeliveryCosts: Boolean, startDate: Option[OffsetDateTime] = None, endDate: Option[OffsetDateTime] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[GetOfferStatisticsV3ApiResponse] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/v3/manufacturer/contracts/${contractId}/offers/stats?startDate=$startDate&endDate=$endDate&includeDeliveryCosts=$includeDeliveryCosts")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[GetOfferStatisticsV3ApiResponse])
}

  /**
   * Expected answers:
   *   code 200 : GetOffersResponse (No response was specified)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param start Start product index for pagination
   * @param limit Number of products for pagination
   * @param startDate Timestamp of start of time range, formatted as ISO Date (i.e. 2018-04-06T13:46:13Z) in UTC. If this value is omitted and {endDate} is given, {startDate} is set to {endDate} - 48 hours. If both values are omitted, the range is 'NOW - 48 hours to NOW'.
   * @param endDate Timestamp of end of time range, formatted as ISO Date (i.e. 2018-04-06T13:46:13Z) in UTC. If this value is omitted and {startDate} is given, {endDate} is set to {startDate} + 48 hours. If both values are omitted, the range is 'NOW - 48 hours to NOW'.
   */
  def getOffers(contractId: String, start: Int, limit: Int, startDate: Option[OffsetDateTime] = None, endDate: Option[OffsetDateTime] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[GetOffersResponse] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/2/v/contracts/${contractId}/result/offers?start=$start&limit=$limit&startDate=$startDate&endDate=$endDate")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[GetOffersResponse])
}

  /**
   * Returns all shops which have at least one offer for a given time range per domain.
   * 
   * Expected answers:
   *   code 200 : GetShopsByDomainResponseV3ApiResponse (Shops which have at least one offer for a given time range per domain.)
   *   code 400 : ApiError (Specified time range is invalid (> 7 days).)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param startDate Timestamp of start of time range, formatted as ISO Date (i.e. 2018-04-06T13:46:13Z) in UTC. If this value is omitted and {endDate} is given, {startDate} is set to {endDate} - 48 hours. If both values are omitted, the range is 'NOW - 48 hours to NOW'. The time range may not exceed 1 week.
   * @param endDate Timestamp of end of time range, formatted as ISO Date (i.e. 2018-04-06T13:46:13Z) in UTC. If this value is omitted and {startDate} is given, {endDate} is set to {startDate} + 48 hours. If both values are omitted, the range is 'NOW - 48 hours to NOW'. The time range may not exceed 1 week.
   */
  def getOffersShopsManufacturerV3(contractId: String, startDate: Option[OffsetDateTime] = None, endDate: Option[OffsetDateTime] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[GetShopsByDomainResponseV3ApiResponse] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/v3/manufacturer/contracts/${contractId}/offers/shops?startDate=$startDate&endDate=$endDate")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[GetShopsByDomainResponseV3ApiResponse])
}

  /**
   * Returns all shops which have at least one offer for a given time range per domain.
   * 
   * Expected answers:
   *   code 200 : GetShopsByDomainResponseV3ApiResponse (Shops which have at least one offer for a given time range per domain.)
   *   code 400 : ApiError (Specified time range is invalid (> 7 days).)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param startDate Timestamp of start of time range, formatted as ISO Date (i.e. 2018-04-06T13:46:13Z) in UTC. If this value is omitted and {endDate} is given, {startDate} is set to {endDate} - 48 hours. If both values are omitted, the range is 'NOW - 48 hours to NOW'. The time range may not exceed 1 week.
   * @param endDate Timestamp of end of time range, formatted as ISO Date (i.e. 2018-04-06T13:46:13Z) in UTC. If this value is omitted and {startDate} is given, {endDate} is set to {startDate} + 48 hours. If both values are omitted, the range is 'NOW - 48 hours to NOW'. The time range may not exceed 1 week.
   */
  def getOffersShopsVendorV3(contractId: String, startDate: Option[OffsetDateTime] = None, endDate: Option[OffsetDateTime] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[GetShopsByDomainResponseV3ApiResponse] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/v3/vendor/contracts/${contractId}/offers/shops?startDate=$startDate&endDate=$endDate")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[GetShopsByDomainResponseV3ApiResponse])
}

  /**
   * Get the number of orders by portal for the given contract.
   * 
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   */
  def getOrdersCountByPortalByContract(contractId: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/1/${contractId}/products/orderscountbyportal")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param session 
   * @param limit 
   * @param includeDeliveryCosts 
   * @param body This is a generated entry and needs to be described.
   */
  def getPriceCuttersManufacturerV2(contractId: String, session: OffsetDateTime, limit: Int, includeDeliveryCosts: Boolean, body: Option[Any] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.POST, uri"$baseUrl/api/2/m/contracts/${contractId}/result/pricecutters?session=$session&limit=$limit&includeDeliveryCosts=$includeDeliveryCosts")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(body)
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param session 
   * @param limit 
   * @param includeDeliveryCosts 
   * @param body This is a generated entry and needs to be described.
   */
  def getPriceCuttersVendorV2(contractId: String, session: OffsetDateTime, limit: Int, includeDeliveryCosts: Boolean, body: Option[Any] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.POST, uri"$baseUrl/api/2/v/contracts/${contractId}/result/pricecutters?session=$session&limit=$limit&includeDeliveryCosts=$includeDeliveryCosts")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(body)
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param startTime 
   * @param endTime 
   * @param maxPositions 
   */
  def getPriceRecommendationStatsVendorV2(contractId: String, startTime: OffsetDateTime, endTime: OffsetDateTime, maxPositions: Int)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/2/v/contracts/${contractId}/result/pricerecommendationstats?startTime=$startTime&endTime=$endTime&maxPositions=$maxPositions")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param body This is a generated entry and needs to be described.
   */
  def getProductFiltersByIDVendorV2(contractId: String, body: Option[Any] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.POST, uri"$baseUrl/api/2/v/contracts/${contractId}/offerfilters/:listType/products/query")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(body)
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : Any (List of the filters per product to ignore the individual offers.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param listType 
   * @param start 
   * @param limit 
   */
  def getProductFiltersByRangeVendorV2(contractId: String, listType: String, start: Int, limit: Int)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/2/v/contracts/${contractId}/offerfilters/${listType}/products?start=$start&limit=$limit")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : OfferFilterApiResponse (List of the filters to ignore the individual offers.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param listType 
   * @param productId 
   */
  def getProductFiltersVendorV2(contractId: String, listType: String, productId: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[OfferFilterApiResponse] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/2/v/contracts/${contractId}/offerfilters/${listType}/products/${productId}")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[OfferFilterApiResponse])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param start 
   * @param end 
   */
  def getProductMetricsByContract(contractId: String, start: OffsetDateTime, end: OffsetDateTime)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/1/${contractId}/products/articlescountbyportal?start=$start&end=$end")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : GetProductMonitoringStatusStatsVendorV3ApiResponse (Contains the monitoring status stats per domain)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   */
  def getProductMonitoringStatusStatsVendorV3(contractId: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[GetProductMonitoringStatusStatsVendorV3ApiResponse] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/v3/vendor/contracts/${contractId}/products/monitoringstatus/stats")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[GetProductMonitoringStatusStatsVendorV3ApiResponse])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param start 
   * @param end 
   * @param includeDeliveryCosts 
   * @param referencePriceDelta 
   */
  def getProductPriceViolationsManufacturerV2(contractId: String, start: OffsetDateTime, end: OffsetDateTime, includeDeliveryCosts: Boolean, referencePriceDelta: Double)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/2/m/contracts/${contractId}/result/priceviolations?start=$start&end=$end&includeDeliveryCosts=$includeDeliveryCosts&referencePriceDelta=$referencePriceDelta")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param start 
   * @param end 
   * @param includeDeliveryCosts 
   * @param referencePriceDelta 
   */
  def getProductPriceViolationsVendorV2(contractId: String, start: OffsetDateTime, end: OffsetDateTime, includeDeliveryCosts: Boolean, referencePriceDelta: Double)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/2/v/contracts/${contractId}/result/priceviolations?start=$start&end=$end&includeDeliveryCosts=$includeDeliveryCosts&referencePriceDelta=$referencePriceDelta")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * This endpoint returns a list product properties for a certain product and contract. Product properties represent additional information for a product, independent of the imported products and tags.
   * 
   * Expected answers:
   *   code 200 : GetProductPropertiesV3ApiResponse (A list of product properties)
   *   code 404 : ApiErrorResponse (Returned if the product does not exist.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param productId ID of the product (Omnia's internal product id)
   */
  def getProductPropertiesV3(contractId: String, productId: Long)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[GetProductPropertiesV3ApiResponse] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/v3/vendor/contracts/${contractId}/products/${productId}/properties")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[GetProductPropertiesV3ApiResponse])
}

  /**
   * This endpoint returns a list of distinct product property keys for all imported products of a contract.
   * 
   * Expected answers:
   *   code 200 : StringArrayResponse (A list of distinct keys of all product properties.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   */
  def getProductPropertyKeysV3(contractId: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[StringArrayResponse] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/v3/vendor/contracts/${contractId}/products/properties/keys")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[StringArrayResponse])
}

  /**
   * Expected answers:
   *   code 200 : Any (In case a document version is provided, get that strategy version. Otherwise get latest strategy for this contract.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param documentVersion 
   */
  def getRepricingStrategyVendorV2(contractId: String, documentVersion: Option[Int] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/2/v/contracts/${contractId}/settings/repricingstrategy?documentVersion=$documentVersion")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * Get a scenario strategy with the provided scenario id.
   * 
   * Expected answers:
   *   code 200 : ScenarioStrategyResponse (A scenario strategy)
   *   code 404 : ApiErrorResponse (Scenario strategy with the provided Id was not found.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param scenarioId ID of the required scenario strategy
   */
  def getScenarioById(contractId: String, scenarioId: Int)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[ScenarioStrategyResponse] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/v3/vendor/contracts/${contractId}/settings/pricingstrategies/scenarios/${scenarioId}")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[ScenarioStrategyResponse])
}

  /**
   * Expected answers:
   *   code 200 : GetContractSettingsResponseV1 (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   */
  def getSettings(contractId: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[GetContractSettingsResponseV1] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/1/${contractId}/settings")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[GetContractSettingsResponseV1])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param key 
   */
  def getTagValuesManufacturerV2(contractId: String, key: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/2/m/contracts/${contractId}/products/tags/${key}")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param key 
   */
  def getTagValuesVendorV2(contractId: String, key: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/2/v/contracts/${contractId}/products/tags/${key}")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   */
  def getTagsManufacturerV2(contractId: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/2/m/contracts/${contractId}/products/tags")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   */
  def getTagsVendorV2(contractId: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/2/v/contracts/${contractId}/products/tags")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * Get a task by id
   * 
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param taskId 
   */
  def getTask(contractId: String, taskId: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/1/${contractId}/tasks/${taskId}")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : Any (The payload data of the requested task is returned)
   *   code 404 :  (The task with the given ID could not be found)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param taskId 
   */
  def getTaskDataManufacturerV2(contractId: String, taskId: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/2/m/contracts/${contractId}/tasks/${taskId}/data")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param taskId 
   */
  def getTaskDataVendorV2(contractId: String, taskId: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/2/v/contracts/${contractId}/tasks/${taskId}/data")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * Get the task with the specified id.
   * 
   * Expected answers:
   *   code 200 : GenericTask (The task was found and is returned)
   *   code 404 :  (No task with given taskId was found)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param taskId 
   */
  def getTaskManufacturerV2(contractId: String, taskId: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[GenericTask] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/2/m/contracts/${contractId}/tasks/${taskId}")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[GenericTask])
}

  /**
   * Gets the state of a task.
   * 
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param taskId 
   */
  def getTaskState(contractId: String, taskId: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/1/${contractId}/tasks/${taskId}/state")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param tasks 
   * @param attributes 
   * @param limit 
   * @param taskType 
   */
  def getTasks(contractId: String, tasks: String, attributes: String, limit: Int, taskType: Option[String] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/1/${contractId}/tasks?tasks=$tasks&attributes=$attributes&limit=$limit&taskType=$taskType")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * Returns a list of task objects for the given contract
   * 
   * Expected answers:
   *   code 200 : Seq[GenericTask] (The list of tasks for the given contract)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param taskTypeFilter A list of task types to filter for
   * @param taskState A list of task states to filter for
   * @param limit The maximum number of tasks returned
   * @param includeFailures Include failed tasks
   * @param taskIdsFilter Comma separated list of task IDs to filter for
   * @param minCreationDate Ignore all tasks created earlier than this date (ISO 8601)
   * @param maxCreationDate Ignore all tasks created later than this date (ISO 8601)
   */
  def getTasksManufacturerV2(contractId: String, taskTypeFilter: Seq[String], taskState: Seq[String], limit: Int, includeFailures: Boolean, taskIdsFilter: Option[String] = None, minCreationDate: Option[OffsetDateTime] = None, maxCreationDate: Option[OffsetDateTime] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Seq[GenericTask]] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/2/m/contracts/${contractId}/tasks?taskIdsFilter=$taskIdsFilter&taskTypeFilter=$taskTypeFilter&taskState=$taskState&minCreationDate=$minCreationDate&maxCreationDate=$maxCreationDate&limit=$limit&includeFailures=$includeFailures")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Seq[GenericTask]])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param sinceSeconds 
   */
  def getTasksStats(sinceSeconds: Int)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/controlpanel/api/tasks/stats?sinceSeconds=$sinceSeconds")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId 
   */
  def getTimeStamps(contractId: Long)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/1/${contractId}/products/analysis/timestamps")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * Get the user with the specified email address.
   * 
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param email 
   */
  def getUser(email: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/controlpanel/api/users/${email}")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * Get which user can access which contract of the company. 
   * 
   * Expected answers:
   *   code 200 : GetUserAccessToContractsOfCompanyV3ApiResponse (All users and their accessible contracts)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param companyId ID of a company
   */
  def getUserAccessToContractsOfCompanyV3(companyId: Long)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[GetUserAccessToContractsOfCompanyV3ApiResponse] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/v3/companies/${companyId}/users/contractaccess")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[GetUserAccessToContractsOfCompanyV3ApiResponse])
}

  /**
   * This endpoint returns all users that are assigned to a company. It is only accessible for admins or company admins.
   * 
   * Expected answers:
   *   code 200 : Seq[GetCompanyUsersUser] (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param companyId ID of a company
   */
  def getUsers(companyId: Long)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Seq[GetCompanyUsersUser]] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/controlpanel/api/companies/${companyId}/users")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Seq[GetCompanyUsersUser]])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   */
  def getVendorSettingsV2VendorV2(contractId: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/2/v/contracts/${contractId}/settings/repricing")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * Get vendor along with their associated shop for given vendor id and manufacturer contract.
   * 
   * Expected answers:
   *   code 200 : VendorShopMappingV3ApiResponse (Get vendor along with their associated shop for given vendor id and contract.)
   *   code 404 : ApiErrorResponse (Vendor doesn't exist for given vendor id.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param vendorId ID of vendor shop mapping
   */
  def getVendorShopMappingManufacturerV3(contractId: String, vendorId: Long)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[VendorShopMappingV3ApiResponse] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/v3/manufacturer/contracts/${contractId}/vendors/${vendorId}")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[VendorShopMappingV3ApiResponse])
}

  /**
   * Get all the vendors along with their associated shops for a specified manufacturer contract.
   * 
   * Expected answers:
   *   code 200 : GetVendorShopMappingsApiResponse (List of vendors along with their associated shops.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   */
  def getVendorShopMappingsManufacturerV3(contractId: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[GetVendorShopMappingsApiResponse] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/v3/manufacturer/contracts/${contractId}/vendors")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[GetVendorShopMappingsApiResponse])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   */
  def getVendorV3(contractId: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/v3/vendor/contracts/${contractId}")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   */
  def getVendorVendorV2(contractId: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/2/v/contracts/${contractId}")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : PostVendorsByDomainResponse (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param domain 
   * @param start 
   * @param includeDeliveryCosts 
   * @param session 
   * @param tagFilteredVendorsRequest This is a generated entry and needs to be described.
   */
  def getVendorsByDomainManufacturerV2(contractId: String, domain: String, start: Int, includeDeliveryCosts: Boolean, session: OffsetDateTime, tagFilteredVendorsRequest: Option[TagFilteredVendorsRequest] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[PostVendorsByDomainResponse] =
{
    var r = basicRequest
      .method(Method.POST, uri"$baseUrl/api/2/m/contracts/${contractId}/result/vendors/list?domain=$domain&start=$start&includeDeliveryCosts=$includeDeliveryCosts&session=$session")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(tagFilteredVendorsRequest)
      r.response(asJson[PostVendorsByDomainResponse])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param nameFilter 
   */
  def listVendors(nameFilter: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/controlpanel/vendors?nameFilter=$nameFilter")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * @param token 
   */
  def loginByAuthToken(token: String): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/login/token/${token}")
      .contentType("application/json")
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : Any (Deauthenticate with the API and destroy the current session.)
   */
  def logout(): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.POST, uri"$baseUrl/logout")
      .contentType("application/json")
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param path The monitoring-pipeline path to be called
   */
  def monitoringPipelinePostRequestManufacturerV3(contractId: String, path: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.POST, uri"$baseUrl/api/v3/manufacturer/contracts/${contractId}/monitoringpipeline/${path}")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param path The monitoring-pipeline path to be called
   */
  def monitoringPipelinePostRequestVendorV3(contractId: String, path: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.POST, uri"$baseUrl/api/v3/vendor/contracts/${contractId}/monitoringpipeline/${path}")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param body This is a generated entry and needs to be described.
   */
  def monitoringPipelineUpsertSearchAttemptsManufacturerV3(contractId: String, body: Option[Any] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.POST, uri"$baseUrl/api/v3/manufacturer/contracts/${contractId}/monitoringpipeline/v1/searchattempts")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(body)
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param body This is a generated entry and needs to be described.
   */
  def monitoringPipelineUpsertSearchAttemptsVendorV3(contractId: String, body: Option[Any] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.POST, uri"$baseUrl/api/v3/vendor/contracts/${contractId}/monitoringpipeline/v1/searchattempts")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(body)
      r.response(asJson[Any])
}

  /**
   * The PATCH request is proxied to the internal export API.
   * 
   * Expected answers:
   *   code 200 : Any (Successful response returned by the Export API.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param path The export path to be called
   */
  def patchExportRequestVendorV3(contractId: String, path: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.PATCH, uri"$baseUrl/api/v3/vendor/contracts/${contractId}/export/${path}")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * The PATCH request is proxied to the internal import-export API.
   * 
   * Expected answers:
   *   code 200 : Any (Successful response returned by the import-export API.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param path The import-export path to be called
   */
  def patchImportExportRequestVendorV3(contractId: String, path: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.PATCH, uri"$baseUrl/api/v3/vendor/contracts/${contractId}/import-export/${path}")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * The PATCH request is proxied to the internal import API.
   * 
   * Expected answers:
   *   code 200 : Any (Successful response returned by the Import API.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param path The import path to be called
   */
  def patchImportRequestVendorV3(contractId: String, path: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.PATCH, uri"$baseUrl/api/v3/vendor/contracts/${contractId}/import/${path}")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param productId 
   * @param body This is a generated entry and needs to be described.
   */
  def patchProductManufacturerV3(contractId: String, productId: String, body: Option[Any] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.PATCH, uri"$baseUrl/api/v3/manufacturer/contracts/${contractId}/products/${productId}")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(body)
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param productId 
   * @param body This is a generated entry and needs to be described.
   */
  def patchProductVendorV3(contractId: String, productId: String, body: Option[Any] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.PATCH, uri"$baseUrl/api/v3/vendor/contracts/${contractId}/products/${productId}")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(body)
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param vendor 
   * @param day 
   * @param body This is a generated entry and needs to be described.
   */
  def positionDistribution(contractId: String, vendor: String, day: OffsetDateTime, body: Option[Any] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.POST, uri"$baseUrl/api/1/${contractId}/vendors/${vendor}/positions?day=$day")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(body)
      r.response(asJson[Any])
}

  /**
   * Create a new user account.
   * 
   * Expected answers:
   *   code 200 : PostAccountResponseV3ApiResponse (The account information of the newly created account.)
   *   code 400 : ApiErrorResponse (Returned if: - The Request body is not a valid JSON string - The user account name is empty - The email doesn't match a valid email format - The password length is less than 6 characters long - The endpoint was requested too often - The given email address already exists )
   * 
   * @param postAccountRequestV3 Request body for creating a new user account. It must contain name, email and password.
   */
  def postAccountV3(postAccountRequestV3: Option[PostAccountRequestV3] = None): ApiRequestT[PostAccountResponseV3ApiResponse] =
{
    var r = basicRequest
      .method(Method.POST, uri"$baseUrl/api/v3/account")
      .contentType("application/json")
      r=r.body(postAccountRequestV3)
      r.response(asJson[PostAccountResponseV3ApiResponse])
}

  /**
   * Activate marketplace of a customer in our system. By activation, it means that our system can write prices back into the customer's Amazon shop. 
   * 
   * Expected answers:
   *   code 200 : ActivateMarketplaceResponseV3ApiResponse (Successfully activated marketplace of a customer in our system.)
   *   code 400 : ApiErrorResponse (- Specified marketplace already activated. - Invalid marketplace country code is specified. - Given company is not registered with our system. One must register his seller central account with our system. )
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param companyId ID of a company
   * @param postActivateMarketplaceRequestV3 Marketplace of a customer to be activated.
   */
  def postActivateMarketplaceVendorV3(companyId: Long, postActivateMarketplaceRequestV3: Option[PostActivateMarketplaceRequestV3] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[ActivateMarketplaceResponseV3ApiResponse] =
{
    var r = basicRequest
      .method(Method.POST, uri"$baseUrl/api/v3/companies/${companyId}/amazon/marketplace")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(postActivateMarketplaceRequestV3)
      r.response(asJson[ActivateMarketplaceResponseV3ApiResponse])
}

  /**
   * Set up an OAuth authorization for a customer's Amazon Seller Central account. It establishes a connection between our system and the customer's Amazon shop using the Amazon SP-API. Once connected, our system can write prices back to the customer's Amazon shop, allowing them to benefit from our price recommendations. 
   * 
   * Expected answers:
   *   code 200 : PostAuthorizeSellerResponseV3ApiResponse (Successfully authorized customer's Amazon seller central account.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param companyId ID of a company
   * @param postAuthorizeSellerRequestV3 Customer's Amazon seller central account to be authorized.
   */
  def postAuthorizeSellerVendorV3(companyId: Long, postAuthorizeSellerRequestV3: Option[PostAuthorizeSellerRequestV3] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[PostAuthorizeSellerResponseV3ApiResponse] =
{
    var r = basicRequest
      .method(Method.POST, uri"$baseUrl/api/v3/companies/${companyId}/amazon/authorization")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(postAuthorizeSellerRequestV3)
      r.response(asJson[PostAuthorizeSellerResponseV3ApiResponse])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param body This is a generated entry and needs to be described.
   */
  def postEbayAuthorizationVendorV2(contractId: String, body: Option[Any] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.POST, uri"$baseUrl/api/2/v/contracts/${contractId}/settings/ebay/authorizations")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(body)
      r.response(asJson[Any])
}

  /**
   * Returns a signed Looker SSO URL for embedding a dashboard for a contract. The target dashboard must be whitelisted.
   * 
   * Expected answers:
   *   code 200 : EmbedSSOUrlResponseV3ApiResponse (Signed Looker SSO embed URL.)
   *   code 400 : ApiErrorResponse (- Invalid Looker URL - Dashboard ID is not allowed - Looker API returns client error )
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param postEmbedSSOUrlRequestV3 Payload for retrieving a signed embed SSO url using Looker API.
   */
  def postEmbedSSOUrlManufacturer(contractId: String, postEmbedSSOUrlRequestV3: Option[PostEmbedSSOUrlRequestV3] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[EmbedSSOUrlResponseV3ApiResponse] =
{
    var r = basicRequest
      .method(Method.POST, uri"$baseUrl/api/v3/manufacturer/contracts/${contractId}/looker/sso/embed/url")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(postEmbedSSOUrlRequestV3)
      r.response(asJson[EmbedSSOUrlResponseV3ApiResponse])
}

  /**
   * Returns a signed Looker SSO URL for embedding a dashboard for a contract. The target dashboard must be whitelisted.
   * 
   * Expected answers:
   *   code 200 : EmbedSSOUrlResponseV3ApiResponse (Signed Looker SSO embed URL.)
   *   code 400 : ApiErrorResponse (- Invalid Looker URL - Dashboard ID is not allowed - Looker API returns client error )
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param postEmbedSSOUrlRequestV3 Payload for retrieving a signed embed SSO url using Looker API.
   */
  def postEmbedSSOUrlVendor(contractId: String, postEmbedSSOUrlRequestV3: Option[PostEmbedSSOUrlRequestV3] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[EmbedSSOUrlResponseV3ApiResponse] =
{
    var r = basicRequest
      .method(Method.POST, uri"$baseUrl/api/v3/vendor/contracts/${contractId}/looker/sso/embed/url")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(postEmbedSSOUrlRequestV3)
      r.response(asJson[EmbedSSOUrlResponseV3ApiResponse])
}

  /**
   * The POST request is proxied to the internal Export API.
   * 
   * Expected answers:
   *   code 200 : Any (Successful response returned by the Export API.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param path The export path to be called
   */
  def postExportRequestVendorV3(contractId: String, path: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.POST, uri"$baseUrl/api/v3/vendor/contracts/${contractId}/export/${path}")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param body This is a generated entry and needs to be described.
   */
  def postFeedVendorV2(contractId: String, body: Option[Any] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.POST, uri"$baseUrl/api/2/v/contracts/${contractId}/feeds")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(body)
      r.response(asJson[Any])
}

  /**
   * The POST request is proxied to the internal import-export API.
   * 
   * Expected answers:
   *   code 200 : Any (Successful response returned by the import-export API.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param path The import-export path to be called
   */
  def postImportExportRequestVendorV3(contractId: String, path: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.POST, uri"$baseUrl/api/v3/vendor/contracts/${contractId}/import-export/${path}")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * The POST request is proxied to the internal Import API.
   * 
   * Expected answers:
   *   code 200 : Any (Successful response returned by the Import API.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param path The import path to be called
   */
  def postImportRequestVendorV3(contractId: String, path: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.POST, uri"$baseUrl/api/v3/vendor/contracts/${contractId}/import/${path}")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * Company admin user can invite a user to a company. 
   * 
   * Expected answers:
   *   code 200 : InviteUserToCompanyResponseV3ApiResponse (User is already associated with the given company and hence no invitation is sent.)
   *   code 201 : InviteUserToCompanyResponseV3ApiResponse (Invitation sent and the user is assigned to the company successfully.)
   *   code 400 : ApiErrorResponse (- Invalid email address is provided - Empty name is provided )
   *   code 500 : ApiErrorResponse (Communication with Auth0 service failed.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param companyId ID of a company
   * @param inviteUserToCompanyRequestV3 User information including email & display name.
   */
  def postInviteUserToCompanyV3(companyId: Long, inviteUserToCompanyRequestV3: Option[InviteUserToCompanyRequestV3] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[InviteUserToCompanyResponseV3ApiResponse] =
{
    var r = basicRequest
      .method(Method.POST, uri"$baseUrl/api/v3/companies/${companyId}/users")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(inviteUserToCompanyRequestV3)
      r.response(asJson[InviteUserToCompanyResponseV3ApiResponse])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param body This is a generated entry and needs to be described.
   */
  def postMappingsVendorV2(contractId: String, body: Option[Any] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.POST, uri"$baseUrl/api/2/v/contracts/${contractId}/productidentifiermapping")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(body)
      r.response(asJson[Any])
}

  /**
   * Add a monitoring schedule for a given manufacturer contract.
   * 
   * Expected answers:
   *   code 200 : PutMonitoringSchedulesApiResponse (Monitoring schedule has been created successfully.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param postMonitoringScheduleRequestV3 Request body for creating monitoring schedule.
   */
  def postMonitoringScheduleManufacturerV3(contractId: String, postMonitoringScheduleRequestV3: Option[PostMonitoringScheduleRequestV3] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[PutMonitoringSchedulesApiResponse] =
{
    var r = basicRequest
      .method(Method.POST, uri"$baseUrl/api/v3/manufacturer/contracts/${contractId}/settings/monitoringschedules")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(postMonitoringScheduleRequestV3)
      r.response(asJson[PutMonitoringSchedulesApiResponse])
}

  /**
   * Add a monitoring schedule for a given contract.
   * 
   * Expected answers:
   *   code 200 : PutMonitoringSchedulesApiResponse (Monitoring schedule has been created successfully.)
   *   code 503 : ApiErrorResponse (Monitoring schedule could not be created due to an internal server error.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param postMonitoringScheduleRequestV3 Request body for creating monitoring schedule.
   */
  def postMonitoringScheduleVendorV3(contractId: String, postMonitoringScheduleRequestV3: Option[PostMonitoringScheduleRequestV3] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[PutMonitoringSchedulesApiResponse] =
{
    var r = basicRequest
      .method(Method.POST, uri"$baseUrl/api/v3/vendor/contracts/${contractId}/settings/monitoringschedules")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(postMonitoringScheduleRequestV3)
      r.response(asJson[PutMonitoringSchedulesApiResponse])
}

  /**
   * This operation is used to get offer statistics (e.g. offer count, average price) grouped by product and domain.  Warning: This endpoint contains complex filter structure and will be replaced in the future. Currently, we only allow filtering by a list of internal pricemonitor product ids. Please note that offer statistics can only be computed for at **maximum 2500** products at a time.  To use the example request body from below, you have to adjust the `ownShopNames`, the `range` and `filter.right.value`. Where `filter.right.value` has to be a list of internal pricemonitor product ids corresponding to the `contractId` provided as part of the URL.  All prices will be with or without delivery costs depending on the `includeDeliveryCosts` parameter in the body. 
   * 
   * Expected answers:
   *   code 200 : PostOfferStatisticsApiResponse (Returns a list of offer statistics per product. ## How to use this endpoint's result to get Total Market statistics ### Minimum Price To calculate the minimum price in the total market, you have to take the minimum of the `minPrice` of each domain. In the example below, both products have the same min prices: `min(16.00,7.99) = 7.99`. ### Average Price To calculate the average price in the total market, you have to calculate a **weighted average**, weighing the average price of each domain by its offer count. In the example below we get different results for the average price in the total market for product id `1001` and `1002` even though they have the same average price in each domain. This is due to the different offer counts:    - product id `1001`: `(20.00 * 4 + 10.00 * 12) / (4 + 12) = 12.50`   - product id `1002`: `(20.00 * 12 + 10.00 * 4) / (12 + 4) = 17.50`  ### Offer Count The offer count of one product in the total market is the sum of the offer counts for all its domains. In the example below, both products would have an offer count of `12 + 4 = 16`. ### Market Position The market position of a product generally **can not be deduced** from the data provided in this endpoint. )
   *   code 400 : ApiError (Returned in case of unparsable request body JSON or unsupported filter.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param postOfferStatisticsRequest 
   */
  def postOfferStatisticsVendorQuery(contractId: String, postOfferStatisticsRequest: PostOfferStatisticsRequest)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[PostOfferStatisticsApiResponse] =
{
    var r = basicRequest
      .method(Method.POST, uri"$baseUrl/api/v3/vendor/contracts/${contractId}/offers/stats/query")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(postOfferStatisticsRequest)
      r.response(asJson[PostOfferStatisticsApiResponse])
}

  /**
   * Add a new vendor for a given manufacturer contract and associate shops with the given vendor.
   * 
   * Expected answers:
   *   code 200 : VendorShopMappingV3ApiResponse (Vendor shop mapping has been successfully created.)
   *   code 400 : ApiErrorResponse (The specified vendor name is empty. Or the specified shops are empty.)
   *   code 409 : ApiErrorResponse (The specified vendor name already exists in our system.)
   *   code 422 : ApiErrorResponse (The specified shops do not exist in our system.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param postVendorShopMappingRequestV3 Request body for creating a new vendor and associate shops with it. Please note that atleast one shop is required for a successful creation.
   */
  def postVendorShopMappingManufacturerV3(contractId: String, postVendorShopMappingRequestV3: Option[PostVendorShopMappingRequestV3] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[VendorShopMappingV3ApiResponse] =
{
    var r = basicRequest
      .method(Method.POST, uri"$baseUrl/api/v3/manufacturer/contracts/${contractId}/vendors")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(postVendorShopMappingRequestV3)
      r.response(asJson[VendorShopMappingV3ApiResponse])
}

  /**
   * Expected answers:
   *   code 200 : Seq[PricesByDayByProductIdResponseV2] (The list of all known prices for the queried day & product ID)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param productId The product ID to filter for
   * @param pricesByDayByProductIdRequestV2 Query all known prices for a given day & product ID. Can be filtered by using the selectors.
   */
  def pricesByDayByProductIdManufacturerV2(contractId: String, productId: String, pricesByDayByProductIdRequestV2: Option[PricesByDayByProductIdRequestV2] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Seq[PricesByDayByProductIdResponseV2]] =
{
    var r = basicRequest
      .method(Method.POST, uri"$baseUrl/api/2/m/contracts/${contractId}/result/pricesbyday/productid/${productId}")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(pricesByDayByProductIdRequestV2)
      r.response(asJson[Seq[PricesByDayByProductIdResponseV2]])
}

  /**
   * Publish a preprocessing task for a vendor.
   * 
   * Expected answers:
   *   code 200 : EmptyApiResponse (Preprocessing task created successfully)
   *   code 400 : ApiErrorResponse (- Invalid retrospective value. - No retrospective value is specified. )
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param retrospectiveInMinutes The timespan, in minutes, for considering offers in preprocessing. Allowed value is between 1 and 10080
   * @param contractId ID of the contract
   * @param triggerFollowUpTask 
   */
  def publishPreprocessingTaskVendorV3(retrospectiveInMinutes: Int, contractId: String, triggerFollowUpTask: Option[Boolean] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[EmptyApiResponse] =
{
    var r = basicRequest
      .method(Method.POST, uri"$baseUrl/api/v3/vendor/contracts/${contractId}/tasks/preprocessing?retrospectiveInMinutes=$retrospectiveInMinutes&triggerFollowUpTask=$triggerFollowUpTask")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[EmptyApiResponse])
}

  /**
   * Update an existing domain or add a new domain in case domain does not exist.
   * 
   * Expected answers:
   *   code 201 : PutAdminDomainResponseV3ApiResponse (A domain was updated or added.)
   *   code 400 : ApiErrorResponse (Domain could not be updated or added. - Offer sources must be valid - Domain must be a valid internet domain and non-empty - Domain name must be unique and non-empty - Please refer to the request schema for what constitutes valid offer sources and a valid domain)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param domain Fully qualified domain name
   * @param putAdminDomainRequestV3 The domain to be updated or added and its offer sources
   */
  def putAdminDomainControlPanelV3(domain: String, putAdminDomainRequestV3: Option[PutAdminDomainRequestV3] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[PutAdminDomainResponseV3ApiResponse] =
{
    var r = basicRequest
      .method(Method.PUT, uri"$baseUrl/controlpanel/api/v3/domains/${domain}")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(putAdminDomainRequestV3)
      r.response(asJson[PutAdminDomainResponseV3ApiResponse])
}

  /**
   * Warning: Deletes all existing products.         <br/>Note that this will not happen immediately. Instead, you receive the ID of a task that has been created.         <br/>Furthermore you receive an URL which you can use to check if the task was executed successfully.         <br>The csv file must contain following columns:         <ul>           <li>productId - arbitrary string, can be used for the systems product id.</li>           <li>gtin - the GTIN of the product           <li>description - name or short description of the product           <li>referencePrice - arbitrary decimal number, usually the current price or recommended retail price (gross)           <li>minPriceBoundary - decimal number defining the lower price boundary (gross)           <li>maxPriceBoundary - decimal number defining the upper price boundary (gross)           <li>Additional columns are added as product tags. Tags are used for repricing strategies and several other           purpose.         </ul>         <br/>Column separator must be semicolon, the decimal separator must be dot. File encoding must be UTF-8.
   * 
   * Expected answers:
   *   code 200 :  (-)
   *   code 202 : TaskIdAndUrl (Accepted)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param body CSV file containing the products
   */
  def putCSVProducts(contractId: String, body: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Unit] =
{
    var r = basicRequest
      .method(Method.PUT, uri"$baseUrl/api/2/v/contracts/${contractId}/products/csv")
      .contentType("text/csv")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(body)
      r.response(asJson[Unit])
}

  /**
   * This operation is used to import products into the pricemonitor. This process is represented by a task, which is processed asynchronously. In the response you will receive a url which is used to check the status of the import process. <br>  When the process is done all products in csv file from the request body will be in the pricemonitor. Products that were already present before have been updated and new products have been added. <br>  Warning: All products that were in the pricemonitor before but are not present in the new import will be deleted.  Identification of the products is done based on the identifying attributes (see parameter: patagona-product-identifying-attributes)'
   * 
   * Expected answers:
   *   code 202 : PutProductsApiResponse (The field data.url in the returned object allows to check the status of the import process. It will point to the endpoint GET /api/2/v/contracts/{contractId}/tasks/{taskId}. \\ The field data.id is the task id corresponding to the product import.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param contentType 
   * @param patagonaProductIdentifyingAttributes A single CSV column that identify a product uniquely. Avoid using tags as an identifier, as this feature will soon be deprecated. By doing so, you may loose historical market data during product import.
   * @param patagonaProductName Csv column that contains the product name
   * @param patagonaProductReferencePrice Csv column that contains the reference price
   * @param patagonaDecimalSeparator Decimal separator used for parsing numbers \\ The values for patagona-decimal-separator, patagona-csv-column-separator and patagona-csv-quotation-character must be different from one another. \\ Available values: \",\", \".\"
   * @param patagonaCsvColumnSeparator The csv column separator \\ The values for patagona-decimal-separator, patagona-csv-column-separator and patagona-csv-quotation-character must be different from one another.
   * @param patagonaCsvQuotationCharacter The csv quotation character \\ The values for patagona-decimal-separator, patagona-csv-column-separator and patagona-csv-quotation-character must be different from one another.
   * @param body CSV file containing the products. Note: The CSV file should be encoded in UTF-8.
   * @param patagonaProductGtin Csv column that contains the gtin
   * @param patagonaProductCustomerId Csv column that contains an id (There is no requirement for this field to be unique)
   */
  def putCSVProductsManufacturerV3(contractId: String, contentType: String, patagonaProductIdentifyingAttributes: String, patagonaProductName: String, patagonaProductReferencePrice: String, patagonaDecimalSeparator: String, patagonaCsvColumnSeparator: String, patagonaCsvQuotationCharacter: String, body: String, patagonaProductGtin: Option[String] = None, patagonaProductCustomerId: Option[String] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[PutProductsApiResponse] =
{
    var r = basicRequest
      .method(Method.PUT, uri"$baseUrl/api/v3/manufacturer/contracts/${contractId}/products")
      .contentType("text/csv")
      .header("content-type", contentType)
      .header("patagona-product-identifying-attributes", patagonaProductIdentifyingAttributes)
      .header("patagona-product-name", patagonaProductName)
      .header("patagona-product-reference-price", patagonaProductReferencePrice)
      .header("patagona-product-gtin", patagonaProductGtin)
      .header("patagona-product-customer-id", patagonaProductCustomerId)
      .header("patagona-decimal-separator", patagonaDecimalSeparator)
      .header("patagona-csv-column-separator", patagonaCsvColumnSeparator)
      .header("patagona-csv-quotation-character", patagonaCsvQuotationCharacter)
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(body)
      r.response(asJson[PutProductsApiResponse])
}

  /**
   * Expected answers:
   *   code 200 :  (-)
   *   code 404 :  (Settings for this contract don't exist yet)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param callbacks Callbacks
   */
  def putCallbacks(contractId: String, callbacks: Callbacks)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Unit] =
{
    var r = basicRequest
      .method(Method.PUT, uri"$baseUrl/api/2/m/contracts/${contractId}/settings/callbacks")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(callbacks)
      r.response(asJson[Unit])
}

  /**
   * Expected answers:
   *   code 200 : OfferFilterApiResponse (List of the filters that have been sent as the request body.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param listType 
   * @param andOfferFilter List of the filter that needs to be considered to ignore the individual offers.
   */
  def putComplexOfferFiltersVendorV2(contractId: String, listType: String, andOfferFilter: Seq[AndOfferFilter])(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[OfferFilterApiResponse] =
{
    var r = basicRequest
      .method(Method.PUT, uri"$baseUrl/api/2/v/contracts/${contractId}/offerfilters/${listType}/complex")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(andOfferFilter)
      r.response(asJson[OfferFilterApiResponse])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param body This is a generated entry and needs to be described.
   */
  def putCurrencyVendorV2(contractId: String, body: Option[Any] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.PUT, uri"$baseUrl/api/2/v/contracts/${contractId}/settings/currency")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(body)
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : PutCustomerContractSettingsApiResponse (Settings for this contract.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param customerContractSettings This is a generated entry and needs to be described.
   */
  def putCustomerContractSettingsManufacturerV3(contractId: String, customerContractSettings: Option[CustomerContractSettings] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[PutCustomerContractSettingsApiResponse] =
{
    var r = basicRequest
      .method(Method.PUT, uri"$baseUrl/api/v3/manufacturer/contracts/${contractId}/settings/customer")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(customerContractSettings)
      r.response(asJson[PutCustomerContractSettingsApiResponse])
}

  /**
   * Expected answers:
   *   code 200 : PutCustomerContractSettingsApiResponse (Settings for this contract.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param customerContractSettings This is a generated entry and needs to be described.
   */
  def putCustomerContractSettingsVendorV3(contractId: String, customerContractSettings: Option[CustomerContractSettings] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[PutCustomerContractSettingsApiResponse] =
{
    var r = basicRequest
      .method(Method.PUT, uri"$baseUrl/api/v3/vendor/contracts/${contractId}/settings/customer")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(customerContractSettings)
      r.response(asJson[PutCustomerContractSettingsApiResponse])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param body This is a generated entry and needs to be described.
   */
  def putDynamicMonitoringSettings(contractId: String, body: Option[Any] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.PUT, uri"$baseUrl/api/1/${contractId}/settings/dynamicmonitoring")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(body)
      r.response(asJson[Any])
}

  /**
   * The PUT request is proxied to the internal Export API.
   * 
   * Expected answers:
   *   code 200 : Any (Successful response returned by the Export API.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param path The export path to be called
   */
  def putExportRequestVendorV3(contractId: String, path: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.PUT, uri"$baseUrl/api/v3/vendor/contracts/${contractId}/export/${path}")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param feedId 
   * @param body This is a generated entry and needs to be described.
   */
  def putFeedVendorV2(contractId: String, feedId: String, body: Option[Any] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.PUT, uri"$baseUrl/api/2/v/contracts/${contractId}/feeds/${feedId}")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(body)
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param body This is a generated entry and needs to be described.
   */
  def putImageTagManufacturerV2(contractId: String, body: Option[Any] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.PUT, uri"$baseUrl/api/2/m/contracts/${contractId}/settings/imagetag")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(body)
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param body This is a generated entry and needs to be described.
   */
  def putImageTagVendorV2(contractId: String, body: Option[Any] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.PUT, uri"$baseUrl/api/2/v/contracts/${contractId}/settings/imagetag")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(body)
      r.response(asJson[Any])
}

  /**
   * The PUT request is proxied to the internal import-export API.
   * 
   * Expected answers:
   *   code 200 : Any (Successful response returned by the import-export API.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param path The import-export path to be called
   */
  def putImportExportRequestVendorV3(contractId: String, path: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.PUT, uri"$baseUrl/api/v3/vendor/contracts/${contractId}/import-export/${path}")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * The PUT request is proxied to the internal Import API.
   * 
   * Expected answers:
   *   code 200 : Any (Successful response returned by the Import API.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param path The import path to be called
   */
  def putImportRequestVendorV3(contractId: String, path: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.PUT, uri"$baseUrl/api/v3/vendor/contracts/${contractId}/import/${path}")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param body This is a generated entry and needs to be described.
   */
  def putImportSettingsVendorV2(contractId: String, body: Option[Any] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.PUT, uri"$baseUrl/api/2/v/contracts/${contractId}/settings/import")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(body)
      r.response(asJson[Any])
}

  /**
   * Update a monitoring schedule for a given manufacturer contract.
   * 
   * Expected answers:
   *   code 201 : PutMonitoringSchedulesApiResponse (Monitoring schedule has been updated successfully.)
   *   code 404 : ApiErrorResponse (Specified monitoring schedule does not exist.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param scheduleId ID of a monitoring schedule
   * @param postMonitoringScheduleRequestV3 Request body for updating monitoring schedule.
   */
  def putMonitoringScheduleManufacturerV3(contractId: String, scheduleId: Int, postMonitoringScheduleRequestV3: Option[PostMonitoringScheduleRequestV3] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[PutMonitoringSchedulesApiResponse] =
{
    var r = basicRequest
      .method(Method.PUT, uri"$baseUrl/api/v3/manufacturer/contracts/${contractId}/settings/monitoringschedules/${scheduleId}")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(postMonitoringScheduleRequestV3)
      r.response(asJson[PutMonitoringSchedulesApiResponse])
}

  /**
   * Update a monitoring schedule for a given vendor contract.
   * 
   * Expected answers:
   *   code 201 : PutMonitoringSchedulesApiResponse (Monitoring schedule has been updated successfully.)
   *   code 404 : ApiErrorResponse (Specified monitoring schedule does not exist.)
   *   code 503 : ApiErrorResponse (Monitoring schedule could not be updated due to an internal server error.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param scheduleId ID of a monitoring schedule
   * @param postMonitoringScheduleRequestV3 Request body for updating monitoring schedule.
   */
  def putMonitoringScheduleVendorV3(contractId: String, scheduleId: Int, postMonitoringScheduleRequestV3: Option[PostMonitoringScheduleRequestV3] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[PutMonitoringSchedulesApiResponse] =
{
    var r = basicRequest
      .method(Method.PUT, uri"$baseUrl/api/v3/vendor/contracts/${contractId}/settings/monitoringschedules/${scheduleId}")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(postMonitoringScheduleRequestV3)
      r.response(asJson[PutMonitoringSchedulesApiResponse])
}

  /**
   * Update the monitoring settings for a given contract
   * 
   * Expected answers:
   *   code 200 : Any (Returns the successfully updated monitoring settings object)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param body The monitoring settings object to be written to the database
   */
  def putMonitoringSettingsManufacturerV2(contractId: String, body: Option[Any] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.PUT, uri"$baseUrl/api/2/m/contracts/${contractId}/settings/monitoring")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(body)
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param body This is a generated entry and needs to be described.
   */
  def putMonitoringSettingsManufacturerV3(contractId: String, body: Option[Any] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.PUT, uri"$baseUrl/api/v3/manufacturer/contracts/${contractId}/settings/monitoring")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(body)
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param body This is a generated entry and needs to be described.
   */
  def putMonitoringSettingsVendorV2(contractId: String, body: Option[Any] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.PUT, uri"$baseUrl/api/2/v/contracts/${contractId}/settings/monitoring")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(body)
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param body This is a generated entry and needs to be described.
   */
  def putMonitoringSettingsVendorV3(contractId: String, body: Option[Any] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.PUT, uri"$baseUrl/api/v3/vendor/contracts/${contractId}/settings/monitoring")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(body)
      r.response(asJson[Any])
}

  /**
   * Store the vendor filters for the given contract.
   * 
   * Expected answers:
   *   code 200 : Any (List of the filters that have been sent as the request body.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param listType 
   * @param body List of the filters that needs to be considered to ignore the individual offers.
   */
  def putOfferFiltersVendorV2(contractId: String, listType: String, body: Option[Any] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.PUT, uri"$baseUrl/api/2/v/contracts/${contractId}/offerfilters/${listType}/vendors")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(body)
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param contractType 
   * @param body This is a generated entry and needs to be described.
   */
  def putOfferRetentionSettingsManufacturerV3(contractId: String, contractType: String, body: Option[Any] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.PUT, uri"$baseUrl/api/v3/manufacturer/contracts/${contractId}/settings/offerretention?contractType=$contractType")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(body)
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param contractType 
   * @param body This is a generated entry and needs to be described.
   */
  def putOfferRetentionSettingsVendorV3(contractId: String, contractType: String, body: Option[Any] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.PUT, uri"$baseUrl/api/v3/vendor/contracts/${contractId}/settings/offerretention?contractType=$contractType")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(body)
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : OfferFilterApiResponse (List of the filters that have been sent as the request body.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param listType 
   * @param productId 
   * @param andOfferFilter List of the filter that needs to be considered to ignore the individual offers.
   */
  def putProductFiltersVendorV2(contractId: String, listType: String, productId: String, andOfferFilter: Seq[AndOfferFilter])(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[OfferFilterApiResponse] =
{
    var r = basicRequest
      .method(Method.PUT, uri"$baseUrl/api/2/v/contracts/${contractId}/offerfilters/${listType}/products/${productId}")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(andOfferFilter)
      r.response(asJson[OfferFilterApiResponse])
}

  /**
   * This endpoint allows creating, updating, or deleting product properties for a certain product and contract. For deleting product properties, it's sufficient to provide an empty list of product properties. When providing dates, please use the ISO 8601 format. When providing numbers, please use dot as decimal separator.  Product properties represent additional information for a product, independent of imported products and tags. 
   * 
   * Expected answers:
   *   code 200 : EmptyApiResponse (The product properties have been stored successfully for the product.)
   *   code 400 : ApiErrorResponse (Returned if the request body is invalid: - The request body is not a valid JSON string. - The provided product properties contain duplicated keys. - The provided product properties contain an empty key. - The provided product properties contain a key which is too long. - The provided product properties contain a value which is too long. )
   *   code 404 : ApiErrorResponse (Returned if the product does not exist.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param productId ID of the product (Omnia's internal product id)
   * @param putProductPropertiesRequestV3 
   */
  def putProductPropertiesV3(contractId: String, productId: Long, putProductPropertiesRequestV3: PutProductPropertiesRequestV3)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[EmptyApiResponse] =
{
    var r = basicRequest
      .method(Method.PUT, uri"$baseUrl/api/v3/vendor/contracts/${contractId}/products/${productId}/properties")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(putProductPropertiesRequestV3)
      r.response(asJson[EmptyApiResponse])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param body This is a generated entry and needs to be described.
   */
  def putProductsCSVManufacturerV2(contractId: String, body: Option[Any] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.PUT, uri"$baseUrl/api/2/m/contracts/${contractId}/products/csv")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(body)
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param body This is a generated entry and needs to be described.
   */
  def putProductsVendorV2(contractId: String, body: Option[Any] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.PUT, uri"$baseUrl/api/2/v/contracts/${contractId}/products")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(body)
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : Any (Save a new strategy version)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param body This is a generated entry and needs to be described.
   */
  def putRepricingStrategyVendorV2(contractId: String, body: Option[Any] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.PUT, uri"$baseUrl/api/2/v/contracts/${contractId}/settings/repricingstrategy")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(body)
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : PutAdminContractSettingsBody (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param putAdminContractSettingsBody This is a generated entry and needs to be described.
   */
  def putSettings(contractId: String, putAdminContractSettingsBody: Option[PutAdminContractSettingsBody] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[PutAdminContractSettingsBody] =
{
    var r = basicRequest
      .method(Method.PUT, uri"$baseUrl/api/1/${contractId}/settings")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(putAdminContractSettingsBody)
      r.response(asJson[PutAdminContractSettingsBody])
}

  /**
   * Users can either access all contracts of a company or only dedicated contracts. With this api endpoint one can control the access rights of a user. 
   * 
   * Expected answers:
   *   code 200 : EmptyApiResponse (Empty response signalling that the changes have been applied.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param companyId ID of a company
   * @param userAccessToContractsOfCompany All users and their accessible contracts
   */
  def putUserAccessToContractsOfCompanyV3(companyId: Long, userAccessToContractsOfCompany: Option[UserAccessToContractsOfCompany] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[EmptyApiResponse] =
{
    var r = basicRequest
      .method(Method.PUT, uri"$baseUrl/api/v3/companies/${companyId}/users/contractaccess")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(userAccessToContractsOfCompany)
      r.response(asJson[EmptyApiResponse])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param body This is a generated entry and needs to be described.
   */
  def putVendorSettingsVendorV2(contractId: String, body: Option[Any] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.PUT, uri"$baseUrl/api/2/v/contracts/${contractId}/settings/repricing")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(body)
      r.response(asJson[Any])
}

  /**
   * Update an existing vendor for a given manufacturer contract and associate shops with the given vendor.
   * 
   * Expected answers:
   *   code 200 : VendorShopMappingV3ApiResponse (Vendor shop mapping has been successfully updated.)
   *   code 400 : ApiErrorResponse (The specified vendor name is empty. Or the specified shops are empty.)
   *   code 409 : ApiErrorResponse (The specified vendor name already exists in our system.)
   *   code 422 : ApiErrorResponse (The specified shops do not exist in our system.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param vendorId ID of vendor shop mapping
   * @param postVendorShopMappingRequestV3 Request body for updating an existing vendor and associate shops with it. Please note that at least one shop is required for a successful creation.
   */
  def putVendorShopMappingManufacturerV3(contractId: String, vendorId: Long, postVendorShopMappingRequestV3: Option[PostVendorShopMappingRequestV3] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[VendorShopMappingV3ApiResponse] =
{
    var r = basicRequest
      .method(Method.PUT, uri"$baseUrl/api/v3/manufacturer/contracts/${contractId}/vendors/${vendorId}")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(postVendorShopMappingRequestV3)
      r.response(asJson[VendorShopMappingV3ApiResponse])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param body This is a generated entry and needs to be described.
   */
  def queryOffersManufacturerV3(contractId: String, body: Option[Any] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.POST, uri"$baseUrl/api/v3/manufacturer/contracts/${contractId}/offers/query")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(body)
      r.response(asJson[Any])
}

  /**
   * This operation is used to query price dumping statistics for a time range for a set of shops.
   * 
   * Expected answers:
   *   code 200 : QueryPriceDumpingStatsApiResponse (Returns the price dumping statistics in the given time range.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param priceDumpingStatsRequest 
   */
  def queryOffersPriceDumpingStatsManufacturerV3(contractId: String, priceDumpingStatsRequest: PriceDumpingStatsRequest)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[QueryPriceDumpingStatsApiResponse] =
{
    var r = basicRequest
      .method(Method.POST, uri"$baseUrl/api/v3/manufacturer/contracts/${contractId}/offers/pricedumpingstats")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(priceDumpingStatsRequest)
      r.response(asJson[QueryPriceDumpingStatsApiResponse])
}

  /**
   * This operation is used to query price dumping statistics for a time range for a set of shops.
   * 
   * Expected answers:
   *   code 200 : QueryPriceDumpingStatsApiResponse (Returns the price dumping statistics in the given time range.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param priceDumpingStatsRequest 
   */
  def queryOffersPriceDumpingStatsVendorV3(contractId: String, priceDumpingStatsRequest: PriceDumpingStatsRequest)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[QueryPriceDumpingStatsApiResponse] =
{
    var r = basicRequest
      .method(Method.POST, uri"$baseUrl/api/v3/vendor/contracts/${contractId}/offers/pricedumpingstats")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(priceDumpingStatsRequest)
      r.response(asJson[QueryPriceDumpingStatsApiResponse])
}

  /**
   * Get all offers of a shop. Please note that it might return offers for inactive products.
   * 
   * Expected answers:
   *   code 200 : QueryOffersOfShopV3ApiResponse (Returns offers of the shop)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param queryOffersOfShopRequestV3 
   */
  def queryOffersShopManufacturerV3(contractId: String, queryOffersOfShopRequestV3: QueryOffersOfShopRequestV3)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[QueryOffersOfShopV3ApiResponse] =
{
    var r = basicRequest
      .method(Method.POST, uri"$baseUrl/api/v3/manufacturer/contracts/${contractId}/offers/shop/query")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(queryOffersOfShopRequestV3)
      r.response(asJson[QueryOffersOfShopV3ApiResponse])
}

  /**
   * Get all offers of a shop. Please note that it might return offers for inactive products.
   * 
   * Expected answers:
   *   code 200 : QueryOffersOfShopV3ApiResponse (Returns offers of the shop)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param queryOffersOfShopRequestV3 
   */
  def queryOffersShopVendorV3(contractId: String, queryOffersOfShopRequestV3: QueryOffersOfShopRequestV3)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[QueryOffersOfShopV3ApiResponse] =
{
    var r = basicRequest
      .method(Method.POST, uri"$baseUrl/api/v3/vendor/contracts/${contractId}/offers/shop/query")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(queryOffersOfShopRequestV3)
      r.response(asJson[QueryOffersOfShopV3ApiResponse])
}

  /**
   * This operation is used to get offer statistics (e.g. offer count, average price) grouped by product and domain. Warning: This endpoint contains complex query structure and will be replaced in the future. Please note that offer statistics can only be computed for at maximum 2500 products at a time.
   * 
   * Expected answers:
   *   code 200 : PostOfferStatisticsApiResponse (Returns a list of offer statistics per product.)
   *   code 400 : ApiError (Returned in case of unparsable request body JSON or unsupported filter.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param postOfferStatisticsRequest 
   */
  def queryOffersStatsManufacturerV3(contractId: String, postOfferStatisticsRequest: PostOfferStatisticsRequest)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[PostOfferStatisticsApiResponse] =
{
    var r = basicRequest
      .method(Method.POST, uri"$baseUrl/api/v3/manufacturer/contracts/${contractId}/offers/stats/query")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(postOfferStatisticsRequest)
      r.response(asJson[PostOfferStatisticsApiResponse])
}

  /**
   * This endpoint can be used to query offer statistics (e.g. offer count, average price) grouped by product. Only the most recent market data is considered per product and domain. 
   * 
   * Expected answers:
   *   code 200 : QueryOfferStatisticsV31ApiResponse (Returns a list of offer statistics per product. When a product has no market data then no offer statistics are returned for that product. )
   *   code 400 : ApiErrorResponse (A `400` error is returned under the following conditions: - The request body JSON is unparsable. - An unsupported filter is provided. - The specified time range exceeds 48 hours. - The pagination limit exceeds 10,000. )
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param postOfferStatisticsRequestV31 The request body may include an optional products query. If omitted, all products are queried. Currently, product queries can be performed on two attributes:   - \"customerProductId\"   - \"productId\" (Patagona's internal product id; must be a numerical integer)  Pagination is supported with a maximum limit of 10,000. For optimized performance:   - Use a limit of 10,000 products per page when querying all products of a contract.   - Prefer using \"productId\" for queries when a product query is utilized.  Pagination operates based on the provided products query. This is particularly useful when querying a set of customerProductId's. For chunked requests over a set of ids, it's straightforward to specify up to 10,000 customerProductId's in the query with pagination set at start: 0, limit: 10,000. The allowed query pattern is structured as follows: ``` json {   \"pagination\": {     \"start\": ${start},     \"limit\": ${limit}   },   \"range\": {     \"start\": ${start},     \"end\": ${end}   },   \"filter\": {     \"oneOf\": {       \"field\": \"customerProductId\",       \"values\": [${customerProductIds as a list of strings}]     }   } } ```
   */
  def queryOffersStatsManufacturerV31(contractId: String, postOfferStatisticsRequestV31: Option[PostOfferStatisticsRequestV31] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[QueryOfferStatisticsV31ApiResponse] =
{
    var r = basicRequest
      .method(Method.POST, uri"$baseUrl/api/v3.1/manufacturer/contracts/${contractId}/offers/stats/query")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(postOfferStatisticsRequestV31)
      r.response(asJson[QueryOfferStatisticsV31ApiResponse])
}

  /**
   * This endpoint is used to query certain price recommendations. It supports a rather complex filtering structure. Most commonly it's used for querying by our internal product id.  Here you can find an example request body for querying one product id (here `123456`):  <details> <summary>Click to expand</summary>  ``` json {   \"pagination\": {     \"start\": 0,     \"limit\": 500   },   \"range\": {     \"start\": \"2023-01-07T12:05:01.000Z\",     \"end\": \"2023-01-09T12:05:01.000Z\"   },   \"filter\": {     \"filters\": [{       \"left\": {         \"attributeName\": \"productId\",         \"type\": \"StringValueProvider\"       },       \"right\": {         \"value\": \"123456\",         \"type\": \"StringConstantValueProvider\"       },       \"comparison\": {         \"type\": \"StringEquality\"       },       \"type\": \"ComparisonFilter\"     }],     \"type\": \"OrFilter\"   } } ``` </details>  If you want to query for multiple product ids, then you need to provide one object per product id in the filters-array.  It's recommended to query for at most 1000 price recommendations at once.
   * 
   * Expected answers:
   *   code 200 : QueryPriceRecommendationsV2ApiResponse (A paginated list of price recommendations is returned for the specified timerange. <br> Only the newest price recommendations are returned in case of multiple price recommendations per product. )
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param priceRecommendationApiQueryV2 The request body specifies which price recommendations will be searched for.
   */
  def queryPriceRecommendationsVendorV2(contractId: String, priceRecommendationApiQueryV2: Option[PriceRecommendationApiQueryV2] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[QueryPriceRecommendationsV2ApiResponse] =
{
    var r = basicRequest
      .method(Method.POST, uri"$baseUrl/api/2/v/contracts/${contractId}/result/pricerecommendations/query")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(priceRecommendationApiQueryV2)
      r.response(asJson[QueryPriceRecommendationsV2ApiResponse])
}

  /**
   * This endpoint can be used for querying either all products or certain products by product ids.
   * 
   * Expected answers:
   *   code 200 : QueryProductsByFilterManufacturerV3ApiResponse (Returns a list of found products.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param queryProductsRequestV3 The body contains the products query.
   */
  def queryProductsByFilterManufacturerV3(contractId: String, queryProductsRequestV3: Option[QueryProductsRequestV3] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[QueryProductsByFilterManufacturerV3ApiResponse] =
{
    var r = basicRequest
      .method(Method.POST, uri"$baseUrl/api/v3/manufacturer/contracts/${contractId}/products/query")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(queryProductsRequestV3)
      r.response(asJson[QueryProductsByFilterManufacturerV3ApiResponse])
}

  /**
   * This endpoint can be used for querying either all products or certain products by product ids.
   * 
   * Expected answers:
   *   code 200 : QueryProductsByFilterVendorV3ApiResponse (Returns a list of found products.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param queryProductsRequestV3 The body contains the products query.
   */
  def queryProductsByFilterVendorV3(contractId: String, queryProductsRequestV3: Option[QueryProductsRequestV3] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[QueryProductsByFilterVendorV3ApiResponse] =
{
    var r = basicRequest
      .method(Method.POST, uri"$baseUrl/api/v3/vendor/contracts/${contractId}/products/query")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(queryProductsRequestV3)
      r.response(asJson[QueryProductsByFilterVendorV3ApiResponse])
}

  /**
   * Expected answers:
   *   code 200 : QueryProductsManufacturerV3ApiResponse (Returns a list of found products.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param apiQuery The body contains the products query. <br> Currently, it supports only product queries for two attributes:<br> <ul>   <li> by \"customerProductId\"</li>   <li> by \"productId\" (Patagona's internal product id). Allowed values for 'productId' are numerical integer values</li> </ul> The maximum allowed limit in the pagination is 10000. <br> For better performance, when paginating over all products of a contract, we recommend to use a limit of 10000 products per page. Pagination works with respective to the given products query. <br> This is most relevant when querying for a set of customerProductId's. <br> When the requests are chunked over a set of ids, it is easiest to provide up to 10000 customerProductId's in the query and keep the pagination at start: 0, limit: 10000. <br> The only allowed pattern is currently: <br> { <br> &nbsp;&nbsp;\"pagination\": { <br> &nbsp;&nbsp;&nbsp;&nbsp;\"start\": ${start}, <br> &nbsp;&nbsp;&nbsp;&nbsp;\"limit\": ${limit} <br> &nbsp;&nbsp;}, <br> &nbsp;&nbsp;\"filter\": { <br> &nbsp;&nbsp;&nbsp;&nbsp;\"oneOf\": { <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"field\": \"customerProductId\", <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"values\": [${customerProductIds as a list of strings}] <br> &nbsp;&nbsp;&nbsp;&nbsp;} <br> &nbsp;&nbsp;} <br> } <br> <br> example: <br> { <br> &nbsp;&nbsp;\"pagination\": { <br> &nbsp;&nbsp;&nbsp;&nbsp;\"start\": 0, <br> &nbsp;&nbsp;&nbsp;&nbsp;\"limit\": 10 <br> &nbsp;&nbsp;}, <br> &nbsp;&nbsp;\"filter\": { <br> &nbsp;&nbsp;\"oneOf\": { <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"field\": \"customerProductId\", <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"values\": [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\"] <br> &nbsp;&nbsp;&nbsp;&nbsp;} <br> &nbsp;&nbsp;} <br> } <br> 
   */
  def queryProductsManufacturerV3(contractId: String, apiQuery: Option[ApiQuery] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[QueryProductsManufacturerV3ApiResponse] =
{
    var r = basicRequest
      .method(Method.POST, uri"$baseUrl/api/v3.1/manufacturer/contracts/${contractId}/products/query")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(apiQuery)
      r.response(asJson[QueryProductsManufacturerV3ApiResponse])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param start 
   * @param limit 
   * @param since 
   * @param until 
   */
  def rawOffers(contractId: String, start: Int, limit: Int, since: Option[OffsetDateTime] = None, until: Option[OffsetDateTime] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/1/${contractId}/products/offers?start=$start&limit=$limit&since=$since&until=$until")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param companyId ID of a company
   * @param userId 
   */
  def removeUser(companyId: Long, userId: Long)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.DELETE, uri"$baseUrl/controlpanel/api/companies/${companyId}/users/${userId}")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : String (Successful response upon password request)
   *   code 400 : ApiErrorResponse (Invalid request body is specified)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param postNewPasswordRequest Request a new password.
   */
  def requestNewPassword(postNewPasswordRequest: Option[PostNewPasswordRequest] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[String] =
{
    var r = basicRequest
      .method(Method.POST, uri"$baseUrl/api/account/password/reset")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(postNewPasswordRequest)
      r.response(asJson[String])
}

  /**
   * Expected answers:
   *   code 200 : String (Password changed successfully.)
   *   code 400 : String (Password didn't change successfully.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param putResetPasswordRequest Reset a password
   */
  def resetPassword(putResetPasswordRequest: Option[PutResetPasswordRequest] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[String] =
{
    var r = basicRequest
      .method(Method.PUT, uri"$baseUrl/api/account/password/reset")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(putResetPasswordRequest)
      r.response(asJson[String])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param body This is a generated entry and needs to be described.
   */
  def saveIncludeDeliveryCosts(contractId: String, body: Option[Any] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.POST, uri"$baseUrl/api/1/${contractId}/settings/include_delivery_costs")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(body)
      r.response(asJson[Any])
}

  /**
   * The DELETE request is proxied to the internal Scheduler API.
   * 
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param path The scheduler path to be called
   */
  def schedulerDeleteRequestManufacturerV3(contractId: String, path: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.DELETE, uri"$baseUrl/api/v3/manufacturer/contracts/${contractId}/scheduler/${path}")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * The DELETE request is proxied to the internal Scheduler API.
   * 
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param path The scheduler path to be called
   */
  def schedulerDeleteRequestVendorV3(contractId: String, path: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.DELETE, uri"$baseUrl/api/v3/vendor/contracts/${contractId}/scheduler/${path}")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * The GET request is proxied to the internal Scheduler API.
   * 
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param path The scheduler path to be called
   */
  def schedulerGetRequestManufacturerV3(contractId: String, path: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/v3/manufacturer/contracts/${contractId}/scheduler/${path}")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * The GET request is proxied to the internal Scheduler API.
   * 
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param path The scheduler path to be called
   */
  def schedulerGetRequestVendorV3(contractId: String, path: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/v3/vendor/contracts/${contractId}/scheduler/${path}")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * The POST request is proxied to the internal Scheduler API.
   * 
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param path The scheduler path to be called
   */
  def schedulerPostRequestManufacturerV3(contractId: String, path: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.POST, uri"$baseUrl/api/v3/manufacturer/contracts/${contractId}/scheduler/${path}")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * The POST request is proxied to the internal Scheduler API.
   * 
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param path The scheduler path to be called
   */
  def schedulerPostRequestVendorV3(contractId: String, path: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.POST, uri"$baseUrl/api/v3/vendor/contracts/${contractId}/scheduler/${path}")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * The PUT request is proxied to the internal Scheduler API.
   * 
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param path The scheduler path to be called
   */
  def schedulerPutRequestManufacturerV3(contractId: String, path: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.PUT, uri"$baseUrl/api/v3/manufacturer/contracts/${contractId}/scheduler/${path}")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * The PUT request is proxied to the internal Scheduler API.
   * 
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param path The scheduler path to be called
   */
  def schedulerPutRequestVendorV3(contractId: String, path: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.PUT, uri"$baseUrl/api/v3/vendor/contracts/${contractId}/scheduler/${path}")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param body This is a generated entry and needs to be described.
   */
  def segmentOffersManufacturerV2(contractId: String, body: Option[Any] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.POST, uri"$baseUrl/api/2/m/contracts/${contractId}/result/offersegmentation")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(body)
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param body This is a generated entry and needs to be described.
   */
  def segmentOffersVendorV2(contractId: String, body: Option[Any] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.POST, uri"$baseUrl/api/2/v/contracts/${contractId}/result/offersegmentation")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(body)
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param path The shop-integration path to be called
   */
  def shopIntegrationGetRequest(contractId: String, path: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/2/v/contracts/${contractId}/shop-integration/${path}")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param path The shop-integration path to be called
   */
  def shopIntegrationPostRequest(contractId: String, path: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.POST, uri"$baseUrl/api/2/v/contracts/${contractId}/shop-integration/${path}")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param path 
   * @param body This is a generated entry and needs to be described.
   */
  def shopIntegrationPostRequestVendorV2(contractId: String, path: String, body: Option[Any] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.POST, uri"$baseUrl/api/2/v/contracts/${contractId}/products/import?path=$path")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(body)
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : ContractStats (Get the contract statistics: product count, vendor count, found offers count (filters applied), active portals count, found offers count (no filters applied))
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param session A ISO 8601 timestamp which marks the end of a 48h time range in which the data is collected
   */
  def statsManufacturerV2(contractId: String, session: OffsetDateTime)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[ContractStats] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/2/m/contracts/${contractId}/result/contract/stats?session=$session")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[ContractStats])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param limit 
   */
  def timestampsManufacturerV2(contractId: String, limit: Int)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/2/m/contracts/${contractId}/result/timestamps?limit=$limit")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param alertId 
   * @param body This is a generated entry and needs to be described.
   */
  def updateAlertSettings(contractId: String, alertId: String, body: Option[Any] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.PUT, uri"$baseUrl/api/1/${contractId}/settings/alerts/${alertId}")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(body)
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param email 
   * @param token 
   * @param body This is a generated entry and needs to be described.
   */
  def updateAuthToken(email: String, token: String, body: Option[Any] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.PUT, uri"$baseUrl/controlpanel/users/${email}/authtokens/${token}")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(body)
      r.response(asJson[Any])
}

  /**
   * Update an existing task.
   * 
   * Expected answers:
   *   code 200 : GenericTask (The task was successfully updated and the given data is returned)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param taskId 
   * @param updateTaskRequestV2 The new task object to be written to the database
   */
  def updateTaskManufacturerV2(contractId: String, taskId: String, updateTaskRequestV2: Option[UpdateTaskRequestV2] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[GenericTask] =
{
    var r = basicRequest
      .method(Method.PUT, uri"$baseUrl/api/2/m/contracts/${contractId}/tasks/${taskId}")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(updateTaskRequestV2)
      r.response(asJson[GenericTask])
}

  /**
   * Update the task with the specified id for the given contract.
   * 
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param taskId 
   * @param body This is a generated entry and needs to be described.
   */
  def updateTaskVendorV2(contractId: String, taskId: String, body: Option[Any] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.PUT, uri"$baseUrl/api/2/v/contracts/${contractId}/tasks/${taskId}")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(body)
      r.response(asJson[Any])
}

  /**
   * Add the specified role to the given user.
   * 
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param userId 
   * @param roleName 
   * @param body This is a generated entry and needs to be described.
   */
  def updateUserRole(userId: Long, roleName: String, body: Option[Any] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.PUT, uri"$baseUrl/api/2/users/${userId}/role/${roleName}")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(body)
      r.response(asJson[Any])
}

  /**
   * Returns the current user with its companies and contracts
   * 
   * Expected answers:
   *   code 200 : UserInfo (No response was specified)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   */
  def userInfo()(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[UserInfo] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/account")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[UserInfo])
}

  /**
   * Expected answers:
   *   code 200 :  (No response was specified)
   *   code 201 :  (User was created and confirmation e-mail was sent)
   *   code 400 : ApiErrorResponse (Unable to create the user because of bad request data)
   *   code 500 : ApiErrorResponse (Unable to create the user because of an unexpected error)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param userSignupRequest The user sign up data
   */
  def userSignup(userSignupRequest: UserSignupRequest)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Unit] =
{
    var r = basicRequest
      .method(Method.POST, uri"$baseUrl/api/account")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(userSignupRequest)
      r.response(asJson[Unit])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param body This is a generated entry and needs to be described.
   */
  def validateOffersManufacturerV2(contractId: String, body: Option[Any] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.POST, uri"$baseUrl/api/2/m/contracts/${contractId}/result/validation")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(body)
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param body This is a generated entry and needs to be described.
   */
  def validateOffersVendorV2(contractId: String, body: Option[Any] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.POST, uri"$baseUrl/api/2/v/contracts/${contractId}/result/validation")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(body)
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param vendor 
   * @param minPrice 
   * @param maxPrice 
   */
  def vendorData(vendor: String, minPrice: Double, maxPrice: Double)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/controlpanel/vendorexport/${vendor}?minPrice=$minPrice&maxPrice=$maxPrice")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * Get the current application version
   * 
   * Expected answers:
   *   code 200 : VersionApiResponse (Current application version.)
   */
  def version(): ApiRequestT[VersionApiResponse] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/version")
      .contentType("application/json")
      r.response(asJson[VersionApiResponse])
}

}

