/**
 * Omnia 2.0 API The Omnia 2.0 API is RESTful and provides access to the backend of Omnia 2.0 and Pricemonitor. It is used to manage products, offers, contracts and more.
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.0.6996
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
package com.patagona.pricemonitor.client.api

import com.patagona.pricemonitor.client.model.ApiErrorResponse
import com.patagona.pricemonitor.client.model.DeleteOrdersByQueryRequestV3
import com.patagona.pricemonitor.client.model.DeletedItemsApiResponse
import java.time.OffsetDateTime
import com.patagona.pricemonitor.client.model.PostCustomerOrdersRequestV2
import com.patagona.pricemonitor.client.model.PostOrderStatisticsRequestV3
import com.patagona.pricemonitor.client.model.PostOrdersBulkApiResponse
import com.patagona.pricemonitor.client.model.PutCustomerOrdersRequestV3
import com.patagona.pricemonitor.client.model.PutItemsV3ApiResponse
import com.patagona.pricemonitor.client.model.QueryOrderStatisticsV3ApiResponse
import com.patagona.pricemonitor.client.core._
import alias._
import sttp.client._
import sttp.model.Method

object OrdersApi {

  def apply(baseUrl: String = "https://api.patagona.de")(implicit serializer: SttpSerializer) = new OrdersApi(baseUrl)
}

class OrdersApi(baseUrl: String)(implicit serializer: SttpSerializer) {

  import Helpers._
  import serializer._

  /**
   * Delete all orders for this contract.
   * 
   * Expected answers:
   *   code 200 : DeletedItemsApiResponse (Successfully deleted all orders)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   */
  def deleteOrders(contractId: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[DeletedItemsApiResponse] =
{
    var r = basicRequest
      .method(Method.DELETE, uri"$baseUrl/api/v3/vendor/contracts/${contractId}/orders")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[DeletedItemsApiResponse])
}

  /**
   * This endpoint can be used to delete customer orders by an order query
   * 
   * Expected answers:
   *   code 200 : DeletedItemsApiResponse (Returns the number of orders that have been deleted successfully )
   *   code 400 : ApiErrorResponse (A `400` error is returned under the following conditions: - The request body JSON is unparsable. - The provided order queries exceeds 10,000. )
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param deleteOrdersByQueryRequestV3 The request body should contain a list of order queries. Each query should contain an order id and creation date.  The allowed query pattern is structured as follows:  { <br> &nbsp;&nbsp;\"orders\": [ <br> &nbsp;&nbsp;&nbsp;{ <br> &nbsp;&nbsp;&nbsp;&nbsp;\"orderId\": ${orderId}, <br> &nbsp;&nbsp;&nbsp;&nbsp;\"creationDate\": ${creationDate} <br> &nbsp;&nbsp;} <br> &nbsp;&nbsp;&nbsp;] <br> } <br> <br> 
   */
  def deleteOrdersByQueryVendorV3(contractId: String, deleteOrdersByQueryRequestV3: DeleteOrdersByQueryRequestV3)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[DeletedItemsApiResponse] =
{
    var r = basicRequest
      .method(Method.POST, uri"$baseUrl/api/v3/vendor/contracts/${contractId}/orders/delete/query")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(deleteOrdersByQueryRequestV3)
      r.response(asJson[DeletedItemsApiResponse])
}

  /**
   * Get the number of orders by portal for the given contract.
   * 
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   */
  def getOrdersCountByPortalByContract(contractId: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/1/${contractId}/products/orderscountbyportal")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * Returns all orders for a given contract.
   * 
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param start 
   * @param limit 
   * @param startDate Timestamp of start of time range for fetching orders. Formatted as ISO 8601 format with timezone with reference to UTC (e.g. for [Europe/Berlin] in winter time: 2023-11-01T14:50:45.495+01:00. In summer time: 2023-11-01T14:50:45.495+02:00). If this value is omitted then no lower time limit is considered. 
   * @param endDate Timestamp of end of time range for fetching orders. Formatted as ISO 8601 format with timezone with reference to UTC (e.g. for [Europe/Berlin] in winter time: 2023-11-01T14:50:45.495+01:00. In summer time: 2023-11-01T14:50:45.495+02:00). If this value is omitted then no upper time limit is considered. 
   */
  def getOrdersVendorV3(contractId: String, start: Int, limit: Int, startDate: Option[OffsetDateTime] = None, endDate: Option[OffsetDateTime] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/v3/vendor/contracts/${contractId}/orders?start=$start&limit=$limit&startDate=$startDate&endDate=$endDate")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : PostOrdersBulkApiResponse (Successfully added orders)
   *   code 400 : PostOrdersBulkApiResponse (Unable to add orders)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param postCustomerOrdersRequestV2 Orders to be added
   */
  def postOrders(contractId: String, postCustomerOrdersRequestV2: PostCustomerOrdersRequestV2)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[PostOrdersBulkApiResponse] =
{
    var r = basicRequest
      .method(Method.POST, uri"$baseUrl/api/2/v/contracts/${contractId}/orders")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(postCustomerOrdersRequestV2)
      r.response(asJson[PostOrdersBulkApiResponse])
}

  /**
   * Saves orders in bulk. If an orderId was already used by this contract this order and all it's order-items will be overwritten.  - the `version` of the request body must be \"3\" - requests must not contain duplicated `orderId` - the number of orders in one request must not exceed 10,000 - each order must have at least one item - the `orders.items.itemId` fields should correspond to a `customerProductId` of a product definition inside   the contract 
   * 
   * Expected answers:
   *   code 201 : PutItemsV3ApiResponse (The response provides the ids of the successfully imported orders)
   *   code 400 : ApiErrorResponse (Unable to add orders because of invalid request data)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param putCustomerOrdersRequestV3 
   */
  def putOrdersV3(contractId: String, putCustomerOrdersRequestV3: Option[PutCustomerOrdersRequestV3] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[PutItemsV3ApiResponse] =
{
    var r = basicRequest
      .method(Method.PUT, uri"$baseUrl/api/v3/vendor/contracts/${contractId}/orders")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(putCustomerOrdersRequestV3)
      r.response(asJson[PutItemsV3ApiResponse])
}

  /**
   * This endpoint can be used to query order statistics grouped by product.
   * 
   * Expected answers:
   *   code 200 : QueryOrderStatisticsV3ApiResponse (Returns a list of order statistics per product. When a product has no sold items then no order statistics are returned for that product. )
   *   code 400 : ApiErrorResponse (A `400` error is returned under the following conditions: - The request body JSON is unparsable. - An unsupported filter is provided. - The specified time range exceeds 30 days. - The pagination limit exceeds 10,000. )
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param postOrderStatisticsRequestV3 The request body may include an optional products query. If omitted, all products are queried. Currently, product queries can be performed on two attributes:   - \"customerProductId\"   - \"productId\" (Patagona's internal product id; must be a numerical integer)  Pagination is supported with a maximum limit of 10,000. For optimized performance:   - Use a limit of 10,000 products per page when querying all products of a contract.   - Prefer using \"customerProductId\" for queries when a product query is utilized.  Pagination operates based on the provided products query. For chunked requests over a set of ids, it's straightforward to specify up to 10,000 customerProductId's in the query with pagination set at start: 0, limit: 10,000.  The allowed query pattern is structured as follows:  { <br> &nbsp;&nbsp;\"pagination\": { <br> &nbsp;&nbsp;&nbsp;&nbsp;\"start\": ${start}, <br> &nbsp;&nbsp;&nbsp;&nbsp;\"limit\": ${limit} <br> &nbsp;&nbsp;}, <br> &nbsp;&nbsp;\"range\": { <br> &nbsp;&nbsp;&nbsp;&nbsp;\"start\": ${start}, <br> &nbsp;&nbsp;&nbsp;&nbsp;\"end\": ${end} <br> &nbsp;&nbsp;}, <br> &nbsp;&nbsp;\"filter\": { <br> &nbsp;&nbsp;&nbsp;&nbsp;\"oneOf\": { <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"field\": \"customerProductId\", <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"values\": [${customerProductIds as a list of strings}] <br> &nbsp;&nbsp;&nbsp;&nbsp;} <br> &nbsp;&nbsp;} <br> } <br> <br> 
   */
  def queryOrdersStatsVendorV3(contractId: String, postOrderStatisticsRequestV3: PostOrderStatisticsRequestV3)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[QueryOrderStatisticsV3ApiResponse] =
{
    var r = basicRequest
      .method(Method.POST, uri"$baseUrl/api/v3/vendor/contracts/${contractId}/orders/stats/query")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(postOrderStatisticsRequestV3)
      r.response(asJson[QueryOrderStatisticsV3ApiResponse])
}

}

