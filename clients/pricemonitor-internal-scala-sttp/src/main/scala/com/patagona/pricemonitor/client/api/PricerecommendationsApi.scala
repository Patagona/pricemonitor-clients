/**
 * Omnia 2.0 API The Omnia 2.0 API is RESTful and provides access to the backend of Omnia 2.0 and Pricemonitor. It is used to manage products, offers, contracts, and more.  This API supports both public endpoints for customer integration and internal endpoints for platform management. All endpoints are authenticated using either Basic Authentication or JWT Bearer tokens.
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.0.7192
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
package com.patagona.pricemonitor.client.api

import com.patagona.pricemonitor.client.model.ApiErrorResponse
import com.patagona.pricemonitor.client.model.BooleanBulkApiResponse
import com.patagona.pricemonitor.client.model.GetPriceRecommendationApiResponse
import com.patagona.pricemonitor.client.model.GetPriceRecommendationHistoryApiResponse
import com.patagona.pricemonitor.client.model.GetPriceRecommendationsResponse
import java.time.OffsetDateTime
import com.patagona.pricemonitor.client.model.PostPriceRecommendationApprovalRequestV3
import com.patagona.pricemonitor.client.model.PriceRecommendationApiQueryV2
import com.patagona.pricemonitor.client.model.PriceRecommendationsApprovalQueryRequestV3
import com.patagona.pricemonitor.client.model.PriceSimulationBulkRequestV3
import com.patagona.pricemonitor.client.model.QueryPriceRecommendationsApprovalsV3ApiResponse
import com.patagona.pricemonitor.client.model.QueryPriceRecommendationsV2ApiResponse
import com.patagona.pricemonitor.client.model.SimulatePriceCalculationBulkV3ApiResponse
import com.patagona.pricemonitor.client.core._
import alias._
import sttp.client._
import sttp.model.Method

object PricerecommendationsApi {

  def apply(baseUrl: String = "https://api.patagona.de")(implicit serializer: SttpSerializer) = new PricerecommendationsApi(baseUrl)
}

class PricerecommendationsApi(baseUrl: String)(implicit serializer: SttpSerializer) {

  import Helpers._
  import serializer._

  /**
   * Processes bulk decisions for price recommendation approvals. Only pending price recommendations can be decided.  ## Notes - *Approval* refers to the price approval flow concept in our business processes, covering all states of price recommendations within this flow (i.e., pending, approved, rejected). The term does not mean all price recommendations are approved. - We preserve a linear history: Once a price recommendation approval is **finalized** (i.e., no longer pending), it can no longer be changed. - If any user rejects, the entire price recommendation is rejected. - If a user has already submitted an active (not superseded) decision for a recommendation, they cannot submit another. - The endpoint is not idempotent, as submitting a decision changes the approval state. 
   * 
   * Expected answers:
   *   code 200 : BooleanBulkApiResponse (A successful response indicating that at least one price recommendation approval decision has been applied.  Notes: - The response array preserves the order of the input request array. - An individual price decision might not be processed if:   - Multiple decisions for the same product are included in a single request: **none** of those decisions     will be processed, as it is ambiguous which decision should apply.   - The corresponding price recommendation approval is already processed (i.e., not in the 'pending' status).   - The user has already submitted an active decision (not superseded) for that approval. )
   *   code 400 : ApiErrorResponse (The request could not be processed due to validation errors in the provided body, or none of the pricing decisions could be applied.  Common issues include: - Malformed JSON. - The decision 'overwritten' is provided for a product, but the overwrite price is missing. - A decision other than 'overwritten' is provided for a product, but the overwrite price is provided. - An overwrite price lower than 0.01 is provided. - An unsupported decision is provided (only 'approved', 'rejected', and 'overwritten' are supported). - All price recommendation approvals in the request have been already processed   (e.g., previously approved, rejected, overwritten, or outdated). - The user has already submitted decisions for all provided price recommendation approvals. )
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId Unique identifier of the contract
   * @param postPriceRecommendationApprovalRequestV3 The request body contains a list of price decisions to process. 
   */
  def decidePriceRecommendationsApprovalsV3(contractId: String, postPriceRecommendationApprovalRequestV3: Seq[PostPriceRecommendationApprovalRequestV3])(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[BooleanBulkApiResponse] =
{
    var r = basicRequest
      .method(Method.POST, uri"$baseUrl/api/v3/vendor/contracts/${contractId}/pricerecommendations/approvals/decide")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(postPriceRecommendationApprovalRequestV3)
      r.response(asJson[BooleanBulkApiResponse])
}

  /**
   * Expected answers:
   *   code 200 : Any (Delete all strategy versions per provided contract)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId Unique identifier of the contract
   */
  def deleteRepricingStrategyVendorV2(contractId: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.DELETE, uri"$baseUrl/api/2/v/contracts/${contractId}/settings/repricingstrategy")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * Retrieves all price recommendations for a contract within the specified time range.  This endpoint returns algorithmic pricing recommendations based on market analysis, competitor pricing, and configured pricing strategies. Only the most recent recommendations are returned when multiple recommendations exist for the same product.  **Key Features:** - Paginated results for efficient data retrieval - Optional product tag inclusion - Configurable time range filtering - Real-time market-based recommendations 
   * 
   * Expected answers:
   *   code 200 : GetPriceRecommendationApiResponse (Paginated list of price recommendations for the specified time range.  Each recommendation includes the product information, recommended price, delivery costs, position data, and strategy information that determined the recommendation. Only the newest recommendations are returned when multiple exist for the same product. )
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId Unique identifier of the contract
   * @param startTime **Start of time range** for price recommendation retrieval.  Format: ISO 8601 date-time in UTC (e.g., `2024-01-15T10:30:00Z`) 
   * @param endTime **End of time range** for price recommendation retrieval.  Format: ISO 8601 date-time in UTC (e.g., `2024-01-16T10:30:00Z`) 
   * @param start Starting index for pagination (0-based)
   * @param limit Maximum number of price recommendations to return per page
   * @param includeTags Whether to include product tags in the response
   */
  def getPriceRecommendation(contractId: String, startTime: OffsetDateTime, endTime: OffsetDateTime, start: Int, limit: Option[Int] = None, includeTags: Option[Boolean] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[GetPriceRecommendationApiResponse] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/2/v/contracts/${contractId}/result/pricerecommendations?startTime=$startTime&endTime=$endTime&start=$start&limit=$limit&includeTags=$includeTags")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[GetPriceRecommendationApiResponse])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId Unique identifier of the contract
   * @param startTime 
   * @param endTime 
   * @param maxPositions 
   */
  def getPriceRecommendationStatsVendorV2(contractId: String, startTime: OffsetDateTime, endTime: OffsetDateTime, maxPositions: Int)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/2/v/contracts/${contractId}/result/pricerecommendationstats?startTime=$startTime&endTime=$endTime&maxPositions=$maxPositions")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : GetPriceRecommendationsResponse (No response was specified)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId Unique identifier of the contract
   * @param start Where to start fetching the recommendations
   * @param limit Maximal number of results
   * @param since Timestamp of the oldest results
   */
  def getPriceRecommendations(contractId: String, start: Option[Int] = None, limit: Option[Int] = None, since: Option[OffsetDateTime] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[GetPriceRecommendationsResponse] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/1/${contractId}/products/analysis/pricerecommendations?start=$start&limit=$limit&since=$since")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[GetPriceRecommendationsResponse])
}

  /**
   * This endpoint returns all price recommendations for one product within a given time range.
   * 
   * Expected answers:
   *   code 200 : GetPriceRecommendationHistoryApiResponse (A list of price recommendations)
   *   code 400 : ApiErrorResponse (E.g. when the time range spans more than 48h.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId Unique identifier of the contract
   * @param productId Internal product identifier in the pricemonitor system
   * @param startDate **Start of time range** for data retrieval.  Format: ISO 8601 date-time in UTC (e.g., `2024-01-15T10:30:00Z`)  **Default behavior:** - If omitted and `endDate` is provided: `startDate` = `endDate` - 48 hours - If both omitted: range is `NOW - 48 hours` to `NOW` 
   * @param endDate **End of time range** for data retrieval.  Format: ISO 8601 date-time in UTC (e.g., `2024-01-16T10:30:00Z`)  **Default behavior:** - If omitted and `startDate` is provided: `endDate` = `startDate` + 48 hours - If both omitted: range is `NOW - 48 hours` to `NOW` 
   */
  def getProductPriceRecommendationHistory(contractId: String, productId: String, startDate: Option[OffsetDateTime] = None, endDate: Option[OffsetDateTime] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[GetPriceRecommendationHistoryApiResponse] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/v3/vendor/contracts/${contractId}/products/${productId}/pricerecommendationhistory?startDate=$startDate&endDate=$endDate")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[GetPriceRecommendationHistoryApiResponse])
}

  /**
   * Expected answers:
   *   code 200 : Any (In case a document version is provided, get that strategy version. Otherwise get latest strategy for this contract.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId Unique identifier of the contract
   * @param documentVersion 
   */
  def getRepricingStrategyVendorV2(contractId: String, documentVersion: Option[Int] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/2/v/contracts/${contractId}/settings/repricingstrategy?documentVersion=$documentVersion")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId 
   */
  def getTimeStamps(contractId: Long)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/1/${contractId}/products/analysis/timestamps")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : Any (Save a new strategy version)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId Unique identifier of the contract
   * @param body This is a generated entry and needs to be described.
   */
  def putRepricingStrategyVendorV2(contractId: String, body: Option[Any] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.PUT, uri"$baseUrl/api/2/v/contracts/${contractId}/settings/repricingstrategy")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(body)
      r.response(asJson[Any])
}

  /**
   * This endpoint queries price recommendation approvals for a specified set of filters.  Use cases include: - Retrieving pending price recommendation approvals. - Auditing historic pricing decisions.  Note: *Approval* refers to the price approval flow concept in our business processes, covering all states of price recommendations within this flow (e.g., pending, approved, rejected). The term does not mean all price recommendations are approved. 
   * 
   * Expected answers:
   *   code 200 : QueryPriceRecommendationsApprovalsV3ApiResponse (A successful response containing a list of price approval meta information and associated price recommendations. )
   *   code 400 : ApiErrorResponse (The request could not be processed due to validation errors in the provided body. Common issues include:  - Malformed JSON. - Invalid time range provided. - Invalid pagination parameters. - Invalid approval status values provided. )
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId Unique identifier of the contract
   * @param priceRecommendationsApprovalQueryRequestV3 The request body contains all necessary filters to query the desired price recommendation approvals. 
   */
  def queryPriceRecommendationsApprovalsV3(contractId: String, priceRecommendationsApprovalQueryRequestV3: PriceRecommendationsApprovalQueryRequestV3)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[QueryPriceRecommendationsApprovalsV3ApiResponse] =
{
    var r = basicRequest
      .method(Method.POST, uri"$baseUrl/api/v3/vendor/contracts/${contractId}/pricerecommendations/approvals/query")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(priceRecommendationsApprovalQueryRequestV3)
      r.response(asJson[QueryPriceRecommendationsApprovalsV3ApiResponse])
}

  /**
   * This endpoint is used to query certain price recommendations. It supports a rather complex filtering structure. Most commonly it's used for querying by our internal product id.  Here you can find an example request body for querying one product id (here `123456`):  <details> <summary>Click to expand</summary>  ``` json {   \"pagination\": {     \"start\": 0,     \"limit\": 500   },   \"range\": {     \"start\": \"2023-01-07T12:05:01.000Z\",     \"end\": \"2023-01-09T12:05:01.000Z\"   },   \"filter\": {     \"filters\": [{       \"left\": {         \"attributeName\": \"productId\",         \"type\": \"StringValueProvider\"       },       \"right\": {         \"value\": \"123456\",         \"type\": \"StringConstantValueProvider\"       },       \"comparison\": {         \"type\": \"StringEquality\"       },       \"type\": \"ComparisonFilter\"     }],     \"type\": \"OrFilter\"   } } ``` </details>  If you want to query for multiple product ids, then you need to provide one object per product id in the filters-array.  It's recommended to query for at most 1000 price recommendations at once.
   * 
   * Expected answers:
   *   code 200 : QueryPriceRecommendationsV2ApiResponse (A paginated list of price recommendations is returned for the specified timerange. <br> Only the newest price recommendations are returned in case of multiple price recommendations per product. )
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId Unique identifier of the contract
   * @param priceRecommendationApiQueryV2 The request body specifies which price recommendations will be searched for.
   */
  def queryPriceRecommendationsVendorV2(contractId: String, priceRecommendationApiQueryV2: Option[PriceRecommendationApiQueryV2] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[QueryPriceRecommendationsV2ApiResponse] =
{
    var r = basicRequest
      .method(Method.POST, uri"$baseUrl/api/2/v/contracts/${contractId}/result/pricerecommendations/query")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(priceRecommendationApiQueryV2)
      r.response(asJson[QueryPriceRecommendationsV2ApiResponse])
}

  /**
   * This endpoint simulates price recommendations for a specified set of products. It is useful for:  - Explaining why certain price recommendations have been calculated. - Testing and evaluating pricing strategies before applying them.  The simulation process can be customized by including parameters such as a custom pricing strategy, custom time range, specific offers and more.  A maximum of 10 price recommendation simulations may be included in one request. 
   * 
   * Expected answers:
   *   code 200 : SimulatePriceCalculationBulkV3ApiResponse (A successful response containing a bulk result with simulated price recommendations for multiple products. )
   *   code 400 : ApiErrorResponse (The request could not be processed due to validation errors in the provided body. Common issues include:  - Malformed JSON. - Unimported products specified in the request. - Too many simulation requests in the body. - Contract not compatible with simulation feature. )
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId Unique identifier of the contract
   * @param priceSimulationBulkRequestV3 The request body contains all the necessary data to simulate price recommendations for multiple products. Custom parameters, such as pricing strategies and time ranges, can be provided in order to simulate different scenarios. 
   */
  def simulatePriceRecommendationsV3(contractId: String, priceSimulationBulkRequestV3: PriceSimulationBulkRequestV3)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[SimulatePriceCalculationBulkV3ApiResponse] =
{
    var r = basicRequest
      .method(Method.POST, uri"$baseUrl/api/v3/vendor/contracts/${contractId}/pricerecommendations/simulate")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(priceSimulationBulkRequestV3)
      r.response(asJson[SimulatePriceCalculationBulkV3ApiResponse])
}

}

