/**
 * Omnia 2.0 API The Omnia 2.0 API is RESTful and provides access to the backend of Omnia 2.0 and Pricemonitor. It is used to manage products, offers, contracts and more.
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.0.6878
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
package com.patagona.pricemonitor.client.api

import com.patagona.pricemonitor.client.model.AmazonBuyboxProductStatsV3ApiResponse
import com.patagona.pricemonitor.client.model.AndOfferFilter
import com.patagona.pricemonitor.client.model.ApiError
import com.patagona.pricemonitor.client.model.ApiErrorResponse
import com.patagona.pricemonitor.client.model.ApiQuery
import com.patagona.pricemonitor.client.model.BulkedPostProductsApiResponse
import com.patagona.pricemonitor.client.model.DeleteProductsApiResponse
import com.patagona.pricemonitor.client.model.EmptyApiResponse
import com.patagona.pricemonitor.client.model.GetExtendedTagsApiResponse
import com.patagona.pricemonitor.client.model.GetPriceRecommendationHistoryApiResponse
import com.patagona.pricemonitor.client.model.GetProductMonitoringStatusStatsVendorV3ApiResponse
import com.patagona.pricemonitor.client.model.GetProductMonitoringStatusVendorV3ApiResponse
import com.patagona.pricemonitor.client.model.GetProductPropertiesV3ApiResponse
import com.patagona.pricemonitor.client.model.OfferFilterApiResponse
import java.time.OffsetDateTime
import com.patagona.pricemonitor.client.model.PostOfferStatisticsApiResponse
import com.patagona.pricemonitor.client.model.PostOfferStatisticsRequest
import com.patagona.pricemonitor.client.model.PostProductsRequest
import com.patagona.pricemonitor.client.model.PriceDumpingStatsRequest
import com.patagona.pricemonitor.client.model.Product
import com.patagona.pricemonitor.client.model.PutProductPropertiesRequestV3
import com.patagona.pricemonitor.client.model.PutProductsApiResponse
import com.patagona.pricemonitor.client.model.QueryOffersOfShopRequestV3
import com.patagona.pricemonitor.client.model.QueryOffersOfShopV3ApiResponse
import com.patagona.pricemonitor.client.model.QueryPriceDumpingStatsApiResponse
import com.patagona.pricemonitor.client.model.QueryProductsByFilterManufacturerV3ApiResponse
import com.patagona.pricemonitor.client.model.QueryProductsByFilterVendorV3ApiResponse
import com.patagona.pricemonitor.client.model.QueryProductsManufacturerV3ApiResponse
import com.patagona.pricemonitor.client.model.QueryProductsRequestV3
import com.patagona.pricemonitor.client.model.QueryProductsVendorV3ApiResponse
import com.patagona.pricemonitor.client.model.StringArrayResponse
import com.patagona.pricemonitor.client.model.TaskIdAndUrl
import com.patagona.pricemonitor.client.core._
import alias._
import sttp.client._
import sttp.model.Method

object ProductsApi {

  def apply(baseUrl: String = "https://api.patagona.de")(implicit serializer: SttpSerializer) = new ProductsApi(baseUrl)
}

class ProductsApi(baseUrl: String)(implicit serializer: SttpSerializer) {

  import Helpers._
  import serializer._

  /**
   * Delete all products or delete products by a last updated timestamp.
   * 
   * Expected answers:
   *   code 200 : DeleteProductsApiResponse (Returns the number of deleted products.)
   *   code 400 : ApiErrorResponse (Tags specified for deleting products are specified partially (either tagKey or tagValue is provided). )
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param updatedMax Last updated timestamp of products, formatted as ISO Date (i.e. 2019-11-20T13:46:13Z) in UTC.<br> Products can be deleted which haven't been updated since the specified timestamp.<br> If the query parameter is missing all products are deleted.
   * @param tagKey Tag key to consider for deleting products. This parameter works in combination with tagValue.
   * @param tagValue Tag value to consider for deleting products. This parameter works in combination with tagKey.
   */
  def deleteProducts(contractId: String, updatedMax: Option[OffsetDateTime] = None, tagKey: Option[String] = None, tagValue: Option[String] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[DeleteProductsApiResponse] =
{
    var r = basicRequest
      .method(Method.DELETE, uri"$baseUrl/api/v3/vendor/contracts/${contractId}/products?updatedMax=$updatedMax&tagKey=$tagKey&tagValue=$tagValue")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[DeleteProductsApiResponse])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param updatedMax 
   */
  def deleteProductsManufacturerV3(contractId: String, updatedMax: Option[OffsetDateTime] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.DELETE, uri"$baseUrl/api/v3/manufacturer/contracts/${contractId}/products?updatedMax=$updatedMax")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * Provides latest Amazon Buy Box statistics, i.e., whether a - product is in Amazon Buy Box for Prime users - product is in Amazon Buy Box for Non-Prime users per product per Amazon domain for a given time range. 
   * 
   * Expected answers:
   *   code 200 : AmazonBuyboxProductStatsV3ApiResponse (List of Amazon Buybox statistics per product)
   *   code 400 : ApiErrorResponse (Returned if: - The request body is not a valid JSON string. - The start date is after the end date. - The time range [startDate,endDate] is larger than 48h. - The start parameter is negative - The limit parameter is negative and larger than 50,000 - The contract has more than one amazon domain configured. )
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param startDate Timestamp of start of time range, formatted as ISO Date (i.e. 2018-04-06T13:46:13Z) in UTC. If this value is omitted and {endDate} is given, {startDate} is set to {endDate} - 48 hours. If both values are omitted, the range is 'NOW - 48 hours to NOW'.
   * @param endDate Timestamp of end of time range, formatted as ISO Date (i.e. 2018-04-06T13:46:13Z) in UTC. If this value is omitted and {startDate} is given, {endDate} is set to {startDate} + 48 hours. If both values are omitted, the range is 'NOW - 48 hours to NOW'.
   * @param start Where to start fetching the Amazon Buy Box statistics. Must be positive. Default value is 0.
   * @param limit Maximum number of results. Must be positive and not bigger than 50,000. Default value is 50,000.
   */
  def getAmazonBuyboxProductStatsV3(contractId: String, startDate: Option[OffsetDateTime] = None, endDate: Option[OffsetDateTime] = None, start: Option[Int] = None, limit: Option[Int] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[AmazonBuyboxProductStatsV3ApiResponse] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/v3/vendor/contracts/${contractId}/products/amazon/buybox/stats?startDate=$startDate&endDate=$endDate&start=$start&limit=$limit")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[AmazonBuyboxProductStatsV3ApiResponse])
}

  /**
   * Expected answers:
   *   code 200 : GetExtendedTagsApiResponse (Returns a list of ExtendedTags for the given product.)
   *   code 404 : ApiErrorResponse (Given product does not exist.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param productId ID of the product
   */
  def getExtendedTags(contractId: String, productId: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[GetExtendedTagsApiResponse] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/v3/vendor/contracts/${contractId}/products/${productId}/extendedtags")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[GetExtendedTagsApiResponse])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param productId 
   */
  def getExtendedTagsManufacturerV3(contractId: String, productId: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/v3/manufacturer/contracts/${contractId}/products/${productId}/extendedtags")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param inputType 
   * @param identifiers 
   */
  def getMappingsVendorV2(contractId: String, inputType: String, identifiers: Seq[String])(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/2/v/contracts/${contractId}/productidentifiermapping?inputType=$inputType&identifiers=$identifiers")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : OfferFilterApiResponse (List of the filters to ignore the individual offers.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param listType 
   * @param productId 
   */
  def getProductFiltersVendorV2(contractId: String, listType: String, productId: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[OfferFilterApiResponse] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/2/v/contracts/${contractId}/offerfilters/${listType}/products/${productId}")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[OfferFilterApiResponse])
}

  /**
   * Expected answers:
   *   code 200 : GetProductMonitoringStatusStatsVendorV3ApiResponse (Contains the monitoring status stats per domain)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   */
  def getProductMonitoringStatusStatsVendorV3(contractId: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[GetProductMonitoringStatusStatsVendorV3ApiResponse] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/v3/vendor/contracts/${contractId}/products/monitoringstatus/stats")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[GetProductMonitoringStatusStatsVendorV3ApiResponse])
}

  /**
   * Expected answers:
   *   code 200 : GetProductMonitoringStatusVendorV3ApiResponse (Monitoring status of the queried products)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param productIds The product ids for which the monitoring state should be returned
   */
  def getProductMonitoringStatusVendorV3(contractId: String, productIds: Set[Int])(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[GetProductMonitoringStatusVendorV3ApiResponse] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/v3/vendor/contracts/${contractId}/products/monitoringstatus?productIds=$productIds")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[GetProductMonitoringStatusVendorV3ApiResponse])
}

  /**
   * This endpoint returns all price recommendations for one product within a given time range.
   * 
   * Expected answers:
   *   code 200 : GetPriceRecommendationHistoryApiResponse (A list of price recommendations)
   *   code 400 : ApiErrorResponse (E.g. when the time range spans more than 48h.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param productId ID of the product in pricemonitor
   * @param startDate Timestamp of start of time range, formatted as ISO Date (i.e. 2018-04-06T13:46:13Z) in UTC. If this value is omitted and {endDate} is given, {startDate} is set to {endDate} - 48 hours. If both values are omitted, the range is 'NOW - 48 hours to NOW'.
   * @param endDate Timestamp of end of time range, formatted as ISO Date (i.e. 2018-04-06T13:46:13Z) in UTC. If this value is omitted and {startDate} is given, {endDate} is set to {startDate} + 48 hours. If both values are omitted, the range is 'NOW - 48 hours to NOW'.
   */
  def getProductPriceRecommendationHistory(contractId: String, productId: String, startDate: Option[OffsetDateTime] = None, endDate: Option[OffsetDateTime] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[GetPriceRecommendationHistoryApiResponse] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/v3/vendor/contracts/${contractId}/products/${productId}/pricerecommendationhistory?startDate=$startDate&endDate=$endDate")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[GetPriceRecommendationHistoryApiResponse])
}

  /**
   * This endpoint returns a list product properties for a certain product and contract. Product properties represent additional information for a product, independent of the imported products and tags.
   * 
   * Expected answers:
   *   code 200 : GetProductPropertiesV3ApiResponse (A list of product properties)
   *   code 404 : ApiErrorResponse (Returned if the product does not exist.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param productId ID of the product (Omnia's internal product id)
   */
  def getProductPropertiesV3(contractId: String, productId: Long)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[GetProductPropertiesV3ApiResponse] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/v3/vendor/contracts/${contractId}/products/${productId}/properties")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[GetProductPropertiesV3ApiResponse])
}

  /**
   * This endpoint returns a list of distinct product property keys for all imported products of a contract.
   * 
   * Expected answers:
   *   code 200 : StringArrayResponse (A list of distinct keys of all product properties.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   */
  def getProductPropertyKeysV3(contractId: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[StringArrayResponse] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/v3/vendor/contracts/${contractId}/products/properties/keys")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[StringArrayResponse])
}

  /**
   * Gets all products for a contract. Does not support pagination.
   * 
   * Expected answers:
   *   code 200 : Set[Product] (No response was specified)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param attributes Query string to filter products
   */
  def getProducts(contractId: String, attributes: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Set[Product]] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/2/v/contracts/${contractId}/products?attributes=$attributes")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Set[Product]])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param key 
   */
  def getTagValuesManufacturerV2(contractId: String, key: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/2/m/contracts/${contractId}/products/tags/${key}")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param key 
   */
  def getTagValuesVendorV2(contractId: String, key: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/2/v/contracts/${contractId}/products/tags/${key}")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   */
  def getTagsManufacturerV2(contractId: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/2/m/contracts/${contractId}/products/tags")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   */
  def getTagsVendorV2(contractId: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.GET, uri"$baseUrl/api/2/v/contracts/${contractId}/products/tags")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param body This is a generated entry and needs to be described.
   */
  def monitoringPipelineUpsertSearchAttemptsManufacturerV3(contractId: String, body: Option[Any] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.POST, uri"$baseUrl/api/v3/manufacturer/contracts/${contractId}/monitoringpipeline/v1/searchattempts")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(body)
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param body This is a generated entry and needs to be described.
   */
  def monitoringPipelineUpsertSearchAttemptsVendorV3(contractId: String, body: Option[Any] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.POST, uri"$baseUrl/api/v3/vendor/contracts/${contractId}/monitoringpipeline/v1/searchattempts")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(body)
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param productId 
   * @param body This is a generated entry and needs to be described.
   */
  def patchProductManufacturerV3(contractId: String, productId: String, body: Option[Any] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.PATCH, uri"$baseUrl/api/v3/manufacturer/contracts/${contractId}/products/${productId}")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(body)
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param productId 
   * @param body This is a generated entry and needs to be described.
   */
  def patchProductVendorV3(contractId: String, productId: String, body: Option[Any] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.PATCH, uri"$baseUrl/api/v3/vendor/contracts/${contractId}/products/${productId}")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(body)
      r.response(asJson[Any])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param body This is a generated entry and needs to be described.
   */
  def postMappingsVendorV2(contractId: String, body: Option[Any] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.POST, uri"$baseUrl/api/2/v/contracts/${contractId}/productidentifiermapping")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(body)
      r.response(asJson[Any])
}

  /**
   * This operation is used to get offer statistics (e.g. offer count, average price) grouped by product and domain.  Warning: This endpoint contains complex filter structure and will be replaced in the future. Currently, we only allow filtering by a list of internal pricemonitor product ids. Please note that offer statistics can only be computed for at **maximum 2500** products at a time.  To use the example request body from below, you have to adjust the `ownShopNames`, the `range` and `filter.right.value`. Where `filter.right.value` has to be a list of internal pricemonitor product ids corresponding to the `contractId` provided as part of the URL.  All prices will be with or without delivery costs depending on the `includeDeliveryCosts` parameter in the body. 
   * 
   * Expected answers:
   *   code 200 : PostOfferStatisticsApiResponse (Returns a list of offer statistics per product. ## How to use this endpoint's result to get Total Market statistics ### Minimum Price To calculate the minimum price in the total market, you have to take the minimum of the `minPrice` of each domain. In the example below, both products have the same min prices: `min(16.00,7.99) = 7.99`. ### Average Price To calculate the average price in the total market, you have to calculate a **weighted average**, weighing the average price of each domain by its offer count. In the example below we get different results for the average price in the total market for product id `1001` and `1002` even though they have the same average price in each domain. This is due to the different offer counts:    - product id `1001`: `(20.00 * 4 + 10.00 * 12) / (4 + 12) = 12.50`   - product id `1002`: `(20.00 * 12 + 10.00 * 4) / (12 + 4) = 17.50`  ### Offer Count The offer count of one product in the total market is the sum of the offer counts for all its domains. In the example below, both products would have an offer count of `12 + 4 = 16`. ### Market Position The market position of a product generally **can not be deduced** from the data provided in this endpoint. )
   *   code 400 : ApiError (Returned in case of unparsable request body JSON or unsupported filter.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param postOfferStatisticsRequest 
   */
  def postOfferStatisticsVendorQuery(contractId: String, postOfferStatisticsRequest: PostOfferStatisticsRequest)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[PostOfferStatisticsApiResponse] =
{
    var r = basicRequest
      .method(Method.POST, uri"$baseUrl/api/v3/vendor/contracts/${contractId}/offers/stats/query")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(postOfferStatisticsRequest)
      r.response(asJson[PostOfferStatisticsApiResponse])
}

  /**
   * This operation is used to import products into the system from JSON formatted data:<br> Products that are already present will be updated and new products will be added. Identification of the products is done based on the identifying attributes, which need to be provided via the request body.<br><br>Note:<br> This endpoint should be used in conjunction with: DELETE  /api/v3/vendor/contracts/{contractId}/products.<br><br> Procedure:<br> 1. Add your products in bulks with multiple requests via this endpoint.<br> 2. Send a DELETE request to /api/v3/vendor/contracts/{contractId}/products    and set the parameter updatedMax to a date which is older or equal to your first request from step 1.
   * 
   * Expected answers:
   *   code 200 : BulkedPostProductsApiResponse (The response provides sorted import results in respective to the order of the provided products.)
   *   code 400 : ApiErrorResponse (Unable to add products because of invalid request data)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param contentType 
   * @param patagonaTagsDecimalSeparator The decimal separator is used for parsing numbers in tags. English and German number formats are supported: dot and comma.
   * @param postProductsRequest The body contains the products which should be added
   */
  def postProductsImportVendorV3(contractId: String, contentType: String, patagonaTagsDecimalSeparator: String, postProductsRequest: PostProductsRequest)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[BulkedPostProductsApiResponse] =
{
    var r = basicRequest
      .method(Method.POST, uri"$baseUrl/api/v3/vendor/contracts/${contractId}/products")
      .contentType("application/json")
      .header("content-type", contentType)
      .header("patagona-tags-decimal-separator", patagonaTagsDecimalSeparator)
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(postProductsRequest)
      r.response(asJson[BulkedPostProductsApiResponse])
}

  /**
   * Warning: Deletes all existing products.         <br/>Note that this will not happen immediately. Instead, you receive the ID of a task that has been created.         <br/>Furthermore you receive an URL which you can use to check if the task was executed successfully.         <br>The csv file must contain following columns:         <ul>           <li>productId - arbitrary string, can be used for the systems product id.</li>           <li>gtin - the GTIN of the product           <li>description - name or short description of the product           <li>referencePrice - arbitrary decimal number, usually the current price or recommended retail price (gross)           <li>minPriceBoundary - decimal number defining the lower price boundary (gross)           <li>maxPriceBoundary - decimal number defining the upper price boundary (gross)           <li>Additional columns are added as product tags. Tags are used for repricing strategies and several other           purpose.         </ul>         <br/>Column separator must be semicolon, the decimal separator must be dot. File encoding must be UTF-8.
   * 
   * Expected answers:
   *   code 200 :  (-)
   *   code 202 : TaskIdAndUrl (Accepted)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param body CSV file containing the products
   */
  def putCSVProducts(contractId: String, body: String)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Unit] =
{
    var r = basicRequest
      .method(Method.PUT, uri"$baseUrl/api/2/v/contracts/${contractId}/products/csv")
      .contentType("text/csv")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(body)
      r.response(asJson[Unit])
}

  /**
   * This operation is used to import products into the pricemonitor. This process is represented by a task, which is processed asynchronously. In the response you will receive a url which is used to check the status of the import process. <br>  When the process is done all products in csv file from the request body will be in the pricemonitor. Products that were already present before have been updated and new products have been added. <br>  Warning: All products that were in the pricemonitor before but are not present in the new import will be deleted.  Identification of the products is done based on the identifying attributes (see parameter: patagona-product-identifying-attributes)'
   * 
   * Expected answers:
   *   code 202 : PutProductsApiResponse (The field data.url in the returned object allows to check the status of the import process. It will point to the endpoint GET /api/2/v/contracts/{contractId}/tasks/{taskId}. \\ The field data.id is the task id corresponding to the product import.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param contentType 
   * @param patagonaProductIdentifyingAttributes Comma separated list of csv columns that identify a product uniquely
   * @param patagonaProductName Csv column that contains the product name
   * @param patagonaProductReferencePrice Csv column that contains the reference price
   * @param patagonaDecimalSeparator Decimal separator used for parsing numbers \\ The values for patagona-decimal-separator, patagona-csv-column-separator and patagona-csv-quotation-character must be different from one another. \\ Available values: \",\", \".\"
   * @param patagonaCsvColumnSeparator The csv column separator \\ The values for patagona-decimal-separator, patagona-csv-column-separator and patagona-csv-quotation-character must be different from one another.
   * @param patagonaCsvQuotationCharacter The csv quotation character \\ The values for patagona-decimal-separator, patagona-csv-column-separator and patagona-csv-quotation-character must be different from one another.
   * @param body CSV file containing the products. Note: The CSV file should be encoded in UTF-8.
   * @param patagonaProductGtin Csv column that contains the gtin
   * @param patagonaProductCustomerId Csv column that contains an id (There is no requirement for this field to be unique)
   */
  def putCSVProductsManufacturerV3(contractId: String, contentType: String, patagonaProductIdentifyingAttributes: String, patagonaProductName: String, patagonaProductReferencePrice: String, patagonaDecimalSeparator: String, patagonaCsvColumnSeparator: String, patagonaCsvQuotationCharacter: String, body: String, patagonaProductGtin: Option[String] = None, patagonaProductCustomerId: Option[String] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[PutProductsApiResponse] =
{
    var r = basicRequest
      .method(Method.PUT, uri"$baseUrl/api/v3/manufacturer/contracts/${contractId}/products")
      .contentType("text/csv")
      .header("content-type", contentType)
      .header("patagona-product-identifying-attributes", patagonaProductIdentifyingAttributes)
      .header("patagona-product-name", patagonaProductName)
      .header("patagona-product-reference-price", patagonaProductReferencePrice)
      .header("patagona-product-gtin", patagonaProductGtin)
      .header("patagona-product-customer-id", patagonaProductCustomerId)
      .header("patagona-decimal-separator", patagonaDecimalSeparator)
      .header("patagona-csv-column-separator", patagonaCsvColumnSeparator)
      .header("patagona-csv-quotation-character", patagonaCsvQuotationCharacter)
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(body)
      r.response(asJson[PutProductsApiResponse])
}

  /**
   * Expected answers:
   *   code 200 : OfferFilterApiResponse (List of the filters that have been sent as the request body.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param listType 
   * @param productId 
   * @param andOfferFilter List of the filter that needs to be considered to ignore the individual offers.
   */
  def putProductFiltersVendorV2(contractId: String, listType: String, productId: String, andOfferFilter: Seq[AndOfferFilter])(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[OfferFilterApiResponse] =
{
    var r = basicRequest
      .method(Method.PUT, uri"$baseUrl/api/2/v/contracts/${contractId}/offerfilters/${listType}/products/${productId}")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(andOfferFilter)
      r.response(asJson[OfferFilterApiResponse])
}

  /**
   * This endpoint allows creating, updating, or deleting product properties for a certain product and contract. For deleting product properties, it's sufficient to provide an empty list of product properties. When providing dates, please use the ISO 8601 format. When providing numbers, please use dot as decimal separator.  Product properties represent additional information for a product, independent of imported products and tags. 
   * 
   * Expected answers:
   *   code 200 : EmptyApiResponse (The product properties have been stored successfully for the product.)
   *   code 400 : ApiErrorResponse (Returned if the request body is invalid: - The request body is not a valid JSON string. - The provided product properties contain duplicated keys. - The provided product properties contain an empty key. - The provided product properties contain a key which is too long. - The provided product properties contain a value which is too long. )
   *   code 404 : ApiErrorResponse (Returned if the product does not exist.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param productId ID of the product (Omnia's internal product id)
   * @param putProductPropertiesRequestV3 
   */
  def putProductPropertiesV3(contractId: String, productId: Long, putProductPropertiesRequestV3: PutProductPropertiesRequestV3)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[EmptyApiResponse] =
{
    var r = basicRequest
      .method(Method.PUT, uri"$baseUrl/api/v3/vendor/contracts/${contractId}/products/${productId}/properties")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(putProductPropertiesRequestV3)
      r.response(asJson[EmptyApiResponse])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param body This is a generated entry and needs to be described.
   */
  def putProductsCSVManufacturerV2(contractId: String, body: Option[Any] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.PUT, uri"$baseUrl/api/2/m/contracts/${contractId}/products/csv")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(body)
      r.response(asJson[Any])
}

  /**
   * This operation is used to import products into the system from CSV formatted data. This process is represented by a task, which is processed asynchronously. In the response you will receive a url which is used to check the status of the import process. <br>  When the process is done all products in csv file from the request body will be in the pricemonitor. Products that were already present before have been updated and new products have been added. <br>  Warning: All products that were in the pricemonitor before but are not present in the new import will be deleted.  Identification of the products is done based on the identifying attributes (see parameter: patagona-product-identifying-attributes)  Note: It is recommended to use the JSON variant to add products as it works synchronously and more efficient.
   * 
   * Expected answers:
   *   code 202 : PutProductsApiResponse (The field data.url in the returned object allows to check the status of the import process. It will point to the endpoint GET /api/2/v/contracts/{contractId}/tasks/{taskId}. \\ The field data.id is the task id corresponding to the product import.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param contentType 
   * @param patagonaProductIdentifyingAttributes Comma separated list of csv columns that identify a product uniquely
   * @param patagonaProductName Csv column that contains the product name
   * @param patagonaProductReferencePrice Csv column that contains the reference price
   * @param patagonaProductMinPrice Csv column that contains the min price
   * @param patagonaProductMaxPrice Csv column that contains the max price
   * @param patagonaDecimalSeparator Decimal separator used for parsing numbers \\ The values for patagona-decimal-separator, patagona-csv-column-separator and patagona-csv-quotation-character must be different from one another. \\ Available values: \",\", \".\"
   * @param patagonaCsvColumnSeparator The csv column separator \\ It can be provided either as text or as Base64 encoded string (e.g. needed for tab as separator). \\ The values for patagona-decimal-separator, patagona-csv-column-separator and patagona-csv-quotation-character must be different from one another.
   * @param patagonaCsvQuotationCharacter The csv quotation character \\ The values for patagona-decimal-separator, patagona-csv-column-separator and patagona-csv-quotation-character must be different from one another.
   * @param body CSV file containing the products. Note: The CSV file should be encoded in UTF-8.
   * @param patagonaProductGtin Csv column that contains the gtin
   * @param patagonaProductCustomerId Csv column that contains an id (There is no requirement for this field to be unique)
   */
  def putProductsImportVendorV3(contractId: String, contentType: String, patagonaProductIdentifyingAttributes: String, patagonaProductName: String, patagonaProductReferencePrice: String, patagonaProductMinPrice: String, patagonaProductMaxPrice: String, patagonaDecimalSeparator: String, patagonaCsvColumnSeparator: String, patagonaCsvQuotationCharacter: String, body: String, patagonaProductGtin: Option[String] = None, patagonaProductCustomerId: Option[String] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[PutProductsApiResponse] =
{
    var r = basicRequest
      .method(Method.PUT, uri"$baseUrl/api/v3/vendor/contracts/${contractId}/products")
      .contentType("text/csv")
      .header("content-type", contentType)
      .header("patagona-product-identifying-attributes", patagonaProductIdentifyingAttributes)
      .header("patagona-product-name", patagonaProductName)
      .header("patagona-product-reference-price", patagonaProductReferencePrice)
      .header("patagona-product-min-price", patagonaProductMinPrice)
      .header("patagona-product-max-price", patagonaProductMaxPrice)
      .header("patagona-product-gtin", patagonaProductGtin)
      .header("patagona-product-customer-id", patagonaProductCustomerId)
      .header("patagona-decimal-separator", patagonaDecimalSeparator)
      .header("patagona-csv-column-separator", patagonaCsvColumnSeparator)
      .header("patagona-csv-quotation-character", patagonaCsvQuotationCharacter)
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(body)
      r.response(asJson[PutProductsApiResponse])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param body This is a generated entry and needs to be described.
   */
  def putProductsVendorV2(contractId: String, body: Option[Any] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.PUT, uri"$baseUrl/api/2/v/contracts/${contractId}/products")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(body)
      r.response(asJson[Any])
}

  /**
   * This operation is used to query price dumping statistics for a time range for a set of shops.
   * 
   * Expected answers:
   *   code 200 : QueryPriceDumpingStatsApiResponse (Returns the price dumping statistics in the given time range.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param priceDumpingStatsRequest 
   */
  def queryOffersPriceDumpingStatsManufacturerV3(contractId: String, priceDumpingStatsRequest: PriceDumpingStatsRequest)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[QueryPriceDumpingStatsApiResponse] =
{
    var r = basicRequest
      .method(Method.POST, uri"$baseUrl/api/v3/manufacturer/contracts/${contractId}/offers/pricedumpingstats")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(priceDumpingStatsRequest)
      r.response(asJson[QueryPriceDumpingStatsApiResponse])
}

  /**
   * This operation is used to query price dumping statistics for a time range for a set of shops.
   * 
   * Expected answers:
   *   code 200 : QueryPriceDumpingStatsApiResponse (Returns the price dumping statistics in the given time range.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param priceDumpingStatsRequest 
   */
  def queryOffersPriceDumpingStatsVendorV3(contractId: String, priceDumpingStatsRequest: PriceDumpingStatsRequest)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[QueryPriceDumpingStatsApiResponse] =
{
    var r = basicRequest
      .method(Method.POST, uri"$baseUrl/api/v3/vendor/contracts/${contractId}/offers/pricedumpingstats")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(priceDumpingStatsRequest)
      r.response(asJson[QueryPriceDumpingStatsApiResponse])
}

  /**
   * Get all offers of a shop. Please note that it might return offers for inactive products.
   * 
   * Expected answers:
   *   code 200 : QueryOffersOfShopV3ApiResponse (Returns offers of the shop)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param queryOffersOfShopRequestV3 
   */
  def queryOffersShopManufacturerV3(contractId: String, queryOffersOfShopRequestV3: QueryOffersOfShopRequestV3)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[QueryOffersOfShopV3ApiResponse] =
{
    var r = basicRequest
      .method(Method.POST, uri"$baseUrl/api/v3/manufacturer/contracts/${contractId}/offers/shop/query")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(queryOffersOfShopRequestV3)
      r.response(asJson[QueryOffersOfShopV3ApiResponse])
}

  /**
   * Get all offers of a shop. Please note that it might return offers for inactive products.
   * 
   * Expected answers:
   *   code 200 : QueryOffersOfShopV3ApiResponse (Returns offers of the shop)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param queryOffersOfShopRequestV3 
   */
  def queryOffersShopVendorV3(contractId: String, queryOffersOfShopRequestV3: QueryOffersOfShopRequestV3)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[QueryOffersOfShopV3ApiResponse] =
{
    var r = basicRequest
      .method(Method.POST, uri"$baseUrl/api/v3/vendor/contracts/${contractId}/offers/shop/query")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(queryOffersOfShopRequestV3)
      r.response(asJson[QueryOffersOfShopV3ApiResponse])
}

  /**
   * This operation is used to get offer statistics (e.g. offer count, average price) grouped by product and domain. Warning: This endpoint contains complex query structure and will be replaced in the future. Please note that offer statistics can only be computed for at maximum 2500 products at a time.
   * 
   * Expected answers:
   *   code 200 : PostOfferStatisticsApiResponse (Returns a list of offer statistics per product.)
   *   code 400 : ApiError (Returned in case of unparsable request body JSON or unsupported filter.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param postOfferStatisticsRequest 
   */
  def queryOffersStatsManufacturerV3(contractId: String, postOfferStatisticsRequest: PostOfferStatisticsRequest)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[PostOfferStatisticsApiResponse] =
{
    var r = basicRequest
      .method(Method.POST, uri"$baseUrl/api/v3/manufacturer/contracts/${contractId}/offers/stats/query")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(postOfferStatisticsRequest)
      r.response(asJson[PostOfferStatisticsApiResponse])
}

  /**
   * This endpoint can be used for querying either all products or certain products by product ids.
   * 
   * Expected answers:
   *   code 200 : QueryProductsByFilterManufacturerV3ApiResponse (Returns a list of found products.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param queryProductsRequestV3 The body contains the products query.
   */
  def queryProductsByFilterManufacturerV3(contractId: String, queryProductsRequestV3: Option[QueryProductsRequestV3] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[QueryProductsByFilterManufacturerV3ApiResponse] =
{
    var r = basicRequest
      .method(Method.POST, uri"$baseUrl/api/v3/manufacturer/contracts/${contractId}/products/query")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(queryProductsRequestV3)
      r.response(asJson[QueryProductsByFilterManufacturerV3ApiResponse])
}

  /**
   * This endpoint can be used for querying either all products or certain products by product ids.
   * 
   * Expected answers:
   *   code 200 : QueryProductsByFilterVendorV3ApiResponse (Returns a list of found products.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param queryProductsRequestV3 The body contains the products query.
   */
  def queryProductsByFilterVendorV3(contractId: String, queryProductsRequestV3: Option[QueryProductsRequestV3] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[QueryProductsByFilterVendorV3ApiResponse] =
{
    var r = basicRequest
      .method(Method.POST, uri"$baseUrl/api/v3/vendor/contracts/${contractId}/products/query")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(queryProductsRequestV3)
      r.response(asJson[QueryProductsByFilterVendorV3ApiResponse])
}

  /**
   * Expected answers:
   *   code 200 : QueryProductsManufacturerV3ApiResponse (Returns a list of found products.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param apiQuery The body contains the products query. <br> Currently, it supports only product queries for two attributes:<br> <ul>   <li> by \"customerProductId\"</li>   <li> by \"productId\" (Patagona's internal product id). Allowed values for 'productId' are numerical integer values</li> </ul> The maximum allowed limit in the pagination is 10000. <br> For better performance, when paginating over all products of a contract, we recommend to use a limit of 10000 products per page. Pagination works with respective to the given products query. <br> This is most relevant when querying for a set of customerProductId's. <br> When the requests are chunked over a set of ids, it is easiest to provide up to 10000 customerProductId's in the query and keep the pagination at start: 0, limit: 10000. <br> The only allowed pattern is currently: <br> { <br> &nbsp;&nbsp;\"pagination\": { <br> &nbsp;&nbsp;&nbsp;&nbsp;\"start\": ${start}, <br> &nbsp;&nbsp;&nbsp;&nbsp;\"limit\": ${limit} <br> &nbsp;&nbsp;}, <br> &nbsp;&nbsp;\"filter\": { <br> &nbsp;&nbsp;&nbsp;&nbsp;\"oneOf\": { <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"field\": \"customerProductId\", <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"values\": [${customerProductIds as a list of strings}] <br> &nbsp;&nbsp;&nbsp;&nbsp;} <br> &nbsp;&nbsp;} <br> } <br> <br> example: <br> { <br> &nbsp;&nbsp;\"pagination\": { <br> &nbsp;&nbsp;&nbsp;&nbsp;\"start\": 0, <br> &nbsp;&nbsp;&nbsp;&nbsp;\"limit\": 10 <br> &nbsp;&nbsp;}, <br> &nbsp;&nbsp;\"filter\": { <br> &nbsp;&nbsp;\"oneOf\": { <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"field\": \"customerProductId\", <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"values\": [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\"] <br> &nbsp;&nbsp;&nbsp;&nbsp;} <br> &nbsp;&nbsp;} <br> } <br> 
   */
  def queryProductsManufacturerV3(contractId: String, apiQuery: Option[ApiQuery] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[QueryProductsManufacturerV3ApiResponse] =
{
    var r = basicRequest
      .method(Method.POST, uri"$baseUrl/api/v3.1/manufacturer/contracts/${contractId}/products/query")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(apiQuery)
      r.response(asJson[QueryProductsManufacturerV3ApiResponse])
}

  /**
   * This endpoint can be used for querying either all products or certain products by the 'customerProductId' or 'productId'.
   * 
   * Expected answers:
   *   code 200 : QueryProductsVendorV3ApiResponse (Returns a list of found products.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param apiQuery The body contains the products query. <br> Currently, it supports only product queries for two attributes:<br> <ul>   <li> by \"customerProductId\"</li>   <li> by \"productId\" (Patagona's internal product id). Allowed values for 'productId' are numerical integer values</li> </ul> The maximum allowed limit in the pagination is 10000. <br> For better performance, when paginating over all products of a contract, we recommend to use a limit of 10000 products per page. Pagination works with respective to the given products query. <br> This is most relevant when querying for a set of customerProductId's. <br> When the requests are chunked over a set of ids, it is easiest to provide up to 10000 customerProductId's in the query and keep the pagination at start: 0, limit: 10000. <br> The only allowed pattern is currently: <br> { <br> &nbsp;&nbsp;\"pagination\": { <br> &nbsp;&nbsp;&nbsp;&nbsp;\"start\": ${start}, <br> &nbsp;&nbsp;&nbsp;&nbsp;\"limit\": ${limit} <br> &nbsp;&nbsp;}, <br> &nbsp;&nbsp;\"filter\": { <br> &nbsp;&nbsp;&nbsp;&nbsp;\"oneOf\": { <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"field\": \"customerProductId\", <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"values\": [${customerProductIds as a list of strings}] <br> &nbsp;&nbsp;&nbsp;&nbsp;} <br> &nbsp;&nbsp;} <br> } <br> <br> example: <br> { <br> &nbsp;&nbsp;\"pagination\": { <br> &nbsp;&nbsp;&nbsp;&nbsp;\"start\": 0, <br> &nbsp;&nbsp;&nbsp;&nbsp;\"limit\": 10 <br> &nbsp;&nbsp;}, <br> &nbsp;&nbsp;\"filter\": { <br> &nbsp;&nbsp;\"oneOf\": { <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"field\": \"customerProductId\", <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"values\": [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\"] <br> &nbsp;&nbsp;&nbsp;&nbsp;} <br> &nbsp;&nbsp;} <br> } <br> 
   */
  def queryProductsVendorV3(contractId: String, apiQuery: Option[ApiQuery] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[QueryProductsVendorV3ApiResponse] =
{
    var r = basicRequest
      .method(Method.POST, uri"$baseUrl/api/v3.1/vendor/contracts/${contractId}/products/query")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(apiQuery)
      r.response(asJson[QueryProductsVendorV3ApiResponse])
}

  /**
   * Expected answers:
   *   code 200 : Any (This is a generated entry and needs to be described.)
   * 
   * Available security schemes:
   *   BasicAuth (http)
   *   BearerAuth (http)
   * 
   * @param contractId ID of the contract
   * @param path 
   * @param body This is a generated entry and needs to be described.
   */
  def shopIntegrationPostRequestVendorV2(contractId: String, path: String, body: Option[Any] = None)(implicit basicAuth: Option[BasicCredentials], bearerToken: Option[BearerToken]): ApiRequestT[Any] =
{
    var r = basicRequest
      .method(Method.POST, uri"$baseUrl/api/2/v/contracts/${contractId}/products/import?path=$path")
      .contentType("application/json")
      basicAuth.foreach(b => r = r.auth.basic(b.user, b.password))
      bearerToken.foreach(b => r = r.auth.bearer(b.token))
      r=r.body(body)
      r.response(asJson[Any])
}

}

