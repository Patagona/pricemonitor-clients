/**
 * Pricemonitor API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.0.5154VERSION-MANAGED-BY-JENKINS
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';
import { CustomHttpParameterCodec }                          from '../encoder';
import { Observable }                                        from 'rxjs';

import { ApiErrorResponse } from '../model/models';
import { BulkedPostProductsApiResponse } from '../model/models';
import { DeleteProductsApiResponse } from '../model/models';
import { GetExtendedTagsApiResponse } from '../model/models';
import { GetOffersResponse } from '../model/models';
import { PostOfferStatisticsRequest } from '../model/models';
import { PostProductsRequest } from '../model/models';
import { Product } from '../model/models';
import { PutProductsApiResponse } from '../model/models';
import { StatisticsByQueryApiResponse } from '../model/models';
import { TaskIdAndUrl } from '../model/models';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';



@Injectable({
  providedIn: 'root'
})
export class ProductsService {

    protected basePath = 'https://api.patagona.de';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();
    public encoder: HttpParameterCodec;

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (configuration) {
            this.configuration = configuration;
        }
        if (typeof this.configuration.basePath !== 'string') {
            if (typeof basePath !== 'string') {
                basePath = this.basePath;
            }
            this.configuration.basePath = basePath;
        }
        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();
    }



    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {
        if (typeof value === "object" && value instanceof Date === false) {
            httpParams = this.addToHttpParamsRecursive(httpParams, value);
        } else {
            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);
        }
        return httpParams;
    }

    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {
        if (value == null) {
            return httpParams;
        }

        if (typeof value === "object") {
            if (Array.isArray(value)) {
                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));
            } else if (value instanceof Date) {
                if (key != null) {
                    httpParams = httpParams.append(key,
                        (value as Date).toISOString().substr(0, 10));
                } else {
                   throw Error("key may not be null if value is Date");
                }
            } else {
                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(
                    httpParams, value[k], key != null ? `${key}.${k}` : k));
            }
        } else if (key != null) {
            httpParams = httpParams.append(key, value);
        } else {
            throw Error("key may not be null if value is not object or array");
        }
        return httpParams;
    }

    /**
     * @param contractId ID of the contract
     * @param postOfferStatisticsRequest The request body specifies which offers will be taken into account for the calculation of the offer statistics. The attribute names on the left side of the comparison filter must match the attribute names in an offer. The default use case is to specify a ComparisonFilter with a StringValueProvider on the left side pointing to the attribute productId, a SequenceOfStringValueProvider on the right side containing the productIds over which to calculate the offer statistics and a StringInSequence as a comparison. Please note that offer statistics can only be computed for 2500 products at a time.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiV3ManufacturerContractsContractIdOffersStatsQueryPost(contractId: string, postOfferStatisticsRequest: PostOfferStatisticsRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<StatisticsByQueryApiResponse>;
    public apiV3ManufacturerContractsContractIdOffersStatsQueryPost(contractId: string, postOfferStatisticsRequest: PostOfferStatisticsRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpResponse<StatisticsByQueryApiResponse>>;
    public apiV3ManufacturerContractsContractIdOffersStatsQueryPost(contractId: string, postOfferStatisticsRequest: PostOfferStatisticsRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpEvent<StatisticsByQueryApiResponse>>;
    public apiV3ManufacturerContractsContractIdOffersStatsQueryPost(contractId: string, postOfferStatisticsRequest: PostOfferStatisticsRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json'}): Observable<any> {
        if (contractId === null || contractId === undefined) {
            throw new Error('Required parameter contractId was null or undefined when calling apiV3ManufacturerContractsContractIdOffersStatsQueryPost.');
        }
        if (postOfferStatisticsRequest === null || postOfferStatisticsRequest === undefined) {
            throw new Error('Required parameter postOfferStatisticsRequest was null or undefined when calling apiV3ManufacturerContractsContractIdOffersStatsQueryPost.');
        }

        let headers = this.defaultHeaders;

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        let responseType: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }

        return this.httpClient.post<StatisticsByQueryApiResponse>(`${this.configuration.basePath}/api/v3/manufacturer/contracts/${encodeURIComponent(String(contractId))}/offers/stats/query`,
            postOfferStatisticsRequest,
            {
                responseType: <any>responseType,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Set products via CSV file
     * This operation is used to import products into the pricemonitor. This process is represented by a task, which is processed asynchronously. In the response you will receive a url which is used to check the status of the import process. &lt;br&gt;  When the process is done all products in csv file from the request body will be in the pricemonitor. Products that were already present before have been updated and new products have been added. &lt;br&gt;  Warning: All products that were in the pricemonitor before but are not present in the new import will be deleted.  Identification of the products is done based on the identifying attributes (see parameter: patagona-product-identifying-attributes)
     * @param contractId ID of the contract
     * @param contentType 
     * @param patagonaProductIdentifyingAttributes Comma separated list of csv columns that identify a product uniquely
     * @param patagonaProductName Csv column that contains the product name
     * @param patagonaProductReferencePrice Csv column that contains the reference price
     * @param patagonaDecimalSeparator Decimal separator used for parsing numbers \\ The values for patagona-decimal-separator, patagona-csv-column-separator and patagona-csv-quotation-character must be different from one another. \\ Available values: \&quot;,\&quot;, \&quot;.\&quot;
     * @param patagonaCsvColumnSeparator The csv column separator \\ The values for patagona-decimal-separator, patagona-csv-column-separator and patagona-csv-quotation-character must be different from one another.
     * @param patagonaCsvQuotationCharacter The csv quotation character \\ The values for patagona-decimal-separator, patagona-csv-column-separator and patagona-csv-quotation-character must be different from one another.
     * @param body CSV file containing the products
     * @param patagonaProductGtin Csv column that contains the gtin
     * @param patagonaProductCustomerId Csv column that contains an id (There is no requirement for this field to be unique)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiV3ManufacturerContractsContractIdProductsPut(contractId: string, contentType: 'text/csv', patagonaProductIdentifyingAttributes: string, patagonaProductName: string, patagonaProductReferencePrice: string, patagonaDecimalSeparator: string, patagonaCsvColumnSeparator: string, patagonaCsvQuotationCharacter: string, body: string, patagonaProductGtin?: string, patagonaProductCustomerId?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<PutProductsApiResponse>;
    public apiV3ManufacturerContractsContractIdProductsPut(contractId: string, contentType: 'text/csv', patagonaProductIdentifyingAttributes: string, patagonaProductName: string, patagonaProductReferencePrice: string, patagonaDecimalSeparator: string, patagonaCsvColumnSeparator: string, patagonaCsvQuotationCharacter: string, body: string, patagonaProductGtin?: string, patagonaProductCustomerId?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpResponse<PutProductsApiResponse>>;
    public apiV3ManufacturerContractsContractIdProductsPut(contractId: string, contentType: 'text/csv', patagonaProductIdentifyingAttributes: string, patagonaProductName: string, patagonaProductReferencePrice: string, patagonaDecimalSeparator: string, patagonaCsvColumnSeparator: string, patagonaCsvQuotationCharacter: string, body: string, patagonaProductGtin?: string, patagonaProductCustomerId?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpEvent<PutProductsApiResponse>>;
    public apiV3ManufacturerContractsContractIdProductsPut(contractId: string, contentType: 'text/csv', patagonaProductIdentifyingAttributes: string, patagonaProductName: string, patagonaProductReferencePrice: string, patagonaDecimalSeparator: string, patagonaCsvColumnSeparator: string, patagonaCsvQuotationCharacter: string, body: string, patagonaProductGtin?: string, patagonaProductCustomerId?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json'}): Observable<any> {
        if (contractId === null || contractId === undefined) {
            throw new Error('Required parameter contractId was null or undefined when calling apiV3ManufacturerContractsContractIdProductsPut.');
        }
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling apiV3ManufacturerContractsContractIdProductsPut.');
        }
        if (patagonaProductIdentifyingAttributes === null || patagonaProductIdentifyingAttributes === undefined) {
            throw new Error('Required parameter patagonaProductIdentifyingAttributes was null or undefined when calling apiV3ManufacturerContractsContractIdProductsPut.');
        }
        if (patagonaProductName === null || patagonaProductName === undefined) {
            throw new Error('Required parameter patagonaProductName was null or undefined when calling apiV3ManufacturerContractsContractIdProductsPut.');
        }
        if (patagonaProductReferencePrice === null || patagonaProductReferencePrice === undefined) {
            throw new Error('Required parameter patagonaProductReferencePrice was null or undefined when calling apiV3ManufacturerContractsContractIdProductsPut.');
        }
        if (patagonaDecimalSeparator === null || patagonaDecimalSeparator === undefined) {
            throw new Error('Required parameter patagonaDecimalSeparator was null or undefined when calling apiV3ManufacturerContractsContractIdProductsPut.');
        }
        if (patagonaCsvColumnSeparator === null || patagonaCsvColumnSeparator === undefined) {
            throw new Error('Required parameter patagonaCsvColumnSeparator was null or undefined when calling apiV3ManufacturerContractsContractIdProductsPut.');
        }
        if (patagonaCsvQuotationCharacter === null || patagonaCsvQuotationCharacter === undefined) {
            throw new Error('Required parameter patagonaCsvQuotationCharacter was null or undefined when calling apiV3ManufacturerContractsContractIdProductsPut.');
        }
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling apiV3ManufacturerContractsContractIdProductsPut.');
        }

        let headers = this.defaultHeaders;
        if (contentType !== undefined && contentType !== null) {
            headers = headers.set('content-type', String(contentType));
        }
        if (patagonaProductIdentifyingAttributes !== undefined && patagonaProductIdentifyingAttributes !== null) {
            headers = headers.set('patagona-product-identifying-attributes', String(patagonaProductIdentifyingAttributes));
        }
        if (patagonaProductName !== undefined && patagonaProductName !== null) {
            headers = headers.set('patagona-product-name', String(patagonaProductName));
        }
        if (patagonaProductReferencePrice !== undefined && patagonaProductReferencePrice !== null) {
            headers = headers.set('patagona-product-reference-price', String(patagonaProductReferencePrice));
        }
        if (patagonaProductGtin !== undefined && patagonaProductGtin !== null) {
            headers = headers.set('patagona-product-gtin', String(patagonaProductGtin));
        }
        if (patagonaProductCustomerId !== undefined && patagonaProductCustomerId !== null) {
            headers = headers.set('patagona-product-customer-id', String(patagonaProductCustomerId));
        }
        if (patagonaDecimalSeparator !== undefined && patagonaDecimalSeparator !== null) {
            headers = headers.set('patagona-decimal-separator', String(patagonaDecimalSeparator));
        }
        if (patagonaCsvColumnSeparator !== undefined && patagonaCsvColumnSeparator !== null) {
            headers = headers.set('patagona-csv-column-separator', String(patagonaCsvColumnSeparator));
        }
        if (patagonaCsvQuotationCharacter !== undefined && patagonaCsvQuotationCharacter !== null) {
            headers = headers.set('patagona-csv-quotation-character', String(patagonaCsvQuotationCharacter));
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'text/csv'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        let responseType: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }

        return this.httpClient.put<PutProductsApiResponse>(`${this.configuration.basePath}/api/v3/manufacturer/contracts/${encodeURIComponent(String(contractId))}/products`,
            body,
            {
                responseType: <any>responseType,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * @param contractId ID of the contract
     * @param postOfferStatisticsRequest The request body specifies which offers will be taken into account for the calculation of the offer statistics. The attribute names on the left side of the comparison filter must match the attribute names in an offer. The default use case is to specify a ComparisonFilter with a StringValueProvider on the left side pointing to the attribute productId, a SequenceOfStringValueProvider on the right side containing the productIds over which to calculate the offer statistics and a StringInSequence as a comparison. Please note that offer statistics can only be computed for 2500 products at a time.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiV3VendorContractsContractIdOffersStatsQueryPost(contractId: string, postOfferStatisticsRequest: PostOfferStatisticsRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<StatisticsByQueryApiResponse>;
    public apiV3VendorContractsContractIdOffersStatsQueryPost(contractId: string, postOfferStatisticsRequest: PostOfferStatisticsRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpResponse<StatisticsByQueryApiResponse>>;
    public apiV3VendorContractsContractIdOffersStatsQueryPost(contractId: string, postOfferStatisticsRequest: PostOfferStatisticsRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpEvent<StatisticsByQueryApiResponse>>;
    public apiV3VendorContractsContractIdOffersStatsQueryPost(contractId: string, postOfferStatisticsRequest: PostOfferStatisticsRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json'}): Observable<any> {
        if (contractId === null || contractId === undefined) {
            throw new Error('Required parameter contractId was null or undefined when calling apiV3VendorContractsContractIdOffersStatsQueryPost.');
        }
        if (postOfferStatisticsRequest === null || postOfferStatisticsRequest === undefined) {
            throw new Error('Required parameter postOfferStatisticsRequest was null or undefined when calling apiV3VendorContractsContractIdOffersStatsQueryPost.');
        }

        let headers = this.defaultHeaders;

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        let responseType: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }

        return this.httpClient.post<StatisticsByQueryApiResponse>(`${this.configuration.basePath}/api/v3/vendor/contracts/${encodeURIComponent(String(contractId))}/offers/stats/query`,
            postOfferStatisticsRequest,
            {
                responseType: <any>responseType,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Add products in bulk
     * This operation is used to import products into the pricemonitor:&lt;br&gt; Products that are already present will be updated and new products will be added. Identification of the products is done based on the identifying attributes, which need to be provided via the request body.&lt;br&gt;&lt;br&gt; Attention:&lt;br&gt; This endpoint should only be used when dealing with large number of products at your side is an issue. Otherwise please use the PUT-counterpart of this endpoint which accepts products via a csv file.&lt;br&gt;&lt;br&gt; Note:&lt;br&gt; This endpoint should be used in conjunction with: DELETE  /api/v3/vendor/contracts/{contractId}/products.&lt;br&gt;&lt;br&gt; Procedure:&lt;br&gt; 1. Add your products in bulks with multiple requests via this endpoint.&lt;br&gt; 2. Send a DELETE request to /api/v3/vendor/contracts/{contractId}/products    and set the parameter updatedMax to a date which is older or equal to your first request from step 1.
     * @param contractId ID of the contract
     * @param contentType 
     * @param patagonaTagsDecimalSeparator The decimal separator is used for parsing numbers in tags. English and German number formats are supported: dot and comma.
     * @param postProductsRequest The body contains the products which should be added
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiV3VendorContractsContractIdProductsPost(contractId: string, contentType: 'application/json', patagonaTagsDecimalSeparator: '.' | ',', postProductsRequest: PostProductsRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<BulkedPostProductsApiResponse>;
    public apiV3VendorContractsContractIdProductsPost(contractId: string, contentType: 'application/json', patagonaTagsDecimalSeparator: '.' | ',', postProductsRequest: PostProductsRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpResponse<BulkedPostProductsApiResponse>>;
    public apiV3VendorContractsContractIdProductsPost(contractId: string, contentType: 'application/json', patagonaTagsDecimalSeparator: '.' | ',', postProductsRequest: PostProductsRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpEvent<BulkedPostProductsApiResponse>>;
    public apiV3VendorContractsContractIdProductsPost(contractId: string, contentType: 'application/json', patagonaTagsDecimalSeparator: '.' | ',', postProductsRequest: PostProductsRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json'}): Observable<any> {
        if (contractId === null || contractId === undefined) {
            throw new Error('Required parameter contractId was null or undefined when calling apiV3VendorContractsContractIdProductsPost.');
        }
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling apiV3VendorContractsContractIdProductsPost.');
        }
        if (patagonaTagsDecimalSeparator === null || patagonaTagsDecimalSeparator === undefined) {
            throw new Error('Required parameter patagonaTagsDecimalSeparator was null or undefined when calling apiV3VendorContractsContractIdProductsPost.');
        }
        if (postProductsRequest === null || postProductsRequest === undefined) {
            throw new Error('Required parameter postProductsRequest was null or undefined when calling apiV3VendorContractsContractIdProductsPost.');
        }

        let headers = this.defaultHeaders;
        if (contentType !== undefined && contentType !== null) {
            headers = headers.set('content-type', String(contentType));
        }
        if (patagonaTagsDecimalSeparator !== undefined && patagonaTagsDecimalSeparator !== null) {
            headers = headers.set('patagona-tags-decimal-separator', String(patagonaTagsDecimalSeparator));
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        let responseType: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }

        return this.httpClient.post<BulkedPostProductsApiResponse>(`${this.configuration.basePath}/api/v3/vendor/contracts/${encodeURIComponent(String(contractId))}/products`,
            postProductsRequest,
            {
                responseType: <any>responseType,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Set products via CSV file
     * This operation is used to import products into the pricemonitor. This process is represented by a task, which is processed asynchronously. In the response you will receive a url which is used to check the status of the import process. &lt;br&gt;  When the process is done all products in csv file from the request body will be in the pricemonitor. Products that were already present before have been updated and new products have been added. &lt;br&gt;  Warning: All products that were in the pricemonitor before but are not present in the new import will be deleted.  Identification of the products is done based on the identifying attributes (see parameter: patagona-product-identifying-attributes)
     * @param contractId ID of the contract
     * @param contentType 
     * @param patagonaProductIdentifyingAttributes Comma separated list of csv columns that identify a product uniquely
     * @param patagonaProductName Csv column that contains the product name
     * @param patagonaProductReferencePrice Csv column that contains the reference price
     * @param patagonaProductMinPrice Csv column that contains the min price
     * @param patagonaProductMaxPrice Csv column that contains the max price
     * @param patagonaDecimalSeparator Decimal separator used for parsing numbers \\ The values for patagona-decimal-separator, patagona-csv-column-separator and patagona-csv-quotation-character must be different from one another. \\ Available values: \&quot;,\&quot;, \&quot;.\&quot;
     * @param patagonaCsvColumnSeparator The csv column separator \\ It can be provided either as text or as Base64 encoded string (e.g. needed for tab as separator). \\ The values for patagona-decimal-separator, patagona-csv-column-separator and patagona-csv-quotation-character must be different from one another.
     * @param patagonaCsvQuotationCharacter The csv quotation character \\ The values for patagona-decimal-separator, patagona-csv-column-separator and patagona-csv-quotation-character must be different from one another.
     * @param body CSV file containing the products
     * @param patagonaProductGtin Csv column that contains the gtin
     * @param patagonaProductCustomerId Csv column that contains an id (There is no requirement for this field to be unique)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiV3VendorContractsContractIdProductsPut(contractId: string, contentType: 'text/csv', patagonaProductIdentifyingAttributes: string, patagonaProductName: string, patagonaProductReferencePrice: string, patagonaProductMinPrice: string, patagonaProductMaxPrice: string, patagonaDecimalSeparator: string, patagonaCsvColumnSeparator: string, patagonaCsvQuotationCharacter: string, body: string, patagonaProductGtin?: string, patagonaProductCustomerId?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<PutProductsApiResponse>;
    public apiV3VendorContractsContractIdProductsPut(contractId: string, contentType: 'text/csv', patagonaProductIdentifyingAttributes: string, patagonaProductName: string, patagonaProductReferencePrice: string, patagonaProductMinPrice: string, patagonaProductMaxPrice: string, patagonaDecimalSeparator: string, patagonaCsvColumnSeparator: string, patagonaCsvQuotationCharacter: string, body: string, patagonaProductGtin?: string, patagonaProductCustomerId?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpResponse<PutProductsApiResponse>>;
    public apiV3VendorContractsContractIdProductsPut(contractId: string, contentType: 'text/csv', patagonaProductIdentifyingAttributes: string, patagonaProductName: string, patagonaProductReferencePrice: string, patagonaProductMinPrice: string, patagonaProductMaxPrice: string, patagonaDecimalSeparator: string, patagonaCsvColumnSeparator: string, patagonaCsvQuotationCharacter: string, body: string, patagonaProductGtin?: string, patagonaProductCustomerId?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpEvent<PutProductsApiResponse>>;
    public apiV3VendorContractsContractIdProductsPut(contractId: string, contentType: 'text/csv', patagonaProductIdentifyingAttributes: string, patagonaProductName: string, patagonaProductReferencePrice: string, patagonaProductMinPrice: string, patagonaProductMaxPrice: string, patagonaDecimalSeparator: string, patagonaCsvColumnSeparator: string, patagonaCsvQuotationCharacter: string, body: string, patagonaProductGtin?: string, patagonaProductCustomerId?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json'}): Observable<any> {
        if (contractId === null || contractId === undefined) {
            throw new Error('Required parameter contractId was null or undefined when calling apiV3VendorContractsContractIdProductsPut.');
        }
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling apiV3VendorContractsContractIdProductsPut.');
        }
        if (patagonaProductIdentifyingAttributes === null || patagonaProductIdentifyingAttributes === undefined) {
            throw new Error('Required parameter patagonaProductIdentifyingAttributes was null or undefined when calling apiV3VendorContractsContractIdProductsPut.');
        }
        if (patagonaProductName === null || patagonaProductName === undefined) {
            throw new Error('Required parameter patagonaProductName was null or undefined when calling apiV3VendorContractsContractIdProductsPut.');
        }
        if (patagonaProductReferencePrice === null || patagonaProductReferencePrice === undefined) {
            throw new Error('Required parameter patagonaProductReferencePrice was null or undefined when calling apiV3VendorContractsContractIdProductsPut.');
        }
        if (patagonaProductMinPrice === null || patagonaProductMinPrice === undefined) {
            throw new Error('Required parameter patagonaProductMinPrice was null or undefined when calling apiV3VendorContractsContractIdProductsPut.');
        }
        if (patagonaProductMaxPrice === null || patagonaProductMaxPrice === undefined) {
            throw new Error('Required parameter patagonaProductMaxPrice was null or undefined when calling apiV3VendorContractsContractIdProductsPut.');
        }
        if (patagonaDecimalSeparator === null || patagonaDecimalSeparator === undefined) {
            throw new Error('Required parameter patagonaDecimalSeparator was null or undefined when calling apiV3VendorContractsContractIdProductsPut.');
        }
        if (patagonaCsvColumnSeparator === null || patagonaCsvColumnSeparator === undefined) {
            throw new Error('Required parameter patagonaCsvColumnSeparator was null or undefined when calling apiV3VendorContractsContractIdProductsPut.');
        }
        if (patagonaCsvQuotationCharacter === null || patagonaCsvQuotationCharacter === undefined) {
            throw new Error('Required parameter patagonaCsvQuotationCharacter was null or undefined when calling apiV3VendorContractsContractIdProductsPut.');
        }
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling apiV3VendorContractsContractIdProductsPut.');
        }

        let headers = this.defaultHeaders;
        if (contentType !== undefined && contentType !== null) {
            headers = headers.set('content-type', String(contentType));
        }
        if (patagonaProductIdentifyingAttributes !== undefined && patagonaProductIdentifyingAttributes !== null) {
            headers = headers.set('patagona-product-identifying-attributes', String(patagonaProductIdentifyingAttributes));
        }
        if (patagonaProductName !== undefined && patagonaProductName !== null) {
            headers = headers.set('patagona-product-name', String(patagonaProductName));
        }
        if (patagonaProductReferencePrice !== undefined && patagonaProductReferencePrice !== null) {
            headers = headers.set('patagona-product-reference-price', String(patagonaProductReferencePrice));
        }
        if (patagonaProductMinPrice !== undefined && patagonaProductMinPrice !== null) {
            headers = headers.set('patagona-product-min-price', String(patagonaProductMinPrice));
        }
        if (patagonaProductMaxPrice !== undefined && patagonaProductMaxPrice !== null) {
            headers = headers.set('patagona-product-max-price', String(patagonaProductMaxPrice));
        }
        if (patagonaProductGtin !== undefined && patagonaProductGtin !== null) {
            headers = headers.set('patagona-product-gtin', String(patagonaProductGtin));
        }
        if (patagonaProductCustomerId !== undefined && patagonaProductCustomerId !== null) {
            headers = headers.set('patagona-product-customer-id', String(patagonaProductCustomerId));
        }
        if (patagonaDecimalSeparator !== undefined && patagonaDecimalSeparator !== null) {
            headers = headers.set('patagona-decimal-separator', String(patagonaDecimalSeparator));
        }
        if (patagonaCsvColumnSeparator !== undefined && patagonaCsvColumnSeparator !== null) {
            headers = headers.set('patagona-csv-column-separator', String(patagonaCsvColumnSeparator));
        }
        if (patagonaCsvQuotationCharacter !== undefined && patagonaCsvQuotationCharacter !== null) {
            headers = headers.set('patagona-csv-quotation-character', String(patagonaCsvQuotationCharacter));
        }

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'text/csv'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        let responseType: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }

        return this.httpClient.put<PutProductsApiResponse>(`${this.configuration.basePath}/api/v3/vendor/contracts/${encodeURIComponent(String(contractId))}/products`,
            body,
            {
                responseType: <any>responseType,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete products
     * Delete all products or delete products by a last updated timestamp.
     * @param contractId ID of the contract
     * @param updatedMax Last updated timestamp of products, formatted as ISO Date (i.e. 2019-11-20T13:46:13Z) in UTC.&lt;br&gt; Products can be deleted which haven\&#39;t been updated since the specified timestamp.&lt;br&gt; If the query parameter is missing all products are deleted.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteProducts(contractId: string, updatedMax?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<DeleteProductsApiResponse>;
    public deleteProducts(contractId: string, updatedMax?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpResponse<DeleteProductsApiResponse>>;
    public deleteProducts(contractId: string, updatedMax?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpEvent<DeleteProductsApiResponse>>;
    public deleteProducts(contractId: string, updatedMax?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json'}): Observable<any> {
        if (contractId === null || contractId === undefined) {
            throw new Error('Required parameter contractId was null or undefined when calling deleteProducts.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (updatedMax !== undefined && updatedMax !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>updatedMax, 'updatedMax');
        }

        let headers = this.defaultHeaders;

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        let responseType: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }

        return this.httpClient.delete<DeleteProductsApiResponse>(`${this.configuration.basePath}/api/v3/vendor/contracts/${encodeURIComponent(String(contractId))}/products`,
            {
                params: queryParameters,
                responseType: <any>responseType,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Return the extended tags for the given product
     * @param contractId ID of the contract
     * @param productId ID of the product
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getExtendedTags(contractId: string, productId: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<GetExtendedTagsApiResponse>;
    public getExtendedTags(contractId: string, productId: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpResponse<GetExtendedTagsApiResponse>>;
    public getExtendedTags(contractId: string, productId: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpEvent<GetExtendedTagsApiResponse>>;
    public getExtendedTags(contractId: string, productId: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json'}): Observable<any> {
        if (contractId === null || contractId === undefined) {
            throw new Error('Required parameter contractId was null or undefined when calling getExtendedTags.');
        }
        if (productId === null || productId === undefined) {
            throw new Error('Required parameter productId was null or undefined when calling getExtendedTags.');
        }

        let headers = this.defaultHeaders;

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        let responseType: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }

        return this.httpClient.get<GetExtendedTagsApiResponse>(`${this.configuration.basePath}/api/v3/vendor/contracts/${encodeURIComponent(String(contractId))}/products/${encodeURIComponent(String(productId))}/extendedtags`,
            {
                responseType: <any>responseType,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get all offers for all products
     * @param contractId ID of the contract
     * @param start Start product index for pagination
     * @param limit Number of products for pagination
     * @param startDate Timestamp of start of time range, formatted as ISO Date (i.e. 2018-04-06T13:46:13Z) in UTC. If this value is omitted, the range is \&#39;{endDate} - 48 hours to {endDate}\&#39; if {endDate} is given or NOW - 48 hours if both are omitted.
     * @param endDate Timestamp of end of time range, formatted as ISO Date (i.e. 2018-04-06T13:46:13Z) in UTC. If this value is omitted, the range is \&#39;{startDate} to {startDate} + 48 hours\&#39; if {startDate} is given or NOW - 48 hours if both are omitted.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getOffers(contractId: string, start: number, limit: number, startDate?: string, endDate?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<GetOffersResponse>;
    public getOffers(contractId: string, start: number, limit: number, startDate?: string, endDate?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpResponse<GetOffersResponse>>;
    public getOffers(contractId: string, start: number, limit: number, startDate?: string, endDate?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpEvent<GetOffersResponse>>;
    public getOffers(contractId: string, start: number, limit: number, startDate?: string, endDate?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json'}): Observable<any> {
        if (contractId === null || contractId === undefined) {
            throw new Error('Required parameter contractId was null or undefined when calling getOffers.');
        }
        if (start === null || start === undefined) {
            throw new Error('Required parameter start was null or undefined when calling getOffers.');
        }
        if (limit === null || limit === undefined) {
            throw new Error('Required parameter limit was null or undefined when calling getOffers.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (start !== undefined && start !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>start, 'start');
        }
        if (limit !== undefined && limit !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>limit, 'limit');
        }
        if (startDate !== undefined && startDate !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>startDate, 'startDate');
        }
        if (endDate !== undefined && endDate !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>endDate, 'endDate');
        }

        let headers = this.defaultHeaders;

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        let responseType: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }

        return this.httpClient.get<GetOffersResponse>(`${this.configuration.basePath}/api/2/v/contracts/${encodeURIComponent(String(contractId))}/result/offers`,
            {
                params: queryParameters,
                responseType: <any>responseType,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get all products
     * @param contractId ID of the contract
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getProducts(contractId: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<Array<Product>>;
    public getProducts(contractId: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpResponse<Array<Product>>>;
    public getProducts(contractId: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpEvent<Array<Product>>>;
    public getProducts(contractId: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json'}): Observable<any> {
        if (contractId === null || contractId === undefined) {
            throw new Error('Required parameter contractId was null or undefined when calling getProducts.');
        }

        let headers = this.defaultHeaders;

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        let responseType: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }

        return this.httpClient.get<Array<Product>>(`${this.configuration.basePath}/api/2/v/contracts/${encodeURIComponent(String(contractId))}/products`,
            {
                responseType: <any>responseType,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Set products via CSV file
     * Warning: Deletes all existing products.         &lt;br/&gt;Note that this will not happen immediately. Instead, you receive the ID of a task that has been created.         &lt;br/&gt;Furthermore you receive an URL which you can use to check if the task was executed successfully.         &lt;br&gt;The csv file must contain following columns:         &lt;ul&gt;           &lt;li&gt;productId - arbitrary string, can be used for the systems product id.&lt;/li&gt;           &lt;li&gt;gtin - the GTIN of the product           &lt;li&gt;description - name or short description of the product           &lt;li&gt;referencePrice - arbitrary decimal number, usually the current price or recommended retail price (gross)           &lt;li&gt;minPriceBoundary - decimal number defining the lower price boundary (gross)           &lt;li&gt;maxPriceBoundary - decimal number defining the upper price boundary (gross)           &lt;li&gt;Additional columns are added as product tags. Tags are used for repricing strategies and several other           purpose.         &lt;/ul&gt;         &lt;br/&gt;Column separator must be semicolon, the decimal separator must be dot. File encoding must be UTF-8.
     * @param contractId ID of the contract
     * @param body CSV file containing the products
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public putCSVProducts(contractId: string, body: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<any>;
    public putCSVProducts(contractId: string, body: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpResponse<any>>;
    public putCSVProducts(contractId: string, body: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpEvent<any>>;
    public putCSVProducts(contractId: string, body: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json'}): Observable<any> {
        if (contractId === null || contractId === undefined) {
            throw new Error('Required parameter contractId was null or undefined when calling putCSVProducts.');
        }
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling putCSVProducts.');
        }

        let headers = this.defaultHeaders;

        // authentication (BasicAuth) required
        if (this.configuration.username || this.configuration.password) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password));
        }
        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'text/csv'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        let responseType: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }

        return this.httpClient.put<any>(`${this.configuration.basePath}/api/2/v/contracts/${encodeURIComponent(String(contractId))}/products/csv`,
            body,
            {
                responseType: <any>responseType,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
